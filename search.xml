<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java中的注解和反射</title>
    <url>/2025/03/11/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>在学习Spring的时候, 经常看见在 writing</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的Stream</title>
    <url>/2025/03/10/Java%E4%B8%AD%E7%9A%84Stream/</url>
    <content><![CDATA[<p>Java中的Stream是一个非常令人兴奋的特性, 它能够让程序员在很多情况下结合很多时间并且写出不容易出错的代码(并非容易调试), 下面介绍一下这个特性.</p>
<span id="more"></span>
<p>下面这个视频是B站最受好评的Stream教学:<br />
<a href="https://www.bilibili.com/video/BV1Vi421C73n">Java中的流、并行流 - Java Stream API | Parallel Streams</a></p>
<h1 id="stream流的分类"><a class="markdownIt-Anchor" href="#stream流的分类"></a> Stream流的分类</h1>
<h2 id="通用对象流streamt"><a class="markdownIt-Anchor" href="#通用对象流streamt"></a> 通用对象流<code>Stream&lt;T&gt;</code></h2>
<p>这是一个处理泛型对象的流, 适用于所有的对象类型. 也算是最常见的流. 例如: <code>Stream&lt;String&gt; stream = list.stream();</code></p>
<h2 id="基本类型的流"><a class="markdownIt-Anchor" href="#基本类型的流"></a> 基本类型的流</h2>
<p>有三种:</p>
<ul>
<li><code>IntStream</code></li>
<li><code>LongStream</code></li>
<li><code>DoubleStream</code></li>
</ul>
<p>例如:<br />
<code>IntStream numbers = IntStream.range(1, 10);</code></p>
<h2 id="并行流和顺序流"><a class="markdownIt-Anchor" href="#并行流和顺序流"></a> 并行流和顺序流</h2>
<p>java里面的并行流对于程序员来说是透明的. 也就是说, <code>list.stream()</code>返回的类型是<code>Stream&lt;&gt;</code>, 而<code>parallelStream()</code>返回类型也还是<code>Stream&lt;&gt;</code>. 这里详细说明一下并行流的一些例子.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">		.parallelStream()</span><br><span class="line">		.map(String::toLowerCase)</span><br><span class="line">		.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>这样打印的话, 不能保证字母按照顺序出现. 因为parallelStream会将一个完整的流分割成各个小块, 每个小块会执行<strong>整个流水线操作</strong>(包括所有中间操作和终结操作), 并行流会把map和forEach合并为一个复合任务. 也就说, 从parallelStream开始分开, 然后对于每一个块执行后续操作.</p>
<p>对于终结方法来说, 难道就没有办法保证后续的顺序了吗? 那还是有的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">		.parallelStream()</span><br><span class="line">		.map(String::toLowerCase)</span><br><span class="line">		.forEachOrdered(System.out::println);</span><br></pre></td></tr></table></figure>
<p>这里会保证顺序打印, 那么forEachOrdered是如何做到的呢? 在parallelStream分开不同块之后, forEachOrdered会按照顺序执行, 所有线程共用一个forEachOrdered, forEachOrdered会按照顺序来执行, 注意, forEachOrdered并不是等到所有线程的中间操作执行完成之后再执行. 例如一号块中间操作已经完成, 但是2号块还没有, 这种情况下还是会执行forEachOrdered.</p>
<h2 id="其他流类型"><a class="markdownIt-Anchor" href="#其他流类型"></a> 其他流类型</h2>
<p>也可以通过 <code>Stream.generate()</code> 或 <code>Stream.iterate()</code> 动态生成元素.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Double&gt; randomStream = Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; evenNumbers = Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>这里<code>Stream.generate()</code>的形参是一个<code>Supplier&lt;? extends T&gt; s</code>, 也就是常见的一个函数式接口.</p>
<h1 id="非终结方法"><a class="markdownIt-Anchor" href="#非终结方法"></a> 非终结方法</h1>
<p>所谓非终结方法, 也就是中间操作. 中间操作分为<strong>有状态</strong>操作和<strong>无状态</strong>操作. 所谓有状态, 一般都是不能并行, 也就是当前元素的操作需要和已经过去的元素有关系.</p>
<ul>
<li><code>filter(Predicate&lt;? super T&gt; predicate)</code></li>
<li><code>map(Function&lt;? super T, ? extends R&gt; mapper)</code></li>
<li><code>flatMap(Function&lt;? super T, ? extends Stream&lt;R&gt;&gt; mapper)</code><br />
flatmap作用是, 把一个流里面的每一个元素也变成一个流, 然后把许多流最后再合并成一个流. 例如: <code>Stream&lt;String&gt; words = lines.stream().flatMap(line -&gt; Arrays.stream(line.split(&quot; &quot;)));</code></li>
<li><code>peek(Consumer&lt;? super T&gt; action)</code></li>
</ul>
<p>上面都是一些常用的操作, 值得注意的是, map一系列操作里面有很多mapToInt这样的操作, 是可以实现在对象流和基本类型流之间转换的操作.</p>
<p>下面就是一些<strong>有状态</strong>的操作:</p>
<ul>
<li><code>distinct()</code></li>
<li><code>sorted()</code></li>
<li><code>limit(long maxSize)</code></li>
<li><code>skip(long n)</code></li>
</ul>
<p>其中sorted函数也可以接受一个比较器. 再次重申, 比较器<code>compare(T o1, T o2)</code>, 如果是负值, 就表示第一个数字比较小. 所以可以记作减法. 而排序是&quot;大&quot;的排在后面.</p>
<p>值得注意的是还有一些操作也很有意思:</p>
<ul>
<li><code>parallel()</code></li>
<li><code>sequential()</code></li>
<li><code>unordered()</code></li>
</ul>
<p>第一个是把流变成并行, 第二个是把流变成串行, 最后一个是允许乱序执行, 这可能会提高性能表现.</p>
<h1 id="终结方法"><a class="markdownIt-Anchor" href="#终结方法"></a> 终结方法</h1>
<p>终结方法就是对一个流经过遍历以及变换操作之后, 最后要对这一系列数字做什么.</p>
<ul>
<li><code>collect(Collectors.toList())</code></li>
<li><code>reduce()、sum()、average()</code></li>
<li><code>findFirst()、max()、min()</code></li>
<li><code>forEach()</code></li>
<li><code>anyMatch()、allMatch()、noneMatch()</code></li>
</ul>
<p>先说collect, 我们可以看一下collect的方法签名:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>
<p>这个签名是在Stream里面的, 如果是在IntStream里面的话, 会有一些不同:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">                  ObjIntConsumer&lt;R&gt; accumulator,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>
<p>我们就以Stream里面的collect来作为例子, 这三个参数的作用分别是:</p>
<blockquote>
<p>Params:<br />
supplier – a function that creates a new mutable result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.</p>
<p>accumulator – an associative, non-interfering, stateless function that must fold an element into a result container.</p>
<p>combiner – an associative, non-interfering, stateless function that accepts two partial result containers and merges them, which must be compatible with the accumulator function. The combiner function must fold the elements from the second result container into the first result container.</p>
</blockquote>
<p>下面是示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; asList = stringStream.collect(ArrayList::<span class="keyword">new</span>,ArrayList::add,ArrayList::addAll);</span><br><span class="line"><span class="type">String</span> <span class="variable">concat</span> <span class="operator">=</span> stringStream.collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::append, StringBuilder::append).toString();</span><br></pre></td></tr></table></figure>
<p>大概就是, 第一个参数决定需要收集到什么容器里面, 第二个参数提供把流中元素放到容器中的方法, 而第三个参数在处理并行流时候至关重要. 因为并行流可能会产生多个容器, 那如何合并这些容器, 也需要提供一个方法. 在上面的例子里面, 代码的方法都是使用<strong>方法引用</strong>这种语法, 实际也可以写lambda表达式.</p>
<p>collect也可以是下面这个参数: <code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</code></p>
<p>代码长下面这个样子: <code>List&lt;String&gt; asList = stringStream.collect(Collectors.toList());</code></p>
<p>这个其实更加像是写好了的方法, 可以Collectors.toList()还可以Collectors.toCollection()这样的. 我们可以看下面这一段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;T&gt;&gt;</span><br><span class="line">    Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,</span><br><span class="line">                                   (r1, r2) -&gt; &#123; r1.addAll(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">                                   CH_ID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看见下面的三个参数, 确实也是类似supplier, accumulator以及combiner的结构. 在java较新的版本中, 还提供一个更加简单的toList()方法, 但是这个方法返回的List是不可变的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (List&lt;T&gt;) Collections.unmodifiableList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="built_in">this</span>.toArray())));</span><br></pre></td></tr></table></figure>
<p>它可以直接跟在流后面, 而不需要collect.</p>
<p>关于reduce, sum, average. reduce方法是最灵活的, 可以对流里面的对象进行某种累计操作:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(numbers).reduce(<span class="number">0</span>, (subtotal, element) -&gt; subtotal + element);</span><br></pre></td></tr></table></figure>
<p>这里第一项写的是最开始的和, 第二项是lambda表达式, 参数的名字已经很明确了. 说明element如何被作用到整体, 如果像上面这样写, 最后算的就是累加.</p>
<p>sum和average主要更用在<strong>数值流</strong>, 计算平均值和总和.</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC和Spring以及SpringBoot的区别</title>
    <url>/2025/03/08/SpringMVC%E5%92%8CSpring%E4%BB%A5%E5%8F%8ASpringBoot%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>我觉得还是有必要详细研究这三者的区别. 在学习过程中经常会混淆这几个概念.</p>
<span id="more"></span>
<h1 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> Spring</h1>
<p>首先是Spring, Spring是一个很基础的框架, 提供了IOC和AOP, 现在我们来理解一下IOC和AOP是什么.</p>
<blockquote>
<p>IOC容器（Inversion of Control Container） 是Spring框架的核心组件，它通过控制反转和依赖注入（DI）来管理应用程序中对象（Bean）的生命周期和依赖关系。它的核心目标是降低代码的耦合度，使对象之间的关系由容器动态管理，而非硬编码在代码中。</p>
</blockquote>
<p>那么控制反转和依赖注入如何降低代码耦合度呢? 先来看一段代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口：消息服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类1：邮件服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送邮件：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类2：短信服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送短信：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端：直接创建服务实例（高耦合）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接new一个具体的实现类</span></span><br><span class="line">        <span class="type">MessageService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmailService</span>();</span><br><span class="line">        service.send(<span class="string">&quot;Hello, this is a message!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这些代码为什么是高耦合. 因为Client这个类的实现里面出现了具体的EmailService, 假如想要切换成SMSService那么需要改动实现类的代码, 假如想要添加新的通知的实现类那么也需要改动代码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置类：告诉Spring如何创建Bean（对象）</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 定义Bean：选择EmailService作为MessageService的实现</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageService <span class="title function_">messageService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmailService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端不再直接创建对象，而是通过注入获取</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">// 通过@Autowired注入MessageService实例</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        messageService.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动Spring容器，加载配置类</span></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从容器中获取Client实例（Spring自动注入依赖）</span></span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> context.getBean(Client.class);</span><br><span class="line">        client.send(<span class="string">&quot;Hello, this is a message!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里这个Client类通过@AutoWired注解, 不需要初始化messageService这个变量. 但是Spring是怎么知道我需要用这个函数生成的实例来注入呢, 这是因为<strong>Bean 的装配和依赖注入的逻辑核心是类型匹配</strong>. 这里注册之后只有这一个位置的是满足MessageService类型, 故会在这里注入.</p>
<p>假如是这样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageService <span class="title function_">emailService</span><span class="params">()</span> &#123; <span class="comment">// 类型是 MessageService</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmailService</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageService <span class="title function_">smsService</span><span class="params">()</span> &#123; <span class="comment">// 类型也是 MessageService</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SMSService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring就会抛出<strong>NoUniqueBeanDefinitionException</strong>异常了. 这就是依赖注入(Dependency injection).</p>
<p>控制反转(Inversion of Container)的含义就是, 原本是Client类自己来控制创建messageService, 现在由Spring来控制, 通过依赖注入来控制. 这个&quot;容器&quot;的意思就是交给spring控制.</p>
<h1 id="springmvc"><a class="markdownIt-Anchor" href="#springmvc"></a> SpringMVC</h1>
<p>特别注意, MVC这个单词是一种软件架构模式, Model-View-Controller. 在使用SpringMVC开发web应用的时候, 需要先给Maven项目添加依赖, 这一点并不麻烦, 然后需要配置web.xml和spring-mvc.xml这两个文件, AI给出的示例XML在下面:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-mvc.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example.controller&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 开启注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>与其解释这些配置文件的作用, 不如反问为什么SpringBoot不需要这些配置文件.</p>
<p>generated by Qwen-QwQ-32B</p>
<table>
<thead>
<tr>
<th><strong>配置项</strong></th>
<th><strong>传统 Spring MVC</strong></th>
<th><strong>Spring Boot</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>部署描述符</strong></td>
<td>必须通过 <code>web.xml</code> 配置 <code>DispatcherServlet</code>、Filter、Listener 等。</td>
<td>无需 <code>web.xml</code>，通过 <code>@SpringBootApplication</code> 自动配置。</td>
</tr>
<tr>
<td><strong>Spring MVC 配置</strong></td>
<td>需通过 <code>spring-mvc.xml</code> 显式配置组件扫描、视图解析器、静态资源等。</td>
<td>通过注解和少量 Java 配置类（如 <code>WebMvcConfigurer</code>）实现，默认配置已满足大部分需求。</td>
</tr>
<tr>
<td><strong>静态资源处理</strong></td>
<td>需手动配置 <code>mvc:resources</code> 或 <code>mvc:default-servlet-handler</code>。</td>
<td>默认支持 <code>/static</code>、<code>/public</code> 等目录，无需额外配置。</td>
</tr>
<tr>
<td><strong>编码过滤器</strong></td>
<td>需在 <code>web.xml</code> 中手动配置 <code>CharacterEncodingFilter</code>。</td>
<td>通过 <code>spring.http.encoding.charset=UTF-8</code> 自动配置编码。</td>
</tr>
<tr>
<td><strong>启动方式</strong></td>
<td>需部署到 Tomcat 等服务器，通过 WAR 文件运行。</td>
<td>直接运行 <code>main</code> 方法，内置 Tomcat 启动。</td>
</tr>
<tr>
<td>特别值得一提的是, SpringMVC应用最后生成WAR包, 然后丢到Tomcat等服务器中运行.</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>例如：</p>
<ul>
<li>配置<code>web.xml</code>定义<code>DispatcherServlet</code>。</li>
<li>通过Tomcat的<code>webapps</code>目录部署WAR包。</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的MVC架构</title>
    <url>/2025/03/08/Spring%E4%B8%AD%E7%9A%84MVC%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>study</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>从TreeMap看红黑树的具体实现</title>
    <url>/2025/02/09/%E4%BB%8ETreeMap%E7%9C%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>writing</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的foreach</title>
    <url>/2025/01/25/java%E4%B8%AD%E7%9A%84foreach/</url>
    <content><![CDATA[<p>在学习java的时候, 遇到了这个foreach语句. 于是写一篇文章讨论一下这一段源代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">	Objects.requireNonNull(action);</span><br><span class="line">	<span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> <span class="built_in">this</span>.modCount;</span><br><span class="line">	Object[] es = <span class="built_in">this</span>.elementData;</span><br><span class="line">	<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="built_in">this</span>.modCount == expectedModCount &amp;&amp; i &lt; size; ++i) &#123;</span><br><span class="line">		action.accept(elementAt(es, i));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.modCount != expectedModCount) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其中, 我们先简单解释其他语句的作用. <code>Objects.requireNonNull(action);</code>作用是判断传入的<strong>对象实例</strong>是不是为空. 要是为空就直接抛出异常了. 然后是所谓modCount, 这个成员变量实际上是ArrayList里面检查多线程修改错误的一个常见的方式, 大概意思就是在foreach的时候不能修改就是了.</p>
<p>然后就是中间的最关键的, 在ArrayList的实现里面, 实际上就是一个下标遍历, 然后把自己的数据传入给action实例的accept方法.</p>
<p>我们也可以看看Consumer到底是个什么:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; &#123;</span><br><span class="line">            <span class="built_in">this</span>.accept(t);</span><br><span class="line">            after.accept(t);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现这是一个<code>@FunctionalInterface</code>, 意思是这是一个<strong>函数式接口</strong>, 仅仅包含一个抽象方法. 这样规定是为了后面可以用lambda表达式来简化.</p>
<p>所以现在我们来讨论接收参数中的<code>Consumer&lt;? super E&gt; action</code>到底是什么意思. 现在假设我们要通过foreach来遍历ArrayList这个Collection, 我们有哪几种写法? 最直接的就是这样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        al.add(<span class="number">1</span>);</span><br><span class="line">        al.add(<span class="number">2</span>);</span><br><span class="line">        al.add(<span class="number">3</span>);</span><br><span class="line">        al.add(<span class="number">4</span>);</span><br><span class="line">        <span class="type">MyUtil</span> <span class="variable">mu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyUtil</span>();</span><br><span class="line">        al.forEach(mu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUtil</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数要求是一个<code>Consumer&lt;? super E&gt; action</code>, 这实际上是一个<strong>接口多态</strong>, 只要实现了这个接口的类, 都可以传入以<code>Consumer&lt;? super E&gt; action</code>作为形参的函数. 这里有一个非常重要的, 那就是这里的E实际上在新建ArrayList的时候就已经确定了. 这里形参上的E和ArrayList初始化的E是一样的. 也就是对于确定的ArrayList, 这里的形参类型实际上就是<code>Consumer&lt;? super Integer&gt; action</code>而已, 也就是这里形参的类必须是实现了<code>Consumer&lt;Integer&gt;</code>接口或者是<code>Consumer&lt;Integer的父类&gt;</code>的接口的类型了.</p>
<p>然后我们可以进一步使用匿名内部类的方法来写这里:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        al.add(<span class="number">1</span>);</span><br><span class="line">        al.add(<span class="number">2</span>);</span><br><span class="line">        al.add(<span class="number">3</span>);</span><br><span class="line">        al.add(<span class="number">4</span>);</span><br><span class="line">        al.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是lambda表达式, 为什么能够使用lambda表达式是因为标注了函数式接口, 也就是说函数式接口反正只有一个抽象方法, 所以重要的是方法而不是类的示例. 也就是说对于只有一个抽象方法的接口, 而且我本来不是需要你类的示例, 我本来就是只需要你一个抽象方法, 这样的形参其实传一个函数就可以了, lambda表达式就是这样一种简化的写法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">al.forEach((Integer it)-&gt;&#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">itnew</span> <span class="operator">=</span> it + <span class="number">2</span>;</span><br><span class="line">	System.out.println(it);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>甚至还有更进一步的<strong>方法引用机制</strong>, lambda表达式实际上是从调用实例中的方法到只传方法的一个跨越, 所以更进一步我传入已经存在的方法不就好了吗?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">al.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>注意这里是双冒号. 双冒号表示, 我只是引用你这个函数的名字(或者理解C++里面的函数指针), 而不是想要调用方法. 因为使用点号后面跟变量是访问变量, 跟函数名字就是想要调用函数, 但是函数引用只是参数传递, 不是调用, 所以使用双冒号. java里面关于lambda表达式的类型是要赋值给函数接口的对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数，无返回值 → Runnable</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">task.run(); <span class="comment">// 输出: Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数，返回一个值 → Supplier&lt;T&gt;</span></span><br><span class="line">Supplier&lt;String&gt; supplier = () -&gt; <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> supplier.get(); <span class="comment">// result = &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>等会, 有个问题. 接口为什么&quot;实例化&quot;了? 左边类型是确定了泛型类型的接口啊?</p>
<p>实际上这里也是一个底层隐含的操作:</p>
<blockquote>
<p>编译器会将 Lambda 表达式转换为一个匿名类，实现函数式接口的唯一抽象方法。例如，上述代码等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这是AI指出来的.</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb从无知到能用</title>
    <url>/2023/10/14/gdb%E4%BB%8E%E6%97%A0%E7%9F%A5%E5%88%B0%E8%83%BD%E7%94%A8/</url>
    <content><![CDATA[<p>很多时候就在想, 究竟怎么调试才是优雅. vscode提供的调试是基于gdb的(如果你使用C/C++的vscode插件), 当然也有vs提供的debugger, 也有使用codelldb的. 那么我们这次来看一眼终端调试程序. <span id="more"></span></p>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>为什么需要在terminal里面来使用gdb调试. 最直接的契机就是真的不想再配置环境了. 而且需要一个ARM汇编的调试环境. gdb首先是一个collection, 其实在配置很多调试环境的时候是可以通过gdb轻量级配置的, 比如rust. 使用rustc带上-g参数编译的可执行文件就可以通过gdb调试. 那么我最近需要了解的ARM汇编也可以通过gdb搭配gcc来调试. 包括C++也可以. 其实如果会gdb的话就会省去很多麻烦.</p>
<h1 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h1>
<h2 id="breakpoint"><a class="markdownIt-Anchor" href="#breakpoint"></a> breakpoint</h2>
<p>调试的话首先是打断点. 打断点可以说是调试的首要操作. 在gdb中可以使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break 10</span><br><span class="line">break main</span><br><span class="line">break filename:10</span><br><span class="line">break 20 if x == 42</span><br></pre></td></tr></table></figure>
<p>等多种形式来打断点. 当然也可以<strong>使用b来简写break</strong>. 这其中比较惊喜的就是<code>break 20 if x == 42</code>, 例如我们在循环里面, 发现当下标为4的时候函数出问题, 我们想直接跳到这个循环, 则可以使用这种方式.</p>
<h2 id="run和continue"><a class="markdownIt-Anchor" href="#run和continue"></a> run和continue</h2>
<p>使用run或者是简写r来启动调试, 如果程序需要命令行参数, 则需要在run后面加上几个参数.</p>
<p>运行到一个断点之后, 使用continue或者是c继续运行.</p>
<h2 id="step和next"><a class="markdownIt-Anchor" href="#step和next"></a> step和next</h2>
<p>next会向下一行, step是步入函数. 对于一个函数是next会直接执行一整行. 这个比较常见.</p>
<p>这里有一个点, 默认情况下step会进入系统函数, 为了避免这一点, 可以编写gdb的配置文件.gdbinit.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set step-mode on</span><br></pre></td></tr></table></figure>
<p>这样默认步入就不会步入系统函数.</p>
<h2 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> finish</h2>
<p>跳出函数用的命令.</p>
<h2 id="print"><a class="markdownIt-Anchor" href="#print"></a> print</h2>
<p>可以打印一些变量. 这个print可以打印数组的部分元素. 比如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print arr[1:2]</span><br></pre></td></tr></table></figure>
<h2 id="info"><a class="markdownIt-Anchor" href="#info"></a> info</h2>
<p>info是用来查看信息的, info可以查看一些常见的信息, 如果还记得的话vscode边栏里面就有一些信息.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info stack</span><br><span class="line">info threads</span><br><span class="line">info breakpoints</span><br><span class="line">info registers</span><br><span class="line">info locals</span><br><span class="line">info source source_file_name</span><br><span class="line">info functions function_name</span><br></pre></td></tr></table></figure>
<h2 id="watch和delete"><a class="markdownIt-Anchor" href="#watch和delete"></a> watch和delete</h2>
<p>就是调试时候常用的监视器. watch可以是一个表达式啥的, 在表达式值发生变化的同时会停下来. 有一些信息.</p>
<p>delete可以删除监视值. 当然也可以删除breakpoint这样的东西.</p>
<h2 id="display"><a class="markdownIt-Anchor" href="#display"></a> display</h2>
<p>display命令和可视化界面里面的watch界面也异曲同工之妙. 每当程序停下来的时候就会自动打印</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP中的container</title>
    <url>/2023/10/09/CPP%E4%B8%AD%E7%9A%84container/</url>
    <content><![CDATA[<p>学习STL是一个和艰难的过程, 但是里面的很多容器却只需要略微了解就能够使用. 这篇文章就来记录一下常见的容器及其使用. <span id="more"></span></p>
<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1>
<p>参考文章或者是推荐阅读: <a href="https://en.cppreference.com/w/cpp/container">cpp中的container</a></p>
<p>在C++11之前, C++中有所谓的<code>sequence containers</code>和<code>associative containers</code>. sequence, 就像它的英文原意一样, 是表示一系列数据. 比如数组其实就是一系列数据. 下面我们先来看sequence container中的array, vector, deque, forward_list以及list.</p>
<p>本篇源代码摘自llvm项目的libcxx, libstdc++实在是太难看了.</p>
<h1 id="sequence-containers"><a class="markdownIt-Anchor" href="#sequence-containers"></a> Sequence containers</h1>
<h2 id="arrayc11"><a class="markdownIt-Anchor" href="#arrayc11"></a> array(C++11)</h2>
<p>array是C++11才加入的新容器, array实际上就是一个数组, 这个数组就是C语言里面的数组, 类似于<code>int a[3]</code>这样的. 不同点在于array对于数据的所有更加明确.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">array&lt;<span class="type">int</span>,3&gt; a;</span><br></pre></td></tr></table></figure>
<p>原来C风格的数组一直和指针混淆, C风格的数组在设计传参, 拷贝等多种操作的时候就很难说清楚. 现在a就是一个整体, 类型就是array&lt;int,3&gt;, 更加现代.</p>
<p>当然还有一个非常重要的功能就是提供了迭代器. 在C++的algorithm头文件里面提供的很多算法都是需要接受迭代器, 但是如果使用传统数组就没法使用, 比如常见的sort, for_each等等. 而array实现了类似于vector的begin(), end()等. 当然因为支持迭代器当然也支持ranged based for loop的遍历.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;i: a)&#123;</span><br><span class="line">	cout&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为只是一个普通的数组没什么好说的, 里面有一个比较关键就是在访问的时候可以使用at()或者是operator[], 当然这一点在后面其他sequence container的时候也是同样的. 那这样访问有什么好处呢? 好处就是可以抛出异常:</p>
<blockquote>
<p>Returns a reference to the element at specified location pos, with bounds checking.</p>
<p>If pos is not within the range of the container, an exception of type std::out_of_range is thrown.</p>
</blockquote>
<p>这也是为了让C++更加现代统一, 越界的时候抛出异常也能够给编程人员一些处理的空间.</p>
<h2 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h2>
<p>多看<a href="https://en.cppreference.com/w/cpp/container/vector">cpprefer</a></p>
<p>这位更是非常的常用, vector也就是我们常说的动态数组, 我们可以不断地向一段连续的空间加入数据. 传统数组在存入数据之后就没有办法扩大了, 但是vector可以, 可以通过尾部插入的方法来向其中增加数据.(当然也有insert()实际上插入任何地方)</p>
<p>在时间复杂度方面:</p>
<blockquote>
<p>The complexity (efficiency) of common operations on vectors is as follows:</p>
<ul>
<li>Random access - constant 𝓞(1).</li>
<li>Insertion or removal of elements at the end - amortized constant 𝓞(1).</li>
<li>Insertion or removal of elements - linear in the distance to the end of the vector 𝓞(n).</li>
</ul>
</blockquote>
<p>可以看见从尾部插入或者是删除元素是很轻松, 时间复杂度是1, 而其他地方的insert和remove, 则正比于和尾部的距离.</p>
<p>下面我们看一下cppreference如何描述它的常见一些成员函数:</p>
<h3 id="capacity-size-shrink_to_fit和reserve"><a class="markdownIt-Anchor" href="#capacity-size-shrink_to_fit和reserve"></a> capacity(), size(), shrink_to_fit()和reserve()</h3>
<p>我想把这两个放在最前面来讲. vector既然被称为动态数组, 那首先是数组. 也就是空间是连续的, 不是不是在栈上连续而是堆上一片连续的空间. 那既然是连续的空间是怎么做到动态的呢? 原因就是capacity, 新建一个vector的时候都会有一个capacity, 即使里面没有任何元素. 看下面代码(代码测试环境是C++20 O2优化):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; test1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>可以看见capacity随着不断地插入元素是翻倍的, 而且capacity指的是最大容量, 即使pop了, capacity也不会变.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; test1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    test1.<span class="built_in">pop_back</span>();</span><br><span class="line">    test1.<span class="built_in">pop_back</span>();</span><br><span class="line">    test1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在size大小是%d, capacity大小是%d\n&quot;</span>, (<span class="type">int</span>)test1.<span class="built_in">size</span>(),</span><br><span class="line">           (<span class="type">int</span>)test1.<span class="built_in">capacity</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">现在size大小是0, capacity大小是4</span><br></pre></td></tr></table></figure>
<p>size是里面存储了多少个元素, capacity是vector实际占用的空间. 当超出capacity的时候会翻倍capacity, 并且找一块新的内存空间. 那这个过程是一个申请内存的过程, 这个时候的数组越大越耗时间.</p>
<p>在这个过程中经常会有一些错误产生, 一个常见的错误就是因为内存中出现数据转移, 必须保证迭代器的时效性. 当然也包括指针的时效性.</p>
<p>下面代码用到了data()成员函数, 详细可以看<a href="https://en.cppreference.com/w/cpp/container/vector/data">cpprefer</a>, 无论如何就是获得底层内容的指针:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; test1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = test1.<span class="built_in">data</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问指针指向的第一个值%d\n&quot;</span>, *p);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问指针指向的第一个值%d\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问指针指向的第一个值1</span><br><span class="line">访问指针指向的第一个值1488999553</span><br></pre></td></tr></table></figure>
<p>造成这个错误的原因是vector已经转移走了, 不在原位置了. 是一个隐蔽的错误. 而且比较离谱的是g++并不会对此做任何提示. 不过使用g++自带的越界检查可以检查出来, 但是这并不是一个强制选项:</p>
<p><code>g++ -fsanitize=address -fno-omit-frame-pointer -O2 -g mytest.cpp</code></p>
<p>那么再来考虑reserve, 不是reverse! reserve是预留. 如果一开始就知道capacity是大概多少, 不就可以减少内存重分配的次数吗? 我可以<code>vec.reserve(20)</code>直接把capacity拉到20, 虽然size()还是0.</p>
<p>shrink_to_fit()就是将capacity缩小到size附近, 释放多余的空间.</p>
<p>所以这四个放在一起讲.</p>
<h3 id="constructor"><a class="markdownIt-Anchor" href="#constructor"></a> constructor</h3>
<p>下面来说说构造函数的问题.</p>
<p>下面只说一下常用的构造函数. 下面四个是比较常用的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">vector</span>( <span class="type">const</span> vector&amp; other );</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">( <span class="type">const</span> vector&amp; other )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动构造</span></span><br><span class="line"><span class="built_in">vector</span>( vector&amp;&amp; other );</span><br><span class="line"><span class="built_in">vector</span>( vector&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">( vector&amp;&amp; other )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空构造 默认</span></span><br><span class="line"><span class="built_in">vector</span>();</span><br><span class="line"><span class="built_in">vector</span>() <span class="built_in">noexcept</span>(<span class="built_in">noexcept</span>(<span class="built_in">Allocator</span>()));</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(Allocator()))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count个value</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">( size_type count,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> T&amp; value = T(),</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;</span><br><span class="line"><span class="built_in">vector</span>( size_type count,</span><br><span class="line">                 <span class="type">const</span> T&amp; value,</span><br><span class="line">                 <span class="type">const</span> Allocator&amp; alloc = <span class="built_in">Allocator</span>() );</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">( size_type count,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器初始化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="title">vector</span><span class="params">( InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">( InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;</span><br></pre></td></tr></table></figure>
<p>空构造函数和拷贝不必多说, 移动构造就是要接受一个右值, 通过将参数的所有数据移动给要构造的对象来完成. 这是C++11一个很重要的话题. 可以了解一下C++11的右值引用.</p>
<p>然后下一个很常用的就是用n个x来初始化.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">test1</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// test1 = [1,1,1,...1](100个)</span></span><br></pre></td></tr></table></figure>
<p>值得一提的是C++11引入了所谓的List-initialization初始化方法, 简称大括号初始化. 如果想要初始化vector为1 2 3 4也可以这样写:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; test1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上是用了另一个不怎么常见的vector初始化函数. 一定不要混淆:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">test1</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 100个1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; test2&#123;<span class="number">100</span>, <span class="number">1</span>&#125;; <span class="comment">// 大小为2 分别是100和1</span></span><br></pre></td></tr></table></figure>
<p>最后还有迭代器初始化, 比如想要拷贝vec1的所有元素也可以:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(vec1.begin(), vec1.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p>反正只要是迭代器类型就可以, 迭代器本身也可以任意移动, 可以拷贝某一个区间也能够做到.</p>
<p>这里可以进一步体会到, 迭代器是STL的一个重要组成部分. 它起到了结合算法和容器的作用, 不知道有没有注意到这里并没有限定迭代器的来历, 也就是说, List的迭代器能否用于vec的构造函数呢? 答案是肯定的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; lst1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(lst1.begin(), lst1.end())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;i : vec1) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这就是比指针优越的地方, 迭代器就像是胶水一样连接着整个STL.</p>
<h3 id="access"><a class="markdownIt-Anchor" href="#access"></a> access</h3>
<p>下面来看访问vector的成员函数.</p>
<p>data()成员函数已经展现过作用了, 在上面可以看到可以通过传统C指针访问数据. 当然也是很危险的.</p>
<p>下面来看at和operator[].</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; vec1[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec1[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这显然是错误的, 首先这个vec1最多只有三个数字, 这个时候访问下标为3就是显然越界了, 我这边输出是0. 可以看见capacity甚至都是3! 也就是这一片空间根本就不是vector! cpprefer如是说:</p>
<blockquote>
<p>Returns a reference to the element at specified location pos. No bounds checking is performed.</p>
</blockquote>
<p>也就是不知不觉就越界了. 那么at就有作用了:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; vec1.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec1.<span class="built_in">at</span>(<span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span><br><span class="line">  what():  vector::_M_range_check: __n (which is 3) &gt;= this-&gt;size() (which is 3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不仅报出了越界<code>std::out_of_range</code>, 还报出更多有用的信息, size是3, 你下标也是3. 虽然没有报出具体的行数, 但是也是比原来能够正常编译运行好多了.</p>
<p>在reference的access界面, 还有front()和back()两个方法用于访问最前面的数据和最后面的数据, 就没有什么别的注意点.</p>
<h3 id="iterators"><a class="markdownIt-Anchor" href="#iterators"></a> iterators</h3>
<p>成员函数省略了括号!</p>
<p>begin, cbegin, end, cend, 四个成员函数返回迭代器. begin就是开始迭代器, end就是结尾迭代器, 注意左闭右开, 也就是begin返回的迭代器是指向头元素的, 而end指向的却是尾元素还要往后一位, 没有元素.</p>
<p>偷一个refer的图.<br />
<img src="https://upload.cppreference.com/mwiki/images/1/1b/range-begin-end.svg" alt="" /></p>
<p>c开头就是const.</p>
<p>然后还有rbegin, rend, crbegin, crend等迭代器. 就是反过来迭代.</p>
<p><img src="https://upload.cppreference.com/mwiki/images/3/39/range-rbegin-rend.svg" alt="" /></p>
<p>再偷一个图.</p>
<h3 id="modifiers"><a class="markdownIt-Anchor" href="#modifiers"></a> modifiers</h3>
<p>clear()方法, 清除所有size(), 不影响capacity, 换句话来说就是不会释放vector掌管的内存.</p>
<p>insert(), 相当有用的成员函数. 整个insert函数有五个重载, 都非常常用.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在pos前面插入value</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator <span class="title">insert</span><span class="params">( const_iterator pos, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在pos前面插入value</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, T&amp;&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator <span class="title">insert</span><span class="params">( const_iterator pos, T&amp;&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos前面插入count个value</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, size_type count, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator</span></span><br><span class="line"><span class="function">    <span class="title">insert</span><span class="params">( const_iterator pos, size_type count, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos前面插入[first, last)之间的元素</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, InputIt first, InputIt last )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator <span class="title">insert</span><span class="params">( const_iterator pos, InputIt first, InputIt last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos前面插入initializer_list</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator <span class="title">insert</span><span class="params">( const_iterator pos,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure>
<p>在cppreference里面也有示例代码, 里面都是使用构造函数的例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> id, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; id &lt;&lt; <span class="string">&quot;. &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> x : container)</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">3</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, c1);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> it = c1.<span class="built_in">begin</span>();</span><br><span class="line">    it = c1.<span class="built_in">insert</span>(it, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>, c1);</span><br><span class="line"> </span><br><span class="line">    c1.<span class="built_in">insert</span>(it, <span class="number">2</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>, c1);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// `it` no longer valid, get a new one:</span></span><br><span class="line">    it = c1.<span class="built_in">begin</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">2</span>, <span class="number">400</span>)</span></span>;</span><br><span class="line">    c1.<span class="built_in">insert</span>(std::<span class="built_in">next</span>(it, <span class="number">2</span>), c2.<span class="built_in">begin</span>(), c2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>, c1);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">501</span>, <span class="number">502</span>, <span class="number">503</span>&#125;;</span><br><span class="line">    c1.<span class="built_in">insert</span>(c1.<span class="built_in">begin</span>(), arr, arr + std::<span class="built_in">size</span>(arr));</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>, c1);</span><br><span class="line"> </span><br><span class="line">    c1.<span class="built_in">insert</span>(c1.<span class="built_in">end</span>(), &#123;<span class="number">601</span>, <span class="number">602</span>, <span class="number">603</span>&#125;);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">6</span>, c1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不知道有没有人感觉到一个疑问, 既然insert的一个重载的一个函数里面, 接受的参数类型(其中一个)为什么会是const T&amp;, insert的时候, vector内部存的一直就是某个元素的副本而不是引用或其本身. 写成引用只是为了方便传参, 这样传参的时候可以省下一次拷贝.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">    <span class="keyword">typename</span> vector&lt;_Tp, _Alloc&gt;::iterator</span><br><span class="line">    vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">    <span class="built_in">insert</span>(const_iterator __position, <span class="type">const</span> value_type&amp; __x)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">insert</span>(iterator __position, <span class="type">const</span> value_type&amp; __x)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> size_type __n = __position - <span class="built_in">begin</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage)</span><br><span class="line">	<span class="keyword">if</span> (__position == <span class="built_in">end</span>())</span><br><span class="line">	  &#123;</span><br><span class="line">	    _GLIBCXX_ASAN_ANNOTATE_GROW(<span class="number">1</span>);</span><br><span class="line">	    _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">				     __x);</span><br><span class="line">	    ++<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">	    _GLIBCXX_ASAN_ANNOTATE_GREW(<span class="number">1</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">	    <span class="type">const</span> <span class="keyword">auto</span> __pos = <span class="built_in">begin</span>() + (__position - <span class="built_in">cbegin</span>());</span><br><span class="line">	    <span class="comment">// __x could be an existing element of this vector, so make a</span></span><br><span class="line">	    <span class="comment">// copy of it before _M_insert_aux moves elements around.</span></span><br><span class="line">	    _Temporary_value __x_copy(<span class="keyword">this</span>, __x);</span><br><span class="line">	    _M_insert_aux(__pos, std::<span class="built_in">move</span>(__x_copy._M_val()));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	    _M_insert_aux(__position, __x);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">	_M_realloc_insert(<span class="built_in">begin</span>() + (__position - <span class="built_in">cbegin</span>()), __x);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	_M_realloc_insert(__position, __x);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在源代码中, 还特意注释了这一点. 甚至这个函数看上去很乱, 因为各个标准都不一样.</p>
<h2 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> deque</h2>
<p>double-ended queue. 也经常翻译成双端队列. 我们还是看时间复杂度:</p>
<blockquote>
<p>The complexity (efficiency) of common operations on deques is as follows:</p>
<ul>
<li>Random access - constant O(1).</li>
<li>Insertion or removal of elements at the end or beginning - constant O(1).</li>
<li>Insertion or removal of elements - linear O(n).</li>
</ul>
<p><code>std::deque</code> meets the requirements of Container, AllocatorAwareContainer, SequenceContainer and ReversibleContainer.</p>
</blockquote>
<p>随机访问时间复杂度O(1), 在头部尾部都是O(1), 中间是线性的.</p>
<p>回顾一下vector的, vector几乎和这个差不多, 也是随机访问O(1), 中间插入O(n), 但是只是在末尾插入是常数复杂度, 头部插入是O(n). 这样看来好像deque全面优于vector?</p>
<p>deque的内存分布是一系列固定长度的内存小块, 然后组合起来.</p>
<p><img src="https://pic.imgdb.cn/item/65274551c458853aefaf3969.png" alt="" /></p>
<p>从这个图也可以很直观地看出来, 无论是在头部删除还是在尾部删除都是常数. 主要是在两端预留空间, 其实很有链表的特色. 例如我如果删除一个元素, 只需要把begin往后拨一位.</p>
<p>其实和链表非常相似, 那么这个头尾时间复杂度为O(1)反而不足为奇, 反而需要问问是随机访问如何做到O(1)的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">typename</span> deque&lt;_Tp, _Allocator&gt;::reference</span><br><span class="line">deque&lt;_Tp, _Allocator&gt;::<span class="keyword">operator</span>[](size_type __i) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    size_type __p = __start_ + __i;</span><br><span class="line">    <span class="keyword">return</span> *(*(__map_.<span class="built_in">begin</span>() + __p / __block_size) + __p % __block_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面访问下标为i的内容, 首先先算出p, 等于start+i. 这是我们希望的位置, 但是如何快速跳转呢? 如果是链表, 是不是就得不断地往后跳转, 迭代器一位一位往后next得到结果. 但是我们注意这里deque的做法.</p>
<p>先通过map.begin()加上 p/block_size获取对应chunk的迭代器. 例如在上图中我们访问下标为6, 因为一个块是5, 所以需要map的迭代器往前一位, 指向chunk1. 然后取余得到是1, 也就是说<code>*(__map_.begin() + __p / __block_size)</code>就是chunk1这个数组, 或者说是其首地址. 然后再来看, 最开始是start指向2, 因为<code>data[0]</code>是指向所在数组的下标2, 2加上6为8, 8取模5是3. 也就是说需要访问的元素是在当前数组的第三位.</p>
<p>总结来看. 访问的下标i加上最开始元素所在chunk的下标start共同组成了一个p, 这个p和chunk_size除法的部分用来跳转块, 取模的部分用来标识块也就是chunk数组的下标.</p>
<p>相比较而言, 同样都是O(1)的random access, vector的O(1)看上去还是更加O(1)一些.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="keyword">operator</span>[](size_type __n) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(__n &lt; <span class="built_in">size</span>(), <span class="string">&quot;vector[] index out of bounds&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__begin_[__n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题外话: deque只是规定了行为, 至于具体实现, 还得看各个编译器的实现. 而且还有个很有意思的点就是对于<code>operator[]</code>的实现, 可以看见libcxx里面是有一个内存检查的, 而下面是libstdc++的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libstdc++</span></span><br><span class="line">  _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR</span><br><span class="line">  reference</span><br><span class="line">  <span class="keyword">operator</span>[](size_type __n) _GLIBCXX_NOEXCEPT</span><br><span class="line">  &#123;</span><br><span class="line">__glibcxx_requires_subscript(__n);</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>似乎没有检查. 本来上面说过at有检查, 但是libcxx似乎下标访问也会检查. 还没有实测clang++搭配libc++的报错情况.</p>
<p>deque的成员函数没有什么好说的. 和vector比较类似.</p>
<h2 id="forward_listc11"><a class="markdownIt-Anchor" href="#forward_listc11"></a> forward_list(c++11)</h2>
<blockquote>
<p>std::forward_list is a container that supports fast insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is implemented as a singly-linked list. Compared to std::list this container provides more space efficient storage when bidirectional iteration is not needed.</p>
</blockquote>
<p>这一个就略过, 这个只是一个更加&quot;more space efficient&quot;的list. 由C++11引入.</p>
<h2 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h2>
<p>其实STL的很多成员函数都大差不差, 所以下面只说明一下比较有新意的一些成员函数.</p>
<p>在operation一栏里面, 有一些很有意思的函数.</p>
<h3 id="remove和remove_if"><a class="markdownIt-Anchor" href="#remove和remove_if"></a> remove()和remove_if()</h3>
<p>对于一个list, remove就是删除所有和参数一样的元素嘛, 这个remove_if就很酷炫, 它的参数可以是一个lambda表达式:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reference的示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">-1</span>, <span class="number">12</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> count1 = l.<span class="built_in">remove</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; count1 &lt;&lt; <span class="string">&quot; elements equal to 1 were removed\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> count2 = l.<span class="built_in">remove_if</span>([](<span class="type">int</span> n)&#123; <span class="keyword">return</span> n &gt; <span class="number">10</span>; &#125;);</span><br><span class="line">    std::cout &lt;&lt; count2 &lt;&lt; <span class="string">&quot; elements greater than 10 were removed\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finally, the list contains: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : l)</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以根据函数的要求来删除元素. 其他的就不赘述了, 接下来也是重头戏, associative container.</p>
<h1 id="associative-containers"><a class="markdownIt-Anchor" href="#associative-containers"></a> Associative containers</h1>
<h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h2>
<blockquote>
<p>std::set is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as Red–black trees.</p>
</blockquote>
<p>对于set来说, search, removal, insertion都含有&quot;logarithmic complexity&quot;也就是O(logn)的复杂度. 而且经常使用红黑树来实现.</p>
<p>所以与其说学习set, 不如说需要了解红黑树的性质, 不然的话没有办法能够了解时间复杂度和set的优缺点从何而来.</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP中的cin和cout运行缓慢</title>
    <url>/2023/09/13/CPP%E4%B8%AD%E7%9A%84cin%E5%92%8Ccout%E8%BF%90%E8%A1%8C%E7%BC%93%E6%85%A2/</url>
    <content><![CDATA[<p>在昨天遇到了一个对时间要求非常苛刻的一个题目, 室友说它总是超时, 而且超很多, 大概在十几倍的水平, 后来对比了一下标准答案并且控制了一下变量, 发现是cin和cout的锅, 那么我们现在就来讨论一下cin和cout对于程序的影响.</p>
<span id="more"></span>
<h1 id="cin和cout很慢的原因"><a class="markdownIt-Anchor" href="#cin和cout很慢的原因"></a> cin和cout很慢的原因</h1>
<h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2>
<p>&lt;&lt;是一个很多重载的函数, 函数调用会有开销.</p>
<h2 id="和printf同步"><a class="markdownIt-Anchor" href="#和printf同步"></a> 和printf同步</h2>
<p>因为cout格式化字符串并不方便, 所以一般和printf混用. 混用就有这个所谓同步问题.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str1\n&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2\n&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str3\n&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str4\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">str2</span></span><br><span class="line"><span class="comment">str4</span></span><br><span class="line"><span class="comment">str1</span></span><br><span class="line"><span class="comment">str3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>ios::sync_with_stdio(false);使用这一段代码可以解除和stdio的sync, 可以加快速度, 但是就会和printf乱序执行.</p>
<h2 id="endl频繁刷新缓冲区减速"><a class="markdownIt-Anchor" href="#endl频繁刷新缓冲区减速"></a> endl频繁刷新缓冲区减速</h2>
<p>std::endl相当于<code>\n + std::flush</code>. 频繁使用endl换行会刷新缓冲区, 导致性能问题.</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>实战中, 一般先关闭和stdio的sync, 然后endl其实是一个大头耗时. 其实很多情况下不需要考虑cout带来的性能问题.</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP中的右值引用</title>
    <url>/2023/09/04/CPP%E4%B8%AD%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>我对C++真是又爱又恨, 但是静下心来又不得不学. 我认为现在作为一个计算机学生, C++和JAVA无论如何都要熟悉了解一门, 这里的了解当然并不单单是指语法(虽然语法也难学明白), 更是搜索能力, 解决问题能力, 阅读报错能力和项目经验的综合体现. 好好studyC++罢!<span id="more"></span></p>
<p><a href="https://en.cppreference.com/w/cpp/language/reference">右值引用</a>, 始于C++11, 是C++中一个相当关键的概念. 虽然是C++11, 但是本文所有的代码也都会在C++17下面测试一回.</p>
<h1 id="为什么需要右值引用"><a class="markdownIt-Anchor" href="#为什么需要右值引用"></a> 为什么需要右值引用</h1>
<h2 id="实现移动语义来避免拷贝"><a class="markdownIt-Anchor" href="#实现移动语义来避免拷贝"></a> 实现移动语义来避免拷贝</h2>
<p>有一篇文章写得很好, 就是<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics">这个</a>. 下面是第一个可以减少拷贝的小例子. 如果想要交换两个对象, 通过移动语义, 可以在不复制第三个对象的前提下面交换两个对象.</p>
<blockquote>
<p>But, we didn’t want to have any copies of a or b, we just wanted to swap them. Let’s try again:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="built_in">swap</span>(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">    a = std::<span class="built_in">move</span>(b);   </span><br><span class="line">    b = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这是一个很有意思的利用右值的操作, 总共有三个指针, 然后两份资源, 也就是交换过程中自始至终没有出现第三个资源. 也就是<strong>可以减少不必要的拷贝</strong>.</p>
<p>这是一个右值的小应用, 我们再来看一个更加明显的应用, 下面一段代码选自 &lt;现代C++核心特性解析&gt;, 我们在C++98下面编译运行, 看一看在C++11, 也就是右值所在的版本出来之前, 会遇到哪些可能的性能上的问题. 值得注意的是, 我们仅考虑<strong>语义上</strong>的问题, 所以<strong>关闭返回值优化</strong>. 这样才能够实验得到完整的符合语法预期的结果. 编译命令使用:<code>g++ -fno-elide-constructors -std=c++98 cpp11_2.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigMemoryPool</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> PoolSize = <span class="number">4096</span>;</span><br><span class="line">    <span class="built_in">BigMemoryPool</span>() : <span class="built_in">pool_</span>(<span class="keyword">new</span> <span class="type">char</span>[PoolSize]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">BigMemoryPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool_ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] pool_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigMemoryPool</span>(<span class="type">const</span> BigMemoryPool&amp; other) : <span class="built_in">pool_</span>(<span class="keyword">new</span> <span class="type">char</span>[PoolSize]) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy big memory pool.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">memcpy</span>(pool_, other.pool_, PoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* pool_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BigMemoryPool <span class="title">get_pool</span><span class="params">(<span class="type">const</span> BigMemoryPool&amp; pool)</span> </span>&#123; <span class="keyword">return</span> pool; &#125;</span><br><span class="line"><span class="function">BigMemoryPool <span class="title">make_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigMemoryPool pool;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_pool</span>(pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigMemoryPool my_pool = <span class="built_in">make_pool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy big memory pool.</span><br><span class="line">copy big memory pool.</span><br><span class="line">copy big memory pool.</span><br></pre></td></tr></table></figure>
<p>可以看见出现了三个输出&quot;copy big memory pool&quot;, 这说明我们拷贝了一个大数组三次, 这就是性能上的问题. 比较严重的是我们可以发现这次的拷贝, 其实是一种浪费. 我们可以考虑一下这三次拷贝分别是在哪里发生的. 这三次copy其实分别发生在:</p>
<ol>
<li>get_pool返回临时对象复制</li>
<li>make_pool返回临时对象复制</li>
<li>main函数中新构造的my_pool进行复制构造函数</li>
</ol>
<p>虽然上述结果是在关闭返回值优化情况下面进行的, 但是无论怎么讲, 从<strong>语义上</strong>来说, 上面这个代码确实性能很差, 只是编译器救了一手罢了, 之后我们会分析一下编译器如何优化的. 在这些个拷贝的过程中, 实际上是不必要的拷贝, 那个拷贝的来源其实马上就要作废了, 也就是完全可以把那个资源继承给目标, 这个思想就是<strong>移动语义</strong>. 在C++11之后我们可以定义移动构造函数, 编译命令是<code>g++ -fno-elide-constructors -std=c++11 cpp11_2.cpp</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigMemoryPool</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> PoolSize = <span class="number">4096</span>;</span><br><span class="line">    <span class="built_in">BigMemoryPool</span>() : <span class="built_in">pool_</span>(<span class="keyword">new</span> <span class="type">char</span>[PoolSize]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">BigMemoryPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] pool_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">BigMemoryPool</span>(BigMemoryPool&amp;&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move big memory pool.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        pool_ = other.pool_;</span><br><span class="line">        other.pool_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigMemoryPool</span>(<span class="type">const</span> BigMemoryPool&amp; other) : <span class="built_in">pool_</span>(<span class="keyword">new</span> <span class="type">char</span>[PoolSize]) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy big memory pool.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">memcpy</span>(pool_, other.pool_, PoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* pool_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BigMemoryPool <span class="title">get_pool</span><span class="params">(<span class="type">const</span> BigMemoryPool&amp; pool)</span> </span>&#123; <span class="keyword">return</span> pool; &#125;</span><br><span class="line"><span class="function">BigMemoryPool <span class="title">make_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigMemoryPool pool;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_pool</span>(pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigMemoryPool my_pool = <span class="built_in">make_pool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//关闭返回值优化的C++11</span><br><span class="line">copy big memory pool.</span><br><span class="line">move big memory pool.</span><br><span class="line">move big memory pool.</span><br><span class="line">//关闭返回值优化的C++17</span><br><span class="line">copy big memory pool.</span><br></pre></td></tr></table></figure>
<p>这样就只有一次copy. 然后观察我们新建的移动构造函数就会发现, 这个移动构造函数的效率确实比拷贝要高多了.  因为只设计一个指针的变动. 观察move函数的签名:<code>BigMemoryPool(BigMemoryPool&amp;&amp; other)</code>, 这里面函数的行参就是一个右值引用. 我们再来审视一下常见的一些操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myclass a = b; //等同于 myclass a(b)调用拷贝构造函数</span><br><span class="line">myclass&amp;&amp; a = std::move(b); //等同于有 myclass a(b)调用move函数</span><br><span class="line">int a = 3;</span><br></pre></td></tr></table></figure>
<p>我们希望从一个b新建一个跟他掌握资源相同的a, 我们如果使用第一种方式就是把b里面的内容拷贝一份给a, 第二种方法就是直接把b的资源move给a. 当然这个说法也不尽准确, 因为第二种方法是调用了移动构造函数, 你移动构造函数必须是真的做了move. 当然我们从语义上讨论问题就假定所有函数都是规范写法, 而且假定没有编译器优化.</p>
<p>下面就是int a = 3, 这个式子其实从语义上来看, 右侧是一个int的右值, 左侧是一个a, 从语法上来看倒有些无法理解(草), 写成<code>int a(3)</code>就可以理解, 但是<code>int a = 3</code>就有点不符合一贯的理解方式. 或者写成<code>int a = int(3)</code>. 不过这都是咬文嚼字, 毕竟像int这种基础类型无论怎么说都不会遇到什么左右值的问题的, 只是好玩和有意思罢了.</p>
<p>上面我们讨论了一下右值引用给C++带来的性能提升, 但是还有一个问题没有解决. 那就是我们其实可以发现如果使用C++17标准而且关闭返回值优化, 居然只有一个&quot;copy big memory pool&quot;. 顺带一提, 如果不关闭返回值优化, 也就是不加<code>-fno-elide-constructors</code>, 无论是03, 11, 17三个标准的输出都是同样的, 都是&quot;copy big memory pool.&quot; 首先解决第一个问题, 在通过flag关闭RVO之后, 为什么C++17的输出仍然像优化后一样? 这是因为<code>Prvalue semantics (&quot;guaranteed copy elision&quot;)</code>, <a href="https://en.cppreference.com/w/cpp/language/copy_elision">cppreference的参考</a>. 也就是这在C++17的观点看来不算是一种优化, 而是一个从语义上就能解释的东西, 也就是直接让这个优化从语义上能解释通.</p>
<blockquote>
<p>Note: This rule does not specify an optimization, and the Standard does not formally describe it as “copy elision” (because nothing is being elided). Instead, the C++17 core language specification of <a href="https://en.cppreference.com/w/cpp/language/value_category">prvalues</a> and <a href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Temporary_materialization">temporaries</a> is fundamentally different from that of earlier C++ revisions: there is no longer a temporary to copy/move from. Another way to describe C++17 mechanics is “unmaterialized value passing” or “deferred temporary materialization”: prvalues are returned and used without ever materializing a temporary.</p>
</blockquote>
<p>而针对第二个问题, 实际上编译器在C++11之前就已经可以进行类似的优化了, 但是程序员无法控制. 我估计这个优化也只能应对简单的情况, 毕竟不靠程序员理清楚左右值语义光靠编译器还是困难.</p>
<p><s>其实按照原设定本来这里有一段C++98(C++03)对于优化的汇编分析, 但是TM看不懂, 就不深究了. 反正虽然C++98的时候没有右值这个说法, 但是编译器进行了类似的优化.</s></p>
<h2 id="完美转发"><a class="markdownIt-Anchor" href="#完美转发"></a> 完美转发</h2>
<p>现在设想这样一个函数factory(), 它要求能够对于一个类型T, 返回这个T类型的shared_ptr, 并且在构造的同时返回. 也就是, 这个factory()就和类型T的构造函数一样, 只不过是返回一个实例的shared_ptr. 假设T只有一个参数, 那可能会这样写:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A1</span>&gt;</span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="title">factory</span><span class="params">(<span class="type">const</span> A1&amp; a1)</span>   <span class="comment">// one argument version</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(a1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样看似乎是可行的, 对于一个类型A, 可以这样, <code>std::shared_ptr&lt;A&gt; tmp = factory&lt;A&gt;(3);</code></p>
<p>但是假如A的构造函数接受的参数形式是一个可变的引用呢? 或者说你const&amp;固然能够接受无论是左值还是右值, 但是传进来之后就变成不可变引用了, 假如后续s还想修改就不行了. 那可能会说写两个不久行了, 一个接收右值, 一个接受左值. 但是这只是一个参数的情况, 如果构造函数有两个参数那就是需要排列组合, 三个四个就是灾难.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A1</span>&gt;</span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="title">factory</span><span class="params">(A1&amp;&amp; a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;A1&gt;(a1)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里原文章把它称之为:</p>
<blockquote>
<p>Rvalue references offer a simple, scalable solution to this problem:</p>
</blockquote>
<p>但是实际上尤其注意, 这里的A1&amp;&amp; a1, 并不是一个右值引用. 如果是一个右值引用的话, 岂不是无法接受左值了? 这是一种表示方法, 表示如果来了一个左值, a1就变成左值引用, 如果是一个右值, 那就是move给a1.</p>
<p>那下面的<code>std::forward&lt;A1&gt;(a1)</code>是什么意思? 其实<code>static_cast&lt;A1&amp;&amp;&gt;(a1)</code>和这个是等价的. 如果a1是左值, 注意, 这里的左值必须是int&amp;, 才能完美转发:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;int&amp;&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;int&amp;&amp;&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;<span class="type">int</span>&gt;(x));</span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;normal\n&quot;</span>;</span><br><span class="line">    <span class="built_in">foo</span>(x);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp;</span><br><span class="line"><span class="type">int</span>&amp;&amp;</span><br><span class="line">normal</span><br><span class="line"><span class="type">int</span>&amp;</span><br><span class="line"><span class="type">int</span>&amp;&amp;</span><br></pre></td></tr></table></figure>
<p>哎!? 为啥上面也是两个右值? 这里时刻注意, 完美转发的保留左右值属性中的保留左值属性是<strong>引用类型</strong>. 一定时刻记住<code>forward&lt;T&gt;</code>和<code>static_cast&lt;T&amp;&amp;&gt;</code>作用差不多. 如果是一个T, 就变成T&amp;&amp;, 只有T&amp;才是T&amp;, 然后T&amp;&amp;变成T&amp;&amp;.</p>
<p>右值引用和引用折叠共同完成了这个特性. 在完美转发中右值的引入让概念更加清晰, 但是在函数的形参里面的T&amp;&amp;并不是右值引用, 这个必须注意.</p>
<h1 id="值类别"><a class="markdownIt-Anchor" href="#值类别"></a> 值类别</h1>
<p><img src="https://i.stack.imgur.com/GNhBF.png" alt="" /></p>
<p>这个图片来自于stackoverflow的一个回答, 借其图片一用. 而对于各个值的定义, 引用N3092的原文:</p>
<blockquote>
<p>An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [ Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example, the result of calling a function whose return type is an lvalue reference is an lvalue. — end example ]</p>
<p>An xvalue (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references (8.3.2). [ Example: The result of calling a function whose return type is an rvalue reference is an xvalue. — end example ]</p>
<p>A glvalue (“generalized” lvalue) is an lvalue or an xvalue.</p>
<p>An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment expressions) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated with an object.</p>
<p>A prvalue (“pure” rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is also a prvalue. — end example ]</p>
</blockquote>
<p>值得注意的是, 在标准里面详细提到了关于值转换部分.</p>
<blockquote>
<p>Whenever a glvalue appears in a context where a prvalue is expected, the glvalue is converted to a prvalue; see 4.1, 4.2, and 4.3.</p>
</blockquote>
<p>当需要一个纯右值的时候, 而出现了一个泛左值, 则会发生转换. 而这三个转换4.1, 4.2, 4.3分别是<code>Lvalue-to-rvalue convertion</code>, <code>Array-to-pointer convertion</code>, <code>Function-to-pointer convertion</code>. 最常见的第一个转换, 比如对于赋值运算符, 期望右侧是一个纯右值, 但是实际使用也会出现<code>b=a</code>这样, 这个时候就是发生了第一种转换.</p>
<p>扯远了, 左值和纯右值是最好理解的. 在CPP11之前, 我们常说的左值实际上是泛左值(glvalue), 我们说的右值实际上是纯右值(prvalue). 想要理解CPP11的expresstion的分类, 其关键是理解这个多出来的东西, 将亡值(eXpiring value).</p>
<blockquote>
<p>[ Note: An expression is an xvalue if it is:</p>
<p>— the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference to object type,</p>
<p>— a cast to an rvalue reference to object type,</p>
<p>— a class member access expression designating a non-static data member in which the object expression is an xvalue, or</p>
<p>— a .* pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer to data member.</p>
<p>​	In general, the effect of this rule is that named rvalue references are treated as lvalues and unnamed rvalue references to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether named or not. — end note ]</p>
<p>[ Example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line">A&amp;&amp; <span class="keyword">operator</span>+(A, A);</span><br><span class="line"><span class="function">A&amp;&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">A a;</span><br><span class="line">A&amp;&amp; ar = <span class="built_in">static_cast</span>&lt;A&amp;&amp;&gt;(a);</span><br></pre></td></tr></table></figure>
<p>The expressions f(), f().m, static_cast&lt;A&amp;&amp;&gt;(a), and a + a are xvalues. The expression ar is an lvalue. — end example ]</p>
</blockquote>
<p>这是n3092的原文.</p>
<p>第一种情况就是返回右值引用的函数的值. 比如<code>T&amp;&amp; f()</code>, 那么这里的f()的expression类别就是xvalue. (注意区分type和expression category, type就是int, double一类, exression category就是正在讨论的prvalue)</p>
<p>第二个是static_cast&lt;T&amp;&amp;&gt;来的.</p>
<p>第三个是一个xvalue的成员仍然是xvalue. 后面还比较容易看懂. 在总结里面说的更清楚, 起名的右值引用当左值, 没名的当将亡值, 对于函数的右值引用不管怎么样都当左值.</p>
<p>这里需要区分函数的返回值和对函数的引用.</p>
<p>xvalue究竟是用来干什么的? 为什么要引入它? xvalue标志着, 这个变量已经进入了生命周期末期, 可以把它的资源移动. 它是一种标志. 和右值不同, 就像这个语句<code>string&amp;&amp; a = string(&quot;wowo&quot;);</code>这里右侧就不是一个将亡值, 只是一个简单的用右值初始化一个变量. 从语法规定上看, string构造函数的返回值是string而不是string&amp;&amp;, 所以不是将亡值. 从语义上来理解, 这个构造过程并没有变量&quot;亡&quot;, 而诸如std::move(x)这样的语句是有可能引起x的死亡的, 依赖于move函数的具体实现, move之后没有办法保证x是有效的了. 而且std::move的返回值正是一个右值引用.</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>忽然觉得学习左右值没有什么用.</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>重新回到arch系重置版</title>
    <url>/2023/06/18/%E9%87%8D%E6%96%B0%E5%9B%9E%E5%88%B0arch%E7%B3%BB%E9%87%8D%E7%BD%AE%E7%89%88/</url>
    <content><![CDATA[<p>现在是2023年的6月份, 本来润回ubuntu, 但是觉得不够刺激, 现在再次回到了endeavouros, 于是想着重置一下这一篇文章. 重新编排一下组织章节. <span id="more"></span></p>
<h1 id="输入法问题"><a class="markdownIt-Anchor" href="#输入法问题"></a> 输入法问题</h1>
<p>我还是不想换</p>
<h1 id="显卡驱动问题"><a class="markdownIt-Anchor" href="#显卡驱动问题"></a> 显卡驱动问题</h1>
<p>一直以来, arch系和Ubuntu相对比一直差点意思. 首先是arch自己, 装完桌面后配置过于麻烦, 是在是让人难以忍受. manjaro也不是很好, 突出表现在驱动, 对于N卡的驱动比arch实在是差太多了. 使用manjaro玩MC会画面撕裂, 罪魁祸首还是采取了一个hybrid的显卡驱动方法(当然自2023年以来我也没有再去试manjaro了). 而且manjaro毕竟不是arch, 在使用一些aur软件或者是GitHub的开源项目过程中, 万一出了问题, 有时候没法复现. 毕竟aur是给arch用的而不是给manjaro用的.</p>
<p>对于一些对arch亲缘比较近的发行版, 对于N卡的方案就好很多, 对于笔记本的双显卡切换试用<code>nvidia-prime</code>的方案, 也就是默认是一种混合的模式, 如果需要使用独显, 显示地用<code>prime-run</code>. 虽然说这个方案没有彻底关闭nvidia省电但是毕竟是官方的方案, 比manjaro的要好.</p>
<p>当然archwiki也提供了一些其他的方案, 其中有一些方案是需要手动做一些看似很危险的操作, 改一些平时我从来不会去看的文件, 和内核相关. 这些方案确实很吓人, 毕竟如果linux桌面没了还好, kernel panic处理起来可是麻烦多了.</p>
<p>所以看来看去, 好用的其实就一个首推的, <code>optimus-manager</code>. 这应该是算一个首选. 但是这个也确实有一些弊端, 首先就是它已经很久没有更新了(虽然说It works well so no maintainance is needed). 而且optimus也需要搭配一些其他的包比如说bbswitch一起使用来&quot;延长电池续航时间&quot;. 配置起来还是麻烦.</p>
<p><code>envycontrol</code>是最新的, 也是目前最优的解. 也是目前我正在使用的, 非常好用, 方便程度相当于Ubuntu里面的<code>prime-select</code>. 我也在近期重新回到了arch发行版, 也是今天的主角: <strong>endeavoros</strong>.</p>
<p>如果是想要安装xfce的版本那没有什么大问题, 直接安装就行, 默认下面就是给你安装xfce桌面. 但是如果你想安装其他的桌面环境比如说我最喜欢的KDE, 或者是gnome. 那么就需要先<strong>换源</strong>. 保证pacman不会报网络相关的错误. 而且如果不换源的话很有可能它会给你报错, 就说连不上网络, 无法使用online模式, 而offline只有xfce这一种桌面环境. 联网了之后的选择是十分丰富的.</p>
<p>其实和manjaro确实差不太多, 可以参看manjaro那一篇文章. 关于Ubuntu的那一篇文章写的是真的详细. 在进入live环境的时候如果选择了nvidia的那个选择项, 那么在安装完成之后应该会是自动安装的N卡驱动. 然后再搭配上最新的envycontrol, 简直是完美.</p>
<p>可以说流畅地用上了arch系简直是走上了人生巅峰的感觉.</p>
<p><strong>那么接下来是我新添加的内容以及新的想说的话.</strong> 实际情况是, envycontrol依赖于特定版本的python. 在上次离开arch系的原因就是yay -Syyu的时候python从3.10更新到了3.11, 然后一大票软件通通寄了, 我的备份也比较老, 所以直接放弃了. 这次事故再次让人认识到, 一旦一个软件是非官方的, 依赖社区的, 它就很容易出了问题好久没人解决. 我不知道现在解决没有但是, 我现在仍然在使用官方的<code>nvidia-prime</code>方案, 虽然看上去好像耗电, 但是更加安心. aur的社区包非常多, 但是可能问题也很多, 很多时候就是能少装几个就少装几个, 尽量装有官方支持的, 不然用arch就永远在看issue和修bug的路上.</p>
<h1 id="pacman包管理器"><a class="markdownIt-Anchor" href="#pacman包管理器"></a> pacman包管理器</h1>
<p>对于安装, 多是S开头. 没有什么稀奇的地方.</p>
<p><code>pacman -Rs package_name</code>: 相比普通的-R, 这个会remove所有的dependencies.</p>
<p><code>pacman -Rn package_name</code>: prevent backup files of package.</p>
<p>显然-Rsn是未来经常用的命令了.</p>
<p><code>pacman -Syu</code>: 更新整个系统. 如果是Syyu, 就是强制重新sync repo, 即使repo已经报告它没有被更新.</p>
<p>除开更新下载和安装, 查询也是包管理器重要的功能. 随着对linux系统使用的深入, 查询命令确实用得越来越多.</p>
<blockquote>
<p>Pacman queries the local package database with the <code>-Q</code> flag, the sync database with the <code>-S</code> flag and the files database with the <code>-F</code> flag. See <code>pacman -Q --help</code>, <code>pacman -S --help</code> and <code>pacman -F --help</code> for the respective suboptions of each flag.</p>
</blockquote>
<p><code>pacman -Ss string1 string2 ...</code>: 在远端搜索这个包的名字, 列出描述. 这个描述还是比较简略, 但是关键是它显示了每个包来自于哪个仓库:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo pacman -Ss neovim     </span><br><span class="line">community/neovide 0.10.3-1</span><br><span class="line">    No Nonsense Neovim Client in Rust</span><br><span class="line">community/neovim 0.8.3-1 [installed]</span><br><span class="line">    Fork of Vim aiming to improve user experience, plugins, and GUIs</span><br><span class="line">...省略, 类似这一种显示信息.</span><br></pre></td></tr></table></figure>
<p>如果觉得信息太少, 使用-Si查看extensive的信息.</p>
<p>对于已经install的包, 可以使用-Q选项来查询:</p>
<p><code>pacman -Qs neovim</code></p>
<p>同样的:</p>
<p><code>pacman -Qi neovim</code></p>
<p>如果想要查看一个包安装在哪些目录, 使用-Ql, 这样一下子确实输出很多目录.</p>
<p>然后还有一个特别乐的, 可以看一个文件是谁在maintain:</p>
<p><code>pacman -Qo filepath</code></p>
<p>我就是通过这么命令验证了<code>/etc/environment</code>这个文件是属于哪一个包, 在群友的帮助下确实学到了很多.</p>
]]></content>
      <tags>
        <tag>touchfish</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>重新回到arch系</title>
    <url>/2023/03/09/%E9%87%8D%E6%96%B0%E5%9B%9E%E5%88%B0arch%E7%B3%BB/</url>
    <content><![CDATA[<p>现在是2023年的3月份, Ubuntu23.04即将发布, 带来一个新的更加精简的镜像, 并且带来许多新特性. 但是我却尝试回到了endeavoros. <span id="more"></span></p>
<p>一直以来, arch系和Ubuntu相对比一直差点意思. 首先是arch自己, 装完桌面后配置过于麻烦, 是在是让人难以忍受. manjaro也不是很好, 突出表现在驱动, 对于N卡的驱动比arch实在是差太多了. 使用manjaro玩MC会画面撕裂, 罪魁祸首还是采取了一个hybrid的显卡驱动方法(当然自2023年以来我也没有再去试manjaro了). 而且manjaro毕竟不是arch, 在使用一些aur软件或者是GitHub的开源项目过程中, 万一出了问题, 有时候没法复现. 毕竟aur是给arch用的而不是给manjaro用的.</p>
<p>对于一些对arch亲缘比较近的发行版, 对于N卡的方案就好很多, 对于笔记本的双显卡切换试用<code>nvidia-prime</code>的方案, 也就是默认是一种混合的模式, 如果需要使用独显, 显示地用<code>prime-run</code>. 虽然说这个方案没有彻底关闭nvidia省电但是毕竟是官方的方案, 比manjaro的要好.</p>
<p>当然archwiki也提供了一些其他的方案, 其中有一些方案是需要手动做一些看似很危险的操作, 改一些平时我从来不会去看的文件, 和内核相关. 这些方案确实很吓人, 毕竟如果linux桌面没了还好, kernel panic处理起来可是麻烦多了.</p>
<p>所以看来看去, 好用的其实就一个首推的, <code>optimus-manager</code>. 这应该是算一个首选. 但是这个也确实有一些弊端, 首先就是它已经很久没有更新了(虽然说It works well so no maintainance is needed). 而且optimus也需要搭配一些其他的包比如说bbswitch一起使用来&quot;延长电池续航时间&quot;. 配置起来还是麻烦.</p>
<p><code>envycontrol</code>是最新的, 也是目前最优的解. 也是目前我正在使用的, 非常好用, 方便程度相当于Ubuntu里面的<code>prime-select</code>. 我也在近期重新回到了arch发行版, 也是今天的主角: <strong>endeavoros</strong>.</p>
<p>如果是想要安装xfce的版本那没有什么大问题, 直接安装就行, 默认下面就是给你安装xfce桌面. 但是如果你想安装其他的桌面环境比如说我最喜欢的KDE, 或者是gnome. 那么就需要先<strong>换源</strong>. 保证pacman不会报网络相关的错误. 而且如果不换源的话很有可能它会给你报错, 就说连不上网络, 无法使用online模式, 而offline只有xfce这一种桌面环境. 联网了之后的选择是十分丰富的.</p>
<p>其实和manjaro确实差不太多, 可以参看manjaro那一篇文章. 关于Ubuntu的那一篇文章写的是真的详细. 在进入live环境的时候如果选择了nvidia的那个选择项, 那么在安装完成之后应该会是自动安装的N卡驱动. 然后再搭配上最新的envycontrol, 简直是完美.</p>
<p>可以说流畅地用上了arch系简直是走上了人生巅峰的感觉.</p>
<h1 id="pacman包管理器"><a class="markdownIt-Anchor" href="#pacman包管理器"></a> pacman包管理器</h1>
<p>对于安装, 多是S开头. 没有什么稀奇的地方.</p>
<p><code>pacman -Rs package_name</code>: 相比普通的-R, 这个会remove所有的dependencies.</p>
<p><code>pacman -Rn package_name</code>: prevent backup files of package.</p>
<p>显然-Rsn是未来经常用的命令了.</p>
<p><code>pacman -Syu</code>: 更新整个系统. 如果是Syyu, 就是强制重新sync repo, 即使repo已经报告它没有被更新.</p>
<p>除开更新下载和安装, 查询也是包管理器重要的功能. 随着对linux系统使用的深入, 查询命令确实用得越来越多.</p>
<blockquote>
<p>Pacman queries the local package database with the <code>-Q</code> flag, the sync database with the <code>-S</code> flag and the files database with the <code>-F</code> flag. See <code>pacman -Q --help</code>, <code>pacman -S --help</code> and <code>pacman -F --help</code> for the respective suboptions of each flag.</p>
</blockquote>
<p><code>pacman -Ss string1 string2 ...</code>: 在远端搜索这个包的名字, 列出描述. 这个描述还是比较简略, 但是关键是它显示了每个包来自于哪个仓库:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo pacman -Ss neovim     </span><br><span class="line">community/neovide 0.10.3-1</span><br><span class="line">    No Nonsense Neovim Client in Rust</span><br><span class="line">community/neovim 0.8.3-1 [installed]</span><br><span class="line">    Fork of Vim aiming to improve user experience, plugins, and GUIs</span><br><span class="line">...省略, 类似这一种显示信息.</span><br></pre></td></tr></table></figure>
<p>如果觉得信息太少, 使用-Si查看extensive的信息.</p>
<p>对于已经install的包, 可以使用-Q选项来查询:</p>
<p><code>pacman -Qs neovim</code></p>
<p>同样的:</p>
<p><code>pacman -Qi neovim</code></p>
<p>如果想要查看一个包安装在哪些目录, 使用-Ql, 这样一下子确实输出很多目录.</p>
<p>然后还有一个特别乐的, 可以看一个文件是谁在maintain:</p>
<p><code>pacman -Qo filepath</code></p>
<p>我就是通过这么命令验证了<code>/etc/environment</code>这个文件是属于哪一个包, 在群友的帮助下确实学到了很多.</p>
]]></content>
      <tags>
        <tag>touchfish</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>和我一起写makefile</title>
    <url>/2023/02/05/%E5%92%8C%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99makefile/</url>
    <content><![CDATA[<h1 id="关于"><a class="markdownIt-Anchor" href="#关于"></a> 关于</h1>
<p>文章内容是陈皓的跟我一起写 makefile. 但是目前能找到的原版好像是 csdn 上面的(我也没有好好找), 不方便复制下来看.</p>
<p>虽然有一个 PDF 的重置版, 但是我还是更喜欢文字和 markdown.</p>
<p>在 GitHub 上面有 lewis1573 开的重置版 markdown 仓库:<a href="https://github.com/lewis1573/write-makefile-with-me">点此</a>, 非常感谢他的工作! (其实如果 GitHub 上面找不到 markdown 重置版可能我自己就要发了).</p>
<p>文中如果是我自己的评论或者是笔记, 会使用引用的形式标出来. 同时我也会对文章里面的内容再对照一次. 看看有没有什么错误. (其实错误倒是不至于, 主要是我会再将markdown优化一下, 因为$在很多markdown编辑器里面会和数学公式联系在一起, 导致显示出现问题, 最后针对显示出现问题的情况我会再优化一下.)</p>
<p>如果有能力还是推荐去GitHub上面看原作者的Markdown. 虽然没有目录好像不方便看, 但是毕竟是原作者, 他做的更加细致, 我摘抄下来可能会有格式错误的问题!</p>
<span id="more"></span>
<p><strong>需要注意的是, 因为 tab 和空格的问题纠缠不清, 所以导致网上很多的 makefile 是没有办法直接运行的.</strong> 所以作者为了保证 makefile 能够运行, 是使用了 <code>.RECIPEPREFIX = &gt;</code> 这一句话. 使用了这个声明之后, 往后的命令就不适用 tab 开头, 而是使用 &gt; 开头了. 非常有意思.</p>
<h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述</h1>
<p>什么是makefile？或许很多Windows的程序员都不知道这个东西，因为那些Windows的集成开发环境（integrated developmentenvironment，IDE）都为你做了这个工作，但我觉得要作一个好的和专业的程序员，makefile还是要懂。这就好像现在有这么多的HTML编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标签的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。</p>
<p>因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计其数，并且按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p>
<p>makefile带来的好处就是------“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p>
<p>现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在&quot;文件依赖性&quot;上做文章，这里，我仅对GNU的make进行讲述，我的环境 是RedHat Linux 8.0，make的版本是3.80。毕竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992标准的（POSIX.2）。</p>
<p>在这篇文档中，将以C/C++的源码作为基础，所以必然涉及一些关于C/C++的编译的知识。关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p>
<h2 id="11-关于程序的编译和链接"><a class="markdownIt-Anchor" href="#11-关于程序的编译和链接"></a> 1.1 关于程序的编译和链接</h2>
<p>在此，我想多说关于程序编译的一些规范和方法。一般来说，无论是C还是C++，首先要把源文件编译成中间代码文件，在Windows下也就是 <code>.obj</code> 文件，UNIX下是 <code>.o</code> 文件，即Object File，这个动 作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</p>
<p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（<code>.o</code> 文件或 <code>.obj</code> 文件）。</p>
<p>链接时，主要是链接函数和全局变量。所以，我们可以使用这些中间目标文件（<code>.o</code> 文件或 <code>.obj</code>文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫&quot;库文件&quot;（Library File），也就是 <code>.lib</code> 文件，在UNIX下，是Archive File，也就是 <code>.a</code> 文件。</p>
<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。 而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码 （Linker Error），在VC下，这种错误一般是： <code>Link 2001错误</code>，意思说是说，链接器未能找到 函数的实现。你需要指定函数的Object File。</p>
<p>好，言归正传，gnu的make有许多的内容，闲言少叙。</p>
<h1 id="makefile介绍"><a class="markdownIt-Anchor" href="#makefile介绍"></a> makefile介绍</h1>
<p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>首先，我们用一个示例来说明makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<ol>
<li>如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。</li>
<li>如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。</li>
<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。</li>
</ol>
<p>只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。</p>
<h2 id="21-makefile的规则"><a class="markdownIt-Anchor" href="#21-makefile的规则"></a> 2.1 makefile的规则</h2>
<p>在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">target ... : prerequisites ...</span><br><span class="line">&gt;  command</span><br><span class="line">&gt;  ...</span><br><span class="line">&gt;  ...</span><br></pre></td></tr></table></figure>
<p>target:<br />
可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的&quot;伪目标&quot;章节中会有叙述。</p>
<p>prerequisites:<br />
生成该target所依赖的文件和/或target</p>
<p>command:<br />
该target要执行的命令（任意的shell命令）</p>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:</p>
<pre><code>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。
</code></pre>
<p>这就是makefile的规则，也就是makefile中最核心的内容。</p>
<p>说到底，makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是makefile的主线和核心，但要写好一个makefile还不够，我会在后面一点一点地结合我的工作经验给你慢慢道来。内容还多着呢。😃</p>
<h2 id="22-一个示例"><a class="markdownIt-Anchor" href="#22-一个示例"></a> 2.2 一个示例</h2>
<p>正如前面所说，如果一个工程有3个头文件和8个c文件，为了完成前面所述的那三个规则，我们的makefile应该是下面的这个样子的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">&gt;  cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">&gt;  cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">&gt;  cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">&gt;  cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">&gt;  cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">&gt;  cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">&gt;  cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">&gt;  cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">&gt;  cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">&gt;  rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>反斜杠（ <code>\</code> ）是换行符的意思。这样比较便于makefile的阅读。我们可以把这个内容保存在名字为&quot;makefile&quot;或&quot;Makefile&quot;的文件中，然后在该目录下直接输入命令 <code>make</code> 就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 <code>make clean</code> 就 可以了。</p>
<p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（ <code>*.o</code> ），依赖文 件（prerequisites）就是冒号后面的那些 <code>.c</code> 文件和 <code>.h</code> 文件。每一个 <code>.o</code> 文件都有 一组依赖文件，而这些 <code>.o</code> 文件又是执行文件 <code>edit</code> 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个 <code>Tab</code> 键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<p>这里要说明一点的是， <code>clean</code> 不是一个文件，它只不过是一个动作名字，有点像c语言中的label一样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h2 id="23-make是如何工作的"><a class="markdownIt-Anchor" href="#23-make是如何工作的"></a> 2.3 make是如何工作的</h2>
<p>在默认的方式下，也就是我们只输入 <code>make</code> 命令。那么，</p>
<ol>
<li>make会在当前目录下找名字叫&quot;Makefile&quot;或&quot;makefile&quot;的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到&quot;edit&quot;这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果edit文件不存在，或是edit所依赖的后面的 <code>.o</code> 文件的文件修改时间要比 <code>edit</code> 这个文件新，那么，他就会执行后面所定义的命令来生成 <code>edit</code> 这个文件。</li>
<li>如果 <code>edit</code> 所依赖的 <code>.o</code> 文件也不存在，那么make会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如果找到则再根据那一个规则生成 <code>.o</code> 文件。（这有点像一个堆栈的过程）</li>
<li>当然，你的C文件和H文件是存在的啦，于是make会生成 <code>.o</code> 文件，然后再用 <code>.o</code> 文件生 成make的终极任务，也就是执行文件 <code>edit</code> 了。</li>
</ol>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令------ <code>make clean</code> ，以此来清除所有 的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 <code>file.c</code> ， 那么根据我们的依赖性，我们的目标 <code>file.o</code> 会被重编译（也就是在这个依性关系后面所定义的命令）， 于是 <code>file.o</code> 的文件也是最新的啦，于是 <code>file.o</code> 的文件修改时间要比 <code>edit</code> 要新，所以 <code>edit</code> 也会被重新链接了（详见 <code>edit</code> 目标文件后定义的命令）。</p>
<p>而如果我们改变了 <code>command.h</code> ，那么， <code>kdb.o</code> 、 <code>command.o</code> 和 <code>files.o</code> 都 会被重编译，并且， <code>edit</code> 会被重链接。</p>
<h2 id="24-makefile中使用变量"><a class="markdownIt-Anchor" href="#24-makefile中使用变量"></a> 2.4 makefile中使用变量</h2>
<p>在上面的例子中，先让我们看看edit的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">&gt;  cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>.o</code> 文件的字符串被重复了两次，如果我们的工程需要加入一个新的 <code>.o</code> 文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p>
<p>比如，我们声明一个变量，叫 <code>objects</code> ， <code>OBJECTS</code> ， <code>objs</code> ， <code>OBJS</code> ， <code>obj</code> 或是 <code>OBJ</code> ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">     insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>于是，我们就可以很方便地在我们的makefile中以 <code>$(objects)</code> 的方式来使用这个变量了，于是 我们的改良版makefile就变成下面这个样子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">&gt;  cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">&gt;  cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">&gt;  cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">&gt;  cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">&gt;  cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">&gt;  cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">&gt;  cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">&gt;  cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">&gt;  cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">&gt;  rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>于是如果有新的 <code>.o</code> 文件加入，我们只需简单地修改一下 <code>objects</code> 变量就可以了。</p>
<p>关于变量更多的话题，我会在后续给你一一道来。</p>
<h2 id="25-让make自动推导"><a class="markdownIt-Anchor" href="#25-让make自动推导"></a> 2.5 让make自动推导</h2>
<p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 <code>.o</code> 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的新makefile又出炉了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">&gt;  cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">&gt;  rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这种方法，也就是make的&quot;隐晦规则&quot;。上面文件内容中， <code>.PHONY</code> 表示 <code>clean</code> 是个伪目标 文件。</p>
<p>关于更为详细的&quot;隐晦规则&quot;和&quot;伪目标文件&quot;，我会在后续给你一一道来。</p>
<h2 id="26-另类风格的makefiles"><a class="markdownIt-Anchor" href="#26-另类风格的makefiles"></a> 2.6 另类风格的makefiles</h2>
<p>既然我们的make可以自动推导命令，那么我看到那堆 <code>.o</code> 和 <code>.h</code> 的依赖就有点不爽，那么多的 重复的 <code>.h</code> ，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">&gt;  cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">&gt;  rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的 <code>.o</code> 文件，那就理不清楚了。</p>
<h2 id="27-清空目标文件的规则"><a class="markdownIt-Anchor" href="#27-清空目标文件的规则"></a> 2.7 清空目标文件的规则</h2>
<p>每个Makefile中都应该写一个清空目标文件（ <code>.o</code> 和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个&quot;修养&quot;（呵呵，还记得我的《编程修养》吗）。一般的风格都是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">&gt;  rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>更为稳健的做法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">&gt;  -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>前面说过， <code>.PHONY</code> 表示 <code>clean</code> 是一个&quot;伪目标&quot;。而在 <code>rm</code> 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， <code>clean</code> 的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是------“clean从来都是放在文件的最后”。</p>
<p>上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。</p>
<h2 id="28-makefile里有什么"><a class="markdownIt-Anchor" href="#28-makefile里有什么"></a> 2.8 Makefile里有什么？</h2>
<p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<ol>
<li>显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li>
<li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 <code>#</code> 字符，这个就 像C/C++中的 <code>//</code> 一样。如果你要在你的Makefile中使用 <code>#</code> 字符，可以用反斜杠进行 转义，如： <code>\#</code> 。</li>
</ol>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以 <code>Tab</code> 键开始。</p>
<h2 id="29-makefile的文件名"><a class="markdownIt-Anchor" href="#29-makefile的文件名"></a> 2.9 Makefile的文件名</h2>
<p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为&quot;GNUmakefile&quot;、 “makefile”、“Makefile&quot;的文件，找到了解释这个文件。在这三个文件名中，最好使用&quot;Makefile&quot;这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用&quot;GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的&quot;makefile&quot;文件名敏感，但是基本上来说，大多数的make都支持&quot;makefile&quot;和&quot;Makefile&quot;这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，&quot;Make.AIX&quot;等，如果要指定特定的Makefile，你可以使用make的 <code>-f</code> 和 <code>--file</code> 参数， 如： <code>make -f Make.Linux</code> 或 <code>make --file Make.AIX</code> 。</p>
<h2 id="210-引用其它的makefile"><a class="markdownIt-Anchor" href="#210-引用其它的makefile"></a> 2.10 引用其它的Makefile</h2>
<p>在Makefile使用 <code>include</code> 关键字可以把别的Makefile包含进来，这很像C语言的 <code>#include</code> ，被包含的文件会原模原样的放在当前文件的包含位置。 <code>include</code> 的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><code>filename</code> 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。</p>
<p>在 <code>include</code> 前面可以有一些空字符，但是绝不能是 <code>Tab</code> 键开始。 <code>include</code> 和 <code>&lt;filename&gt;</code> 可以用一个或多个空格隔开。举个例子，你有这样几个Makefile： <code>a.mk</code> 、 <code>b.mk</code> 、 <code>c.mk</code> ，还有一个文件叫 <code>foo.make</code> ，以及一个变量 <code>$(bar)</code><br />
，其包含 了 <code>e.mk</code> 和 <code>f.mk</code> ，那么，下面的语句：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure>
<p>make命令开始时，会找寻 <code>include</code> 所指出的其它Makefile，并把其内容安置在当前的位置。就好 像C/C++的 <code>#include</code> 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<ol>
<li>如果make执行时，有 <code>-I</code> 或 <code>--include-dir</code> 参数，那么make就会在这个参数所指定的目 录下去寻找。</li>
<li>如果目录 <code>&lt;prefix&gt;/include</code> （一般是： <code>/usr/local/bin</code> 或 <code>/usr/include</code> ）存在的话，make也会去找。</li>
</ol>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号&quot;-&quot;。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">-include</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p>
<h2 id="211-环境变量makefiles"><a class="markdownIt-Anchor" href="#211-环境变量makefiles"></a> 2.11 环境变量MAKEFILES</h2>
<p>如果你的当前环境中定义了环境变量 <code>MAKEFILES</code> ，那么，make会把这个变量中的值做一个类似于 <code>include</code> 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 <code>include</code> 不同的是，从这个环境变量中引入的Makefile的&quot;目标&quot;不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h2 id="212-make的工作方式"><a class="markdownIt-Anchor" href="#212-make的工作方式"></a> 2.12 make的工作方式</h2>
<p>GNU的make工作时的执行步骤如下：（想来其它的make也是类似）</p>
<ol>
<li>读入所有的Makefile。</li>
<li>读入被include的其它Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p>
<p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h1 id="3-书写规则"><a class="markdownIt-Anchor" href="#3-书写规则"></a> 3. 书写规则</h1>
<p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p>
<p>在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</p>
<p>好了，还是让我们来看一看如何书写规则。</p>
<h2 id="31-规则举例"><a class="markdownIt-Anchor" href="#31-规则举例"></a> 3.1 规则举例</h2>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">foo.o: foo.c defs.h       # foo模块</span></span><br><span class="line">&gt;  cc -c -g foo.c</span><br></pre></td></tr></table></figure>
<p>看到这个例子，各位应该不是很陌生了，前面也已说过， <code>foo.o</code> 是我们的目标， <code>foo.c</code> 和 <code>defs.h</code> 是目标所依赖的源文件，而只有一个命令 <code>cc -c -g foo.c</code> （以Tab键开头）。这个 规则告诉我们两件事：</p>
<ol>
<li>文件的依赖关系， <code>foo.o</code> 依赖于 <code>foo.c</code> 和 <code>defs.h</code> 的文件，如果 <code>foo.c</code> 和 <code>defs.h</code> 的文件日期要比 <code>foo.o</code> 文件日期要新，或是 <code>foo.o</code> 不存在，那么依赖 关系发生。</li>
<li>生成或更新 <code>foo.o</code> 文件，就是那个cc命令。它说明了如何生成 <code>foo.o</code> 这个文件。 （当然，foo.c文件include了defs.h文件）</li>
</ol>
<h2 id="32-规则的语法"><a class="markdownIt-Anchor" href="#32-规则的语法"></a> 3.2 规则的语法</h2>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">targets : prerequisites</span><br><span class="line">&gt;  command</span><br><span class="line">&gt;  ...</span><br></pre></td></tr></table></figure>
<p>或是这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">targets : prerequisites ; command</span><br><span class="line">&gt;  command</span><br><span class="line">&gt;  ...</span><br></pre></td></tr></table></figure>
<p>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。</p>
<p>command是命令行，如果其不与&quot;target:prerequisites&quot;在一行，那么，必须以 <code>Tab</code> 键开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）</p>
<p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是&quot;过时的&quot;，被认为是需要重生成的。这个在前面已经讲过了。</p>
<p>如果命令太长，你可以使用反斜杠（ <code>\</code> ）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何生成目标文件。</p>
<p>一般来说，make会以UNIX的标准Shell，也就是 <code>/bin/sh</code> 来执行命令。</p>
<h2 id="33-在规则中使用通配符"><a class="markdownIt-Anchor" href="#33-在规则中使用通配符"></a> 3.3 在规则中使用通配符</h2>
<p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code> 。这是和Unix的B-Shell是相同的。</p>
<p>波浪号（ <code>~</code> ）字符在文件名中也有比较特殊的用途。如果是 <code>~/test</code> ，这就表示当前用户 的 <code>$HOME</code> 目录下的test目录。而 <code>~hchen/test</code> 则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是 MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量&quot;HOME&quot;而定。</p>
<p>通配符代替了你一系列的文件，如 <code>*.c</code> 表示所有后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如： <code>*</code> ，那么可以用转义字符 <code>\</code> ，如 <code>\*</code> 来表示真实的 <code>*</code> 字符，而不是任意长度的字符串。</p>
<p>好吧，还是先来看几个例子吧：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">&gt;  rm -f *.o</span><br></pre></td></tr></table></figure>
<p>其实在这个clean:后面可以加上你想做的一些事情，如果你想看到在编译完后看看main.c的源代码，你可以在加上cat这个命令，例子如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">&gt;  cat main.c</span><br><span class="line">&gt;  rm -f *.o</span><br></pre></td></tr></table></figure>
<p>其结果你试一下就知道的。<br />
上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">print: *.c</span></span><br><span class="line">&gt;  lpr -p <span class="variable">$?</span></span><br><span class="line">&gt;  touch print</span><br></pre></td></tr></table></figure>
<p>上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的 <code>.c</code> 文件。其中的 <code>$?</code> 是一个自动化变量，我会在后面给你讲述。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure>
<p>上面这个例子，表示了通配符同样可以用在变量中。并不是说 <code>*.o</code> 会展开，不！objects的值就是 <code>*.o</code> 。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有 <code>.o</code> 的文件名的集合，那么，你可以这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br></pre></td></tr></table></figure>
<p>另给一个变量使用通配符的例子：</p>
<ol>
<li>
<p>列出一确定文件夹中的所有 <code>.c</code> 文件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>列出(1)中所有文件对应的 <code>.o</code> 文件，在（3）中我们可以看到它是由make自动编译出的:</p>
<pre><code>$(patsubst %.c,%.o,$(wildcard *.c))
</code></pre>
</li>
<li>
<p>由(1)(2)两步，可写出编译并链接所有 <code>.c</code> 和 <code>.o</code> 文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">objects := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">foo : <span class="variable">$(objects)</span></span><br><span class="line">&gt;  cc -o foo <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这种用法由关键字&quot;wildcard&quot;，&quot;patsubst&quot;指出，关于Makefile的关键字，我们将在后面讨论。</p>
<h2 id="34-文件搜寻"><a class="markdownIt-Anchor" href="#34-文件搜寻"></a> 3.4 文件搜寻</h2>
<p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p>
<p>Makefile文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>
<p>上面的定义指定两个目录，“src&quot;和”…/headers&quot;，make会按照这个顺序进行搜索。目录由&quot;冒号&quot;分隔。（当然，当前目录永远是最高优先搜索的地方）</p>
<p>另一个设置文件搜索路径的方法是使用make的&quot;vpath&quot;关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>
<p><code>vpath &lt;pattern&gt; &lt;directories&gt;</code>:   为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;。</p>
<p><code>vpath &lt;pattern&gt;</code>:   清除符合模式&lt;pattern&gt;的文件的搜索目录。</p>
<p><code>vpath</code>:   清除所有已被设置好了的文件搜索目录。</p>
<p>vpath使用方法中的&lt;pattern&gt;需要包含 <code>%</code> 字符。 <code>%</code> 的意思是匹配零或若干字符，（需引用 <code>%</code> ，使用 <code>\</code> ）例如， <code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件。&lt;pattern&gt;指定了要搜索的文件集，而  &lt;directories&gt;则指定了&lt;pattern&gt;的文件集的搜索的目录。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure>
<p>该语句表示，要求make在&quot;…/headers&quot;目录下搜索所有以 <code>.h</code> 结尾的文件。（如果某文件在当前目 录没有找到的话）</p>
<p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt;pattern&gt;，或是被重复了的&lt;pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br></pre></td></tr></table></figure>
<p>其表示 <code>.c</code> 结尾的文件，先在&quot;foo&quot;目录，然后是&quot;blish&quot;，最后是&quot;bar&quot;目录。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br></pre></td></tr></table></figure>
<p>而上面的语句则表示 <code>.c</code> 结尾的文件，先在&quot;foo&quot;目录，然后是&quot;bar&quot;目录，最后才是&quot;blish&quot;目录。</p>
<h2 id="35-伪目标"><a class="markdownIt-Anchor" href="#35-伪目标"></a> 3.5 伪目标</h2>
<p>最早先的一个例子中，我们提到过一个&quot;clean&quot;的目标，这是一个&quot;伪目标&quot;，</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">&gt;  rm *.o temp</span><br></pre></td></tr></table></figure>
<p>正像我们前面例子中的&quot;clean&quot;一样，既然我们生成了许多文件编译文件，我们也应该提供一个清除它们的&quot;目标&quot;以备完整地重编译而用。 （以&quot;make clean&quot;来使用该目标）</p>
<p>因为，我们并不生成&quot;clean&quot;这个文件。&quot;伪目标&quot;并不是一个文件，只是一个标签，由于&quot;伪目标&quot;不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个&quot;目标&quot;才能让其生效。当然，&quot;伪目标&quot;的取名不能和文件名重名，不然其就失去了&quot;伪目标&quot;的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记&quot;.PHONY&quot;来显式地指明一个目标是&quot;伪目标&quot;，向make说明，不管是否有这个文件，这个目标就是&quot;伪目标&quot;。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>
<p>只要有这个声明，不管是否有&quot;clean&quot;文件，要运行&quot;clean&quot;这个目标，只有&quot;make clean&quot;这样。于是整 个过程可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">&gt;  rm *.o temp</span><br></pre></td></tr></table></figure>
<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为&quot;默认目标&quot;，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用&quot;伪目标&quot;这个特性：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">&gt;  cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">&gt;  cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">&gt;  cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个&quot;all&quot;的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于&quot;all&quot;又是一个伪目标，伪目标只是一个标签不会生成文件，所以不会有&quot;all&quot;文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 <code>.PHONY : all</code>声明了&quot;all&quot;这个目标为&quot;伪目标&quot;。（注：这里的显式 &quot;.PHONY : all&quot;不写的话一般情况也可以正确的执行，这样make可通过隐式规则推导出， “all” 是一个伪目标，执行make不会生成&quot;all&quot;文件，而执行后面的多个目标。建议：显式写出是一个好习惯。）</p>
<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">.PHONY : cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">&gt;  rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">&gt;  rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">&gt;  rm *.diff</span><br></pre></td></tr></table></figure>
<p>&quot;make<br />
cleanall&quot;将清除所有要被清除的文件。&quot;cleanobj&quot;和&quot;cleandiff&quot;这两个伪目标有点像&quot;子程序&quot;的意思。我们可以输入&quot;make clean all&quot;和&quot;make clean obj&quot;和&quot;make clean diff&quot;命令来达到清除不同种类文件的目的。</p>
<h2 id="36-多目标"><a class="markdownIt-Anchor" href="#36-多目标"></a> 3.6 多目标</h2>
<p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 <code>$@</code> （关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">&gt;  generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上述规则等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">bigoutput : text.g</span><br><span class="line">&gt;  generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">&gt;  generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>
<p>其中， <code>-$(subst output,,$@)</code> 中的 <code>$</code> 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思，<code>$@</code> 表示目标的 集合，就像一个数组， <code>$@</code> 依次取出目标，并执于命令。</p>
<h2 id="37-静态模式"><a class="markdownIt-Anchor" href="#37-静态模式"></a> 3.7 静态模式</h2>
<p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;</span><br><span class="line">&gt;  &lt;commands&gt;</span><br><span class="line">&gt;  ...</span><br></pre></td></tr></table></figure>
<p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>
<p>target-pattern是指明了targets的模式，也就是的目标集模式。</p>
<p>prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。</p>
<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的&lt;target-pattern&gt;定义成 <code>%.o</code> ，意思是我们的&lt;target&gt;;集合中都是以 <code>.o</code> 结尾的，而 如果我们的&lt;prereq-patterns&gt;定义成 <code>%.c</code>，意思是对&lt;target-pattern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;target-pattern&gt;模式中的 <code>%</code>（也就是去掉了 <code>.o</code> 这个结 尾），并为其加上 <code>.c</code> 这个结尾，形成的新集合。</p>
<p>所以，我们的&quot;目标模式&quot;或是&quot;依赖模式&quot;中都应该有 <code>%</code> 这个字符，如果你的文件名中有 <code>%</code> 那么 你可以使用反斜杠 <code>\</code> 进行转义，来标明真实的 <code>%</code> 字符。</p>
<p>看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，指明了我们的目标从<code>$object</code>中获取， <code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o bar.o</code> ，也就是变量 <code>$object</code> 集合的模式，而依赖模式 <code>%.c</code> 则取模式 <code>%.o</code> 的 <code>%</code> ，也就是 <code>foo bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就 是 <code>foo.c bar.c</code>。而命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量， <code>$&lt;</code> 表示第一个依赖文件，<code>$@</code> 表示目标集（也就是&quot;foo.o bar.o&quot;）。于是，上面的规则展开后等价于下面的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">foo.o : foo.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>
<p>试想，如果我们的 <code>%.o</code> 有几百个，那么我们只要用这种很简单的&quot;静态模式规则&quot;就可以写完一堆规则，实在是太有效率了。&quot;静态模式规则&quot;的用法很灵活，如果用得好，那会是一个很强大的功能。再看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">&gt;  emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p><code>$(filter %.o,$(files))</code>表示调用 Makefile 的 filter 函数，过滤<code>$files</code>集，只要其中模式为&quot;%.o&quot;的内容。其它的内容，我就不用多说了吧。这个例子展示了Makefile中更大的弹性。</p>
<h2 id="38-自动生成依赖性"><a class="markdownIt-Anchor" href="#38-自动生成依赖性"></a> 3.8 自动生成依赖性</h2>
<p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句<code>#include &quot;defs.h&quot;</code> ，那么我们的依赖关系应该是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个&quot;-M&quot;的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令:</p>
<pre><code>cc -M main.c
</code></pre>
<p>其输出是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用 <code>-MM</code>参数，不然， <code>-M</code> 参数会把一些标准库的头文件也包含进来。</p>
<p>gcc -M main.c的输出是:</p>
<pre><code>main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \
    /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \
    /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \
    /usr/include/bits/sched.h /usr/include/libio.h \
    /usr/include/_G_config.h /usr/include/wchar.h \
    /usr/include/bits/wchar.h /usr/include/gconv.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \
    /usr/include/bits/stdio_lim.h
</code></pre>
<p>gcc -MM main.c的输出则是:</p>
<pre><code>main.o: main.c defs.h
</code></pre>
<p>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 <code>name.c</code> 的文件都生成一个 <code>name.d</code> 的Makefile文件， <code>.d</code> 文件中就存放对应 <code>.c</code> 文件的依赖关系。</p>
<p>于是，我们可以写出 <code>.c</code> 文件和 <code>.d</code> 文件的依赖关系，并让make自动更新或生成 <code>.d</code> 文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p>
<p>这里，我们给出了一个模式规则来产生 <code>.d</code> 文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">&gt;  @set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">    <span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">    sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \</span><br><span class="line">    rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure>
<p>这个规则的意思是，所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件， <code>rm -f $@</code> 的意思是删除所有的 目标，也就是 <code>.d</code> 文件，第二行的意思是，为每个依赖文件 <code>$&lt;</code> ，也就是 <code>.c</code> 文件生成依赖文件， <code>$@</code> 表示模式 <code>%.d</code> 文件，如果有一个C文件是name.c，那么 <code>%</code> 就是 <code>name</code> ， <code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能是&quot;name.d.12345&quot;，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 <code>.d</code> 文件的依赖，即把依赖关系：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>转成：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o main.d : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>于是，我们的 <code>.d</code> 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 <code>.d</code> 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 <code>.d</code> 文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的&quot;include&quot;命令，来引入别的Makefile文件（前面讲过），例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>
<p>上述语句中的 <code>$(sources:.c=.d)</code> 中的 <code>.c=.d</code> 的意思是做一个替换，把变量 <code>$(sources)</code> 所有 <code>.c</code> 的字串都替换成 <code>.d</code> ，关于这个&quot;替换&quot;的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次序来载入文件，最先载入的 <code>.d</code> 文件中的目 标会成为默认目标。</p>
<h1 id="4-书写命令"><a class="markdownIt-Anchor" href="#4-书写命令"></a> 4. 书写命令</h1>
<p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以 <code>Tab</code> 键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p>
<p>我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被 <code>/bin/sh</code> ------UNIX的标准 Shell 解释执行的。除非你特别指定一个其它的Shell。Makefile中， <code>#</code> 是注释符，很像C/C++中的 <code>//</code> ，其后的本行字符都被注释。</p>
<h2 id="41-显示命令"><a class="markdownIt-Anchor" href="#41-显示命令"></a> 4.1 显示命令</h2>
<p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 <code>@</code> 字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如:</p>
<pre><code>@echo 正在编译XXX模块......
</code></pre>
<p>当make执行时，会输出&quot;正在编译XXX模块.….…“字串，但不会输出命令，如果没有”@&quot;，那么，make将输出:</p>
<pre><code>echo 正在编译XXX模块......
正在编译XXX模块......
</code></pre>
<p>如果make执行时，带入make参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而make参数 <code>-s</code> 或 <code>--silent</code> 或 <code>--quiet</code> 则是全面禁止命令的显示。</p>
<h2 id="42-命令执行"><a class="markdownIt-Anchor" href="#42-命令执行"></a> 4.2 命令执行</h2>
<p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p>
<ul>
<li>示例一：</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">exec:</span></span><br><span class="line">&gt;  cd /home/hchen</span><br><span class="line">&gt;  pwd</span><br></pre></td></tr></table></figure>
<ul>
<li>示例二：</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">exec:</span></span><br><span class="line">&gt;  cd /home/hchen; pwd</span><br></pre></td></tr></table></figure>
<p>当我们执行 <code>make exec</code> 时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出&quot;/home/hchen&quot;。</p>
<p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell------/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也<br />
可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如 <code>.exe</code> 、 <code>.com</code> 、 <code>.bat</code> 、 <code>.sh</code> 等后缀。</p>
<h2 id="43-命令出错"><a class="markdownIt-Anchor" href="#43-命令出错"></a> 4.3 命令出错</h2>
<p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p>
<p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号 <code>-</code> （在Tab键之后） ，标记为不管命令出不出错都认为是成功的。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">&gt;  -rm -f *.o</span><br></pre></td></tr></table></figure>
<p>还有一个全局的办法是，给make加上 <code>-i</code> 或是 <code>--ignore-errors</code> 参数，那么，Makefile中 所有命令都会忽略错误。而如果一个规则是以 <code>.IGNORE</code> 作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>还有一个要提一下的make的参数的是 <code>-k</code> 或是 <code>--keep-going</code> ，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p>
<h2 id="44-嵌套执行make"><a class="markdownIt-Anchor" href="#44-嵌套执行make"></a> 4.4 嵌套执行make</h2>
<p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line">&gt;  cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line">&gt;  <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>
<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入&quot;subdir&quot;目录，然后执行make命令。</p>
<p>我们把这个Makefile叫做&quot;总控Makefile&quot;，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了 <code>-e</code> 参数。</p>
<p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明:</p>
<pre><code>export &lt;variable ...&gt;;
</code></pre>
<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明:</p>
<pre><code>unexport &lt;variable ...&gt;;
</code></pre>
<p>如：</p>
<p>示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> variable = value</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable = value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> variable := value</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> variable += value</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable += value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>
<p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p>
<p>需要注意的是，有两个变量，一个是 <code>SHELL</code> ，一个是 <code>MAKEFLAGS</code> ，这两个变量不管你是 否export，其总是要传递到下层 Makefile中，特别是 <code>MAKEFLAGS</code> 变量，其中包含了make的参数<br />
信息，如果我们执行&quot;总控Makefile&quot;时有make参数或是在上层 Makefile中定义了这个变量，那么 <code>MAKEFLAGS</code> 变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p>
<p>但是make命令中的有几个参数并不往下传递，它们是 <code>-C</code> , <code>-f</code> , <code>-h</code>, <code>-o</code> 和 <code>-W</code> （有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line">&gt;  cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure>
<p>如果你定义了环境变量 <code>MAKEFLAGS</code> ，那么你得确信其中的选项是大家都会用到的，如果其中有 <code>-t</code> , <code>-n</code> 和 <code>-q</code> 参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p>
<p>还有一个在&quot;嵌套执行&quot;中比较有用的参数， <code>-w</code> 或是 <code>--print-directory</code> 会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是&quot;/home/hchen/gnu/make&quot;，如果我们使用 <code>make -w</code> 来执行，那么当进入该目录时，我们会看 到:</p>
<pre><code>make: Entering directory `/home/hchen/gnu/make'.
</code></pre>
<p>而在完成下层make后离开目录时，我们会看到:</p>
<pre><code>make: Leaving directory `/home/hchen/gnu/make'
</code></pre>
<p>当你使用 <code>-C</code> 参数来指定make下层Makefile时， <code>-w</code> 会被自动打开的。如果参数中有 <code>-s</code> （ <code>--slient</code> ）或是 <code>--no-print-directory</code> ，那么， <code>-w</code> 总是失效的。</p>
<h2 id="45-定义命令包"><a class="markdownIt-Anchor" href="#45-定义命令包"></a> 4.5 定义命令包</h2>
<p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>这里，&quot;run-yacc&quot;是这个命令包的名字，其不要和Makefile中的变量重名。在 <code>define</code> 和 <code>endef</code> 中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生<br />
成&quot;y.tab.c&quot;的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">foo.c : foo.y</span><br><span class="line">&gt;  $(run-yacc)</span><br></pre></td></tr></table></figure>
<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包&quot;run-yacc&quot;中的 <code>$^</code> 就是 <code>foo.y</code> ， <code>$@</code> 就是 <code>foo.c</code> （有关这种以 <code>$</code> 开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h1 id="5-使用变量"><a class="markdownIt-Anchor" href="#5-使用变量"></a> 5. 使用变量</h1>
<p>在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在&quot;目标&quot;，“依赖目标”，&quot;命令&quot;或是Makefile的其它部分中。</p>
<p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、&quot;Foo&quot;和&quot;FOO&quot;是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p>
<p>有一些变量是很奇怪字串，如 <code>$&lt;</code> 、 <code>$@</code> 等，这些是自动化变量，我会在后面介绍。</p>
<h2 id="51-变量的基础"><a class="markdownIt-Anchor" href="#51-变量的基础"></a> 5.1 变量的基础</h2>
<p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，但最好用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code> 把变量给包括起来。如果你要使用真实的 <code>$</code> 字符，那么你需要用 <code>$$</code><br />
来表示。</p>
<p>变量可以使用在许多地方，如规则中的&quot;目标&quot;、“依赖”、&quot;命令&quot;以及新的变量中。先看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">objects = program.o foo.o utils.o</span><br><span class="line">program : <span class="variable">$(objects)</span></span><br><span class="line">&gt;  cc -o program <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br></pre></td></tr></table></figure>
<p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">foo = c</span><br><span class="line">prog.o : prog.<span class="variable">$(foo)</span></span><br><span class="line">&gt;  <span class="variable">$(foo)</span><span class="variable">$(foo)</span> -<span class="variable">$(foo)</span> prog.<span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>
<p>展开后得到：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">prog.o : prog.c</span><br><span class="line">&gt;  cc -c prog.c</span><br></pre></td></tr></table></figure>
<p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个&quot;替代&quot;的原理。</p>
<p>另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>
<h2 id="52-变量中的变量"><a class="markdownIt-Anchor" href="#52-变量中的变量"></a> 5.2 变量中的变量</h2>
<p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式，也就是简单的使用 <code>=</code> 号，在 <code>=</code> 左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt;  echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>
<p>我们执行&quot;make all&quot;将会打出变量 <code>$(foo)</code> 的值是 <code>Huh?</code> （ <code>$(foo)</code> 的值是<code>$(bar)</code> ， <code>$(bar)</code> 的值是 <code>$(ugh)</code> ， <code>$(ugh)</code> 的值是 <code>Huh?</code> ）可见，变 量是可以使用后面的变量来定义的。</p>
<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(include_dirs)</span> -O</span><br><span class="line">include_dirs = -Ifoo -Ibar</span><br></pre></td></tr></table></figure>
<p>当 <code>CFLAGS</code> 在命令中被展开时，会是 <code>-Ifoo -Ibar -O</code> 。但这种形式也有不好的地方，那就 是递归定义，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(CFLAGS)</span> -O</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">A = <span class="variable">$(B)</span></span><br><span class="line">B = <span class="variable">$(A)</span></span><br></pre></td></tr></table></figure>
<p>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数&quot;wildcard&quot;和&quot;shell&quot;发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是 <code>:=</code> 操作符，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">y := foo bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := foo</span><br></pre></td></tr></table></figure>
<p>那么，y的值是&quot;bar&quot;，而不是&quot;foo bar&quot;。</p>
<p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量&quot;MAKELEVEL&quot;的使用：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (0,$&#123;MAKELEVEL&#125;)</span><br><span class="line">cur-dir   := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">whoami    := <span class="variable">$(<span class="built_in">shell</span> whoami)</span></span><br><span class="line">host-type := <span class="variable">$(<span class="built_in">shell</span> arch)</span></span><br><span class="line">MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>关于条件表达式和函数，我们在后面再说，对于系统变量&quot;MAKELEVEL&quot;，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的&quot;嵌套使用make&quot;），那么，这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure>
<p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用&quot;#“注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于”#“的使用，注释符”#&quot;的这种特性值得我们注意，如果我们这样定义一个变量：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dir := /foo/bar    <span class="comment"># directory to put the frobs in</span></span><br></pre></td></tr></table></figure>
<p>dir这个变量的值是&quot;/foo/bar&quot;，后面还跟了4个空格，如果我们这样使用这个变量来指定别的目录------&quot;$(dir)/file&quot;那么就完蛋了。</p>
<p>还有一个比较有用的操作符是 <code>?=</code> ，先看示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure>
<p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是&quot;bar&quot;，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">    FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h2 id="53-变量高级用法"><a class="markdownIt-Anchor" href="#53-变量高级用法"></a> 5.3 变量高级用法</h2>
<p>这里介绍两种变量的高级使用方法，第一种是变量值的替换。</p>
<p>我们可以替换变量中的共有的部分，其格式是 <code>$(var:a=b)</code> 或是 <code>$&#123;var:a=b&#125;</code>，其意思是，把变量&quot;var&quot;中所有以&quot;a&quot;字串&quot;结尾&quot;的&quot;a&quot;替换成&quot;b&quot;字串。这里的&quot;结尾&quot;意思是&quot;空格&quot;或是&quot;结束符&quot;。</p>
<p>还是看一个示例吧：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure>
<p>这个示例中，我们先定义了一个 <code>$(foo)</code> 变量，而第二行的意思是把 <code>$(foo)</code> 中所有以 <code>.o</code> 字串&quot;结尾&quot;全部替换成 <code>.c</code> ，所以我们的 <code>$(bar)</code> 的值就是&quot;a.c b.c c.c&quot;。</p>
<p>另外一种变量替换的技术是以&quot;静态模式&quot;（参见前面章节）定义的，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure>
<p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个 <code>%</code> 字符，这个例子同样让 <code>$(bar)</code> 变量的值为&quot;a.c b.c c.c&quot;。</p>
<p>第二种高级用法是------“把变量的值再当成变量”。先看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，$(x)的值是&quot;y&quot;，所以$($(x))就是$(y)，于是$(a)的值就是&quot;z&quot;。（注意，是&quot;x=y&quot;，而不是&quot;x=$(y)&quot;）</p>
<p>我们还可以使用更多的层次：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">z = u</span><br><span class="line">a := $($(<span class="variable">$(x)</span>))</span><br></pre></td></tr></table></figure>
<p>这里的 <code>$(a)</code> 的值是&quot;u&quot;，相关的推导留给读者自己去做吧。</p>
<p>让我们再复杂一点，使用上&quot;在变量定义中使用变量&quot;的第一个方式，来看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = z</span><br><span class="line">z = Hello</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>$($(x))</code> 被替换成了 <code>$($(y))</code> ，因为 <code>$(y)</code> 值是&quot;z&quot;，所以，最终结果是： <code>a:=$(z)</code> ，也就是&quot;Hello&quot;。</p>
<p>再复杂一点，我们再加上函数：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">y = <span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span></span><br><span class="line">z = y</span><br><span class="line">a := $($(<span class="variable">$(z)</span>))</span><br></pre></td></tr></table></figure>
<p>这个例子中， <code>$($($(z)))</code> 扩展为 <code>$($(y))</code> ，而其再次被扩展为 <code>$($(subst 1,2,$(x)))</code> 。 <code>$(x)</code> 的值是&quot;variable1&quot;，subst函数把&quot;variable1&quot;中的所有&quot;1&quot;字串替换成&quot;2&quot;字串，于是，“variable1&quot;变成&quot;variable2”，再取其值，所以，最终， <code>$(a)</code> 的值就是 <code>$(variable2)</code> 的值------“Hello”。（喔，好不容易）</p>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line">b = second</span><br><span class="line">all = $($a_$b)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>$a_$b</code> 组成了&quot;first_second&quot;，于是， <code>$(all)</code> 的值就是&quot;Hello&quot;。</p>
<p>再来看看结合第一种技术的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">a_objects := a.o b.o c.o</span><br><span class="line">1_objects := 1.o 2.o 3.o</span><br><span class="line"></span><br><span class="line">sources := $(<span class="variable">$(a1)</span>_objects:.o=.c)</span><br></pre></td></tr></table></figure>
<p>这个例子中，如果 <code>$(a1)</code> 的值是&quot;a&quot;的话，那么， <code>$(sources)</code> 的值就是&quot;a.c b.c c.c&quot;； 如果 <code>$(a1)</code> 的值是&quot;1&quot;，那么 <code>$(sources)</code> 的值是&quot;1.c 2.c 3.c&quot;。</p>
<p>再来看一个这种技术和&quot;函数&quot;与&quot;条件语句&quot;一同使用的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> do_sort</span><br><span class="line">    func := sort</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    func := strip</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">bar := a d b g q c</span><br><span class="line"></span><br><span class="line">foo := $(<span class="variable">$(func)</span> <span class="variable">$(bar)</span>)</span><br></pre></td></tr></table></figure>
<p>这个示例中，如果定义了&quot;do_sort&quot;，那么： <code>foo := $(sort a d b g q c)</code> ，于是 <code>$(foo)</code> 的值就是 “a b c d g q”，而如果没有定义&quot;do_sort&quot;，那么：<br />
<code>foo := $(strip a d b g q c)</code> ，调用的就是strip函数。</p>
<p>当然，&quot;把变量的值再当成变量&quot;这种技术，同样可以用在操作符的左边:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dir = foo</span><br><span class="line"><span class="variable">$(dir)</span>_sources := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span></span><br><span class="line"><span class="keyword">define</span> <span class="variable">$(dir)</span>_print</span><br><span class="line">lpr $(<span class="variable">$(dir)</span>_sources)</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>这个例子中定义了三个变量：“dir”，“foo_sources&quot;和&quot;foo_print”。</p>
<h2 id="54-追加变量值"><a class="markdownIt-Anchor" href="#54-追加变量值"></a> 5.4 追加变量值</h2>
<p>我们可以使用 <code>+=</code> 操作符给变量追加值，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br></pre></td></tr></table></figure>
<p>于是，我们的 <code>$(objects)</code> 值变成：“main.o foo.o bar.o utils.o<br />
another.o”（another.o被追加进去了）</p>
<p>使用 <code>+=</code> 操作符，可以模拟为下面的这种例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects := <span class="variable">$(objects)</span> another.o</span><br></pre></td></tr></table></figure>
<p>所不同的是，用 <code>+=</code> 更为简洁。</p>
<p>如果变量之前没有定义过，那么， <code>+=</code> 会自动变成 <code>=</code> ，如果前面有变量定义，那么 <code>+=</code> 会继承于前次操作的赋值符。如果前一次的是 <code>:=</code> ，那么 <code>+=</code> 会以 <code>:=</code> 作为其赋值符，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable := <span class="variable">$(variable)</span> more</span><br></pre></td></tr></table></figure>
<p>但如果是这种情况：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable = value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure>
<p>由于前次的赋值符是 <code>=</code> ，所以 <code>+=</code> 也会以 <code>=</code> 来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h2 id="55-override-指示符"><a class="markdownIt-Anchor" href="#55-override-指示符"></a> 5.5 override 指示符</h2>
<p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用&quot;override&quot;指示符。其语法是:</p>
<pre><code>override &lt;variable&gt;; = &lt;value&gt;;

override &lt;variable&gt;; := &lt;value&gt;;
</code></pre>
<p>当然，你还可以追加:</p>
<pre><code>override &lt;variable&gt;; += &lt;more text&gt;;
</code></pre>
<p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用override指示符，如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> foo</span><br><span class="line">bar</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<h2 id="56-多行变量"><a class="markdownIt-Anchor" href="#56-多行变量"></a> 5.6 多行变量</h2>
<p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过&quot;命令包&quot;的技术就是利用这个关键字）。</p>
<p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方式和&quot;=&quot;操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，<br />
所以如果你用define定义的命令变量中没有以 <code>Tab</code> 键开头，那么 make 就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<h2 id="57-环境变量"><a class="markdownIt-Anchor" href="#57-环境变量"></a> 5.7 环境变量</h2>
<p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了&quot;-e&quot;参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了 <code>CFLAGS</code> 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像&quot;全局变量&quot;和&quot;局部变量&quot;的特性。</p>
<p>当make嵌套调用时（参见前面的&quot;嵌套调用&quot;章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用export关键字来声明。（参见前面章节）</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h2 id="58-目标变量"><a class="markdownIt-Anchor" href="#58-目标变量"></a> 5.8 目标变量</h2>
<p>前面我们所讲的在Makefile中定义的变量都是&quot;全局变量&quot;，在整个文件，我们都可以访问这些变量。当然，“自动化变量&quot;除外，如 <code>$&lt;</code> 等这种类量的自动化变量就属于&quot;规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我也同样可以为某个目标设置局部变量，这种变量被称为&quot;Target-specific Variable&quot;，它可以和&quot;全局变量&quot;同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;;</span><br><span class="line"></span><br><span class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure>
<p>&lt;variable-assignment&gt;;可以是前面讲过的各种赋值表达式，如 <code>=</code> 、 <code>:=</code> 、 <code>+=</code> 或是 <code>?=</code> 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o : prog.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.c</span><br><span class="line"></span><br><span class="line">foo.o : foo.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> foo.c</span><br><span class="line"></span><br><span class="line">bar.o : bar.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> bar.c</span><br></pre></td></tr></table></figure>
<p>在这个示例中，不管全局的 <code>$(CFLAGS)</code> 的值是什么，在prog目标，以及其所引发的所有规则 中（prog.o foo.o bar.o的规则）， <code>$(CFLAGS)</code> 的值都是 <code>-g</code></p>
<h2 id="59-模式变量"><a class="markdownIt-Anchor" href="#59-模式变量"></a> 5.9 模式变量</h2>
<p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种&quot;模式&quot;，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的&quot;模式&quot;一般是至少含有一个 <code>%</code> 的，所以，我们可以以如下方式给所有以 <code>.o</code> 结尾的目标定义目标变量：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure>
<p>同样，模式变量的语法和&quot;目标变量&quot;一样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;pattern ...&gt;; : &lt;variable-assignment&gt;;</span><br><span class="line"></span><br><span class="line">&lt;pattern ...&gt;; : <span class="keyword">override</span> &lt;variable-assignment&gt;;</span><br></pre></td></tr></table></figure>
<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<h1 id="6-使用条件判断"><a class="markdownIt-Anchor" href="#6-使用条件判断"></a> 6. 使用条件判断</h1>
<p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h2 id="61-示例"><a class="markdownIt-Anchor" href="#61-示例"></a> 6.1 示例</h2>
<p>下面的例子，判断 <code>$(CC)</code> 变量是否 <code>gcc</code> ，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>可见，在上面示例的这个规则中，目标 <code>foo</code> 可以根据变量 <code>$(CC)</code> 值来选取不同的函数库来 编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字： <code>ifeq</code> 、 <code>else</code> 和 <code>endif</code> 。<br />
<code>ifeq</code> 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。 <code>else</code> 表示条件表达式为假的情况。 <code>endif</code> 表示一个条件语句的结束，任何一个条件表达 式都应该以 <code>endif</code> 结束。</p>
<p>当我们的变量 <code>$(CC)</code> 值是 <code>gcc</code> 时，目标 <code>foo</code> 的规则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br></pre></td></tr></table></figure>
<p>而当我们的变量 <code>$(CC)</code> 值不是 <code>gcc</code> 时（比如 <code>cc</code> ），目标 <code>foo</code> 的规则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br></pre></td></tr></table></figure>
<p>当然，我们还可以把上面的那个例子写得更简洁一些：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure>
<h2 id="62-语法"><a class="markdownIt-Anchor" href="#62-语法"></a> 6.2 语法</h2>
<p>条件表达式的语法为:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>以及:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;text-if-false&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;conditional-directive&gt;</code> 表示条件关键字，如 <code>ifeq</code> 。这个关键字有四个。</p>
<p>第一个是我们前面所见过的 <code>ifeq</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同。当然，参数中我们还可以使用make的函数。如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(foo)</span>)</span>,)</span><br><span class="line">&lt;text-if-empty&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>这个示例中使用了 <code>strip</code> 函数，如果这个函数的返回值是空（Empty），那么 <code>&lt;text-if-empty&gt;</code> 就生效。</p>
<p>第二个条件关键字是 <code>ifneq</code> 。语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>其比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同，如果不同，则为真。和 <code>ifeq</code> 类似。</p>
<p>第三个条件关键字是 <code>ifdef</code> 。语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure>
<p>如果变量 <code>&lt;variable-name&gt;</code> 的值非空，那到表达式为真。否则，表达式为假。当然， <code>&lt;variable-name&gt;</code> 同样可以是一个函数的返回值。注意， <code>ifdef</code> 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</p>
<p>示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo =</span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>第一个例子中， <code>$(frobozz)</code> 值是 <code>yes</code> ，第二个则是 <code>no</code>。</p>
<p>第四个条件关键字是 <code>ifndef</code> 。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure>
<p>这个我就不多说了，和 <code>ifdef</code> 是相反的意思。</p>
<p>在 <code>&lt;conditional-directive&gt;</code> 这一行上，多余的空格是被允许的，但是不能以<code>Tab</code> 键 作为开始（不然就被认为是命令）。而注释符 <code>#</code> 同样也是安全的。<code>else</code> 和 <code>endif</code> 也一样，只要不是以 <code>Tab</code> 键开始就行了。</p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如 <code>$@</code> 等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h1 id="7-使用函数"><a class="markdownIt-Anchor" href="#7-使用函数"></a> 7. 使用函数</h1>
<p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make 所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<h2 id="71-函数的调用语法"><a class="markdownIt-Anchor" href="#71-函数的调用语法"></a> 7.1 函数的调用语法</h2>
<p>函数调用，很像变量的使用，也是以 <code>$</code> 来标识的，其语法如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br></pre></td></tr></table></figure>
<p>或是:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>这里， <code>&lt;function&gt;</code> 就是函数名，make支持的函数不多。 <code>&lt;arguments&gt;</code> 为函数的参数， 参数间以逗号 <code>,</code> 分隔，而函数名和参数之间以&quot;空格&quot;分隔。函数调用以 <code>$</code> 开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用 <code>$(subst a,b,$(x))</code> 这样的形式，而不是 <code>$(subst a,b, $&#123;x&#125;)</code> 的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p>
<p>还是来看一个示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中， <code>$(comma)</code> 的值是一个逗号。 <code>$(space)</code> 使用了 <code>$(empty)</code> 定义了 一个空格， <code>$(foo)</code> 的值是 <code>a b c</code> ， <code>$(bar)</code><br />
的定义用，调用了函数 <code>subst</code> ，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把 <code>$(foo)</code> 中的空格替换成逗号，所以<code>$(bar)</code> 的值 是 <code>a,b,c</code> 。</p>
<h2 id="72-字符串处理函数"><a class="markdownIt-Anchor" href="#72-字符串处理函数"></a> 7.2 字符串处理函数</h2>
<h3 id="721-subst"><a class="markdownIt-Anchor" href="#721-subst"></a> 7.2.1 subst</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>名称：字符串替换函数</p>
</li>
<li>
<p>功能：把字串 <code>&lt;text&gt;</code> 中的 <code>&lt;from&gt;</code> 字符串替换成 <code>&lt;to&gt;</code> 。</p>
</li>
<li>
<p>返回：函数返回被替换过后的字符串。</p>
</li>
<li>
<p>示例：</p>
<blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>把 <code>feet on the street</code> 中的 <code>ee</code> 替换成 <code>EE</code> ，返回结果是 <code>fEEt on the strEEt</code> 。</p>
<h3 id="722-patsubst"><a class="markdownIt-Anchor" href="#722-patsubst"></a> 7.2.2 patsubst</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>名称：模式字符串替换函数。</p>
</li>
<li>
<p>功能：查找 <code>&lt;text&gt;</code><br />
中的单词（单词以&quot;空格&quot;、“Tab&quot;或&quot;回车”&quot;换行&quot;分隔）是否符合模式 <code>&lt;pattern&gt;</code> ，如果匹配的话，则以 <code>&lt;replacement&gt;</code> 替换。这里，<code>&lt;pattern&gt;</code> 可以 包括通配符 <code>%</code> ，表示任意长度的字串。如果 <code>&lt;replacement&gt;</code> 中也包含 <code>%</code> ，那么， <code>&lt;replacement&gt;</code> 中的这个 <code>%</code> 将是 <code>&lt;pattern&gt;</code> 中的那个 <code>%</code> 所代表的字串。 （可以用 <code>\</code> 来转义，以 <code>\%</code> 来表示真实含义的 <code>%</code> 字符）</p>
</li>
<li>
<p>返回：函数返回被替换过后的字符串。</p>
</li>
<li>
<p>示例：</p>
<blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>把字串 <code>x.c.c bar.c</code> 符合模式 <code>%.c</code> 的单词替换成 <code>%.o</code> ，返回结果是 <code>x.c.o bar.o</code></p>
<ul>
<li>
<p>备注：这和我们前面&quot;变量章节&quot;说过的相关知识有点相似。如 <code>$(var:&lt;pattern&gt;=&lt;replacement&gt;;)</code> 相当于 <code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))</code> ，而 <code>$(var: &lt;suffix&gt;=&lt;replacement&gt;)</code> 则相当于 <code>$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var))</code> 。</p>
<p>例如有:</p>
<pre><code>objects = foo.o bar.o baz.o，
</code></pre>
<p>那么， <code>$(objects:.o=.c)</code> 和 <code>$(patsubst %.o,%.c,$(objects))</code> 是一样的。</p>
</li>
</ul>
<h3 id="723-strip"><a class="markdownIt-Anchor" href="#723-strip"></a> 7.2.3 strip</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> &lt;string&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>名称：去空格函数。</p>
</li>
<li>
<p>功能：去掉 <code>&lt;string&gt;</code> 字串中开头和结尾的空字符。</p>
</li>
<li>
<p>返回：返回被去掉空格的字符串值。</p>
</li>
<li>
<p>示例：</p>
<blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a b c )</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>把字串 去掉开头和结尾的空格，结果是 <code>a b c</code>。</p>
</li>
</ul>
<h3 id="724-findstring"><a class="markdownIt-Anchor" href="#724-findstring"></a> 7.2.4 findstring</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>名称：查找字符串函数</p>
</li>
<li>
<p>功能：在字串 <code>&lt;in&gt;</code> 中查找 <code>&lt;find&gt;</code> 字串。</p>
</li>
<li>
<p>返回：如果找到，那么返回 <code>&lt;find&gt;</code> ，否则返回空字符串。</p>
</li>
<li>
<p>示例：</p>
<blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,b c)</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>第一个函数返回 <code>a</code> 字符串，第二个返回空字符串</p>
<h3 id="725-filter"><a class="markdownIt-Anchor" href="#725-filter"></a> 7.2.5 filter</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern...&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>名称：过滤函数</p>
</li>
<li>
<p>功能：以 <code>&lt;pattern&gt;</code> 模式过滤 <code>&lt;text&gt;</code> 字符串中的单词，保留符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式。</p>
</li>
<li>
<p>返回：返回符合模式 <code>&lt;pattern&gt;</code> 的字串。</p>
</li>
<li>
<p>示例：</p>
<blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">sources := foo.c bar.c baz.s ugh.h</span><br><span class="line"><span class="section">foo: <span class="variable">$(sources)</span></span></span><br><span class="line">&gt;  cc <span class="variable">$(<span class="built_in">filter</span> %.c %.s,<span class="variable">$(sources)</span>)</span> -o foo</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>$(filter %.c %.s,$(sources))</code> 返回的值是 <code>foo.c bar.c baz.s</code>。</p>
</li>
</ul>
<h3 id="726-filter-out"><a class="markdownIt-Anchor" href="#726-filter-out"></a> 7.2.6 filter-out</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out &lt;pattern...&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>名称：反过滤函数</p>
</li>
<li>
<p>功能：以 <code>&lt;pattern&gt;</code> 模式过滤 <code>&lt;text&gt;</code> 字符串中的单词，去除符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式。</p>
</li>
<li>
<p>返回：返回不符合模式 <code>&lt;pattern&gt;</code> 的字串。</p>
</li>
<li>
<p>示例：</p>
<blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects=main1.o foo.o main2.o bar.o</span><br><span class="line">mains=main1.o main2.o</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>$(filter-out $(mains),$(objects))</code> 返回值是 <code>foo.o bar.o</code> 。</p>
</li>
</ul>
<h3 id="727-sort"><a class="markdownIt-Anchor" href="#727-sort"></a> 7.2.7 sort</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> &lt;list&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：排序函数</li>
<li>功能：给字符串 <code>&lt;list&gt;</code> 中的单词排序（升序）。</li>
<li>返回：返回排序后的字符串。</li>
<li>示例： <code>$(sort foo bar lose)</code> 返回 <code>bar foo lose</code> 。</li>
<li>备注： <code>sort</code> 函数会去掉 <code>&lt;list&gt;</code> 中相同的单词。</li>
</ul>
<h3 id="728-word"><a class="markdownIt-Anchor" href="#728-word"></a> 7.2.8 word</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> &lt;n&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取单词函数</li>
<li>功能：取字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。（从一开始）</li>
<li>返回：返回字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。如果 <code>&lt;n&gt;</code> 比 <code>&lt;text&gt;</code> 中的 单词数要大，那么返回空字符串。</li>
<li>示例： <code>$(word 2, foo bar baz)</code> 返回值是 <code>bar</code> 。</li>
</ul>
<h3 id="729-wordlist"><a class="markdownIt-Anchor" href="#729-wordlist"></a> 7.2.9 wordlist</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取单词串函数</li>
<li>功能：从字符串 <code>&lt;text&gt;</code> 中取从 <code>&lt;ss&gt;</code> 开始到 <code>&lt;e&gt;</code> 的单词串。 <code>&lt;ss&gt;</code><br />
和 <code>&lt;e&gt;</code> 是一个数字。</li>
<li>返回：返回字符串 <code>&lt;text&gt;</code> 中从 <code>&lt;ss&gt;</code> 到 <code>&lt;e&gt;</code> 的单词字串。如果 <code>&lt;ss&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串。如果 <code>&lt;e&gt;</code> 大于 <code>&lt;text&gt;</code> 的单词数， 那么返回从 <code>&lt;ss&gt;</code> 开始，到 <code>&lt;text&gt;</code> 结束的单词串。</li>
<li>示例： <code>$(wordlist 2, 3, foo bar baz)</code> 返回值是 <code>bar baz</code> 。</li>
</ul>
<h3 id="7210-words"><a class="markdownIt-Anchor" href="#7210-words"></a> 7.2.10 words</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(words &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：单词个数统计函数</li>
<li>功能：统计 <code>&lt;text&gt;</code> 中字符串中的单词个数。</li>
<li>返回：返回 <code>&lt;text&gt;</code> 中的单词数。</li>
<li>示例： <code>$(words, foo bar baz)</code> 返回值是 <code>3</code> 。</li>
<li>备注：如果我们要取 <code>&lt;text&gt;</code> 中最后的一个单词，我们可以这样：<br />
<code>$(word $(words &lt;text&gt;),&lt;text&gt;)</code> 。</li>
</ul>
<h3 id="7211-firstword"><a class="markdownIt-Anchor" href="#7211-firstword"></a> 7.2.11 firstword</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：首单词函数------firstword。</li>
<li>功能：取字符串 <code>&lt;text&gt;</code> 中的第一个单词。</li>
<li>返回：返回字符串 <code>&lt;text&gt;</code> 的第一个单词。</li>
<li>示例： <code>$(firstword foo bar)</code> 返回值是 <code>foo</code>。</li>
<li>备注：这个函数可以用 <code>word</code> 函数来实现： <code>$(word 1,&lt;text&gt;)</code> 。</li>
</ul>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用 <code>VPATH</code> 变量来指定&quot;依赖文件&quot;的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 <code>CFLAGS</code> ，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> CFLAGS += <span class="variable">$(<span class="built_in">patsubst</span> %,-I%,$(<span class="built_in">subst</span> :, ,<span class="variable">$(VPATH)</span>)</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们的 <code>$(VPATH)</code> 值是 <code>src:../headers</code> ，那么 <code>$(patsubst %,-I%,$(subst :, ,$(VPATH)))</code> 将返回 <code>-Isrc -I../headers</code> ，这正是cc或gcc搜索头文件路径的参数。</p>
<h2 id="73-文件名操作函数"><a class="markdownIt-Anchor" href="#73-文件名操作函数"></a> 7.3 文件名操作函数</h2>
<p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<h3 id="731-dir"><a class="markdownIt-Anchor" href="#731-dir"></a> 7.3.1 dir</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取目录函数------dir。</li>
<li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出目录部分。目录部分是指最后一个反斜杠（ <code>/</code> ）之前 的部分。如果没有反斜杠，那么返回 <code>./</code> 。</li>
<li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的目录部分。</li>
<li>示例： <code>$(dir src/foo.c hacks)</code> 返回值是 <code>src/ ./</code> 。</li>
</ul>
<h3 id="732-notdir"><a class="markdownIt-Anchor" href="#732-notdir"></a> 7.3.2 notdir</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取文件函数------notdir。</li>
<li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出非目录部分。非目录部分是指最後一个反斜杠（ <code>/</code> ） 之后的部分。</li>
<li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的非目录部分。</li>
<li>示例: <code>$(notdir src/foo.c hacks)</code> 返回值是 <code>foo.c hacks</code> 。</li>
</ul>
<h3 id="733-suffix"><a class="markdownIt-Anchor" href="#733-suffix"></a> 7.3.3 suffix</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取後缀函数------suffix。</li>
<li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的后缀。</li>
<li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的后缀序列，如果文件没有后缀，则返回空字串。</li>
<li>示例： <code>$(suffix src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>.c .c</code>。</li>
</ul>
<h3 id="734-basename"><a class="markdownIt-Anchor" href="#734-basename"></a> 7.3.4 basename</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取前缀函数------basename。</li>
<li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的前缀部分。</li>
<li>返回：返回文件名序列 <code>&lt;names&gt;</code><br />
的前缀序列，如果文件没有前缀，则返回空字串。</li>
<li>示例： <code>$(basename src/foo.c src-1.0/bar.c hacks)</code> 返回值是<br />
<code>src/foo src-1.0/bar hacks</code> 。</li>
</ul>
<h3 id="735-addsuffix"><a class="markdownIt-Anchor" href="#735-addsuffix"></a> 7.3.5 addsuffix</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> &lt;<span class="built_in">suffix</span>&gt;,&lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：加后缀函数------addsuffix。</li>
<li>功能：把后缀 <code>&lt;suffix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词后面。</li>
<li>返回：返回加过后缀的文件名序列。</li>
<li>示例： <code>$(addsuffix .c,foo bar)</code> 返回值是 <code>foo.c bar.c</code> 。</li>
</ul>
<h3 id="736-addprefix"><a class="markdownIt-Anchor" href="#736-addprefix"></a> 7.3.6 addprefix</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> &lt;prefix&gt;,&lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：加前缀函数------addprefix。</li>
<li>功能：把前缀 <code>&lt;prefix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词前面。</li>
<li>返回：返回加过前缀的文件名序列。</li>
<li>示例： <code>$(addprefix src/,foo bar)</code> 返回值是 <code>src/foo src/bar</code> 。</li>
</ul>
<h3 id="737-join"><a class="markdownIt-Anchor" href="#737-join"></a> 7.3.7 join</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> &lt;list1&gt;,&lt;list2&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：连接函数------join。</li>
<li>功能：把 <code>&lt;list2&gt;</code> 中的单词对应地加到 <code>&lt;list1&gt;</code> 的单词后面。如果 <code>&lt;list1&gt;</code> 的 单词个数要比 <code>&lt;list2&gt;</code> 的多，那么， <code>&lt;list1&gt;</code> 中的多出来的单词将保持原样。如果 <code>&lt;list2&gt;</code> 的单词个数要比 <code>&lt;list1&gt;</code> 多，那么， <code>&lt;list2&gt;</code> 多出来的单词将被复制到 <code>&lt;list1&gt;</code> 中。</li>
<li>返回：返回连接过后的字符串。</li>
<li>示例： <code>$(join aaa bbb , 111 222 333)</code> 返回值是 <code>aaa111 bbb222 333</code>。</li>
</ul>
<h2 id="74-foreach-函数"><a class="markdownIt-Anchor" href="#74-foreach-函数"></a> 7.4 foreach 函数</h2>
<p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的意思是，把参数 <code>&lt;list&gt;</code> 中的单词逐一取出放到参数 <code>&lt;var&gt;</code> 所指定的变量中， 然后再执行 <code>&lt;text&gt;</code> 所包含的表达式。每一次 <code>&lt;text&gt;</code> 会返回一个字符串，循环过程中， <code>&lt;text&gt;</code> 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， <code>&lt;text&gt;</code> 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<p>所以， <code>&lt;var&gt;</code> 最好是一个变量名， <code>&lt;list&gt;</code> 可以是一个表达式，而 <code>&lt;text&gt;</code> 中一般会 使用 <code>&lt;var&gt;</code> 这个参数来依次枚举 <code>&lt;list&gt;</code> 中的单词。举个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">names := a b c d</span><br><span class="line"></span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> n,<span class="variable">$(names)</span>,<span class="variable">$(n)</span>.o)</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中， <code>$(name)</code> 中的单词会被挨个取出，并存到变量 <code>n</code> 中，<code>$(n).o</code> 每次 根据 <code>$(n)</code> 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，<code>$(files)</code> 的值是 <code>a.o b.o c.o d.o</code> 。</p>
<p>注意，foreach中的 <code>&lt;var&gt;</code> 参数是一个临时的局部变量，foreach函数执行完后，参数 <code>&lt;var&gt;</code> 的变量将不在作用，其作用域只在foreach函数当中。</p>
<h2 id="75-if-函数"><a class="markdownIt-Anchor" href="#75-if-函数"></a> 7.5 if 函数</h2>
<p>if函数很像GNU的make所支持的条件语句------ifeq（参见前面所述的章节），if函数的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span></span><br></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span></span><br></pre></td></tr></table></figure>
<p>可见，if函数可以包含&quot;else&quot;部分，或是不含。即if函数的参数可以是两个，也可以是三个。<code>&lt;condition&gt;</code>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是， <code>&lt;then-part&gt;</code> 会被计算，否则 <code>&lt;else-part&gt;</code> 会被计算。</p>
<p>而if函数的返回值是，如果 <code>&lt;condition&gt;</code> 为真（非空字符串），那个 <code>&lt;then-part&gt;</code> 会是整个函数的返回值，如果 <code>&lt;condition&gt;</code> 为假（空字符串），那么 <code>&lt;else-part&gt;</code> 会是 整个函数的返回值，此时如果 <code>&lt;else-part&gt;</code> 没有被定义，那么，整个函数返回空字串。</p>
<p>所以， <code>&lt;then-part&gt;</code> 和 <code>&lt;else-part&gt;</code> 只会有一个被计算。</p>
<h2 id="76-call函数"><a class="markdownIt-Anchor" href="#76-call函数"></a> 7.6 call函数</h2>
<p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</span></span><br></pre></td></tr></table></figure>
<p>当make执行这个函数时， <code>&lt;expression&gt;</code> 参数中的变量，如 <code>$(1)</code> 、 <code>$(2)</code> 等，会 被参数 <code>&lt;parm1&gt;</code> 、 <code>&lt;parm2&gt;</code> 、 <code>&lt;parm3&gt;</code> 依次取代。而 <code>&lt;expression&gt;</code> 的 返回值就是 call 函数的返回值。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">reverse =  $(1) $(2)</span><br><span class="line"></span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br></pre></td></tr></table></figure>
<p>那么， <code>foo</code> 的值就是 <code>a b</code>。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">reverse =  $(2) $(1)</span><br><span class="line"></span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br></pre></td></tr></table></figure>
<p>此时的 <code>foo</code> 的值就是 <code>b a</code> 。</p>
<p>需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。</p>
<h2 id="77-origin函数"><a class="markdownIt-Anchor" href="#77-origin函数"></a> 7.7 origin函数</h2>
<p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure>
<p>注意， <code>&lt;variable&gt;</code> 是变量的名字，不应该是引用。所以你最好不要在 <code>&lt;variable&gt;</code> 中使用: <code>$</code>字符。Origin函数会以其返回值来告诉你这个变量的&quot;出生情况&quot;，下面，是origin函数的返回值:</p>
<p><code>undefined</code>:</p>
<p>如果 <code>&lt;variable&gt;</code> 从来没有定义过，origin函数返回这个值 <code>undefined</code></p>
<p><code>default</code>:</p>
<p>如果 <code>&lt;variable&gt;</code><br />
是一个默认的定义，比如&quot;CC&quot;这个变量，这种变量我们将在后面讲述。</p>
<p><code>environment</code>:</p>
<p>如果 <code>&lt;variable&gt;</code> 是一个环境变量，并且当Makefile被执行时， <code>-e</code> 参数没有被打开。</p>
<p><code>file</code>:</p>
<p>如果 <code>&lt;variable&gt;</code> 这个变量被定义在Makefile中。</p>
<p><code>command line</code>:</p>
<p>如果 <code>&lt;variable&gt;</code> 这个变量是被命令行定义的。</p>
<p><code>override</code>:</p>
<p>如果 <code>&lt;variable&gt;</code> 是被override指示符重新定义的。</p>
<p><code>automatic</code>:</p>
<p>如果 <code>&lt;variable&gt;</code>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p>
<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量&quot;bletch&quot;，而我们的环境中也有一个环境变量&quot;bletch&quot;，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> bletch</span><br><span class="line">    <span class="keyword">ifeq</span> <span class="string">&quot;$(origin bletch)&quot;</span> <span class="string">&quot;environment&quot;</span></span><br><span class="line">        bletch = barf, gag, etc.</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>当然，你也许会说，使用 <code>override</code>关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用 <code>override</code> 是可以达到这样的效果，可是 <code>override</code>过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<h2 id="78-shell函数"><a class="markdownIt-Anchor" href="#78-shell函数"></a> 7.8 shell函数</h2>
<p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号&quot;`&quot;是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h2 id="79-控制make的函数"><a class="markdownIt-Anchor" href="#79-控制make的函数"></a> 7.9 控制make的函数</h2>
<p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>产生一个致命的错误， <code>&lt;text ...&gt;</code>是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</p>
<p>示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: err</span></span><br><span class="line"></span><br><span class="line"><span class="section">err: <span class="variable">$(ERR)</span></span></span><br></pre></td></tr></table></figure>
<p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>
<h1 id="8-make-的运行"><a class="markdownIt-Anchor" href="#8-make-的运行"></a> 8. make 的运行</h1>
<p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h2 id="81-make的退出码"><a class="markdownIt-Anchor" href="#81-make的退出码"></a> 8.1 make的退出码</h2>
<p>make命令执行后有三个退出码：</p>
<dl>
<dt>0</dt>
<dd>表示成功执行。</dd>
<dt>1</dt>
<dd>如果make运行时出现任何错误，其返回1。</dd>
<dt>2</dt>
<dd>如果你使用了make的&quot;-q&quot;选项，并且make使得一些目标不需要更新，那么返回2。</dd>
</dl>
<p>Make的相关参数我们会在后续章节中讲述。</p>
<h2 id="82-指定makefile"><a class="markdownIt-Anchor" href="#82-指定makefile"></a> 8.2 指定Makefile</h2>
<p>前面我们说过，GNUmake找寻默认的Makefile的规则是在当前目录下依次找三个文件------“GNUmakefile”、“makefile&quot;和&quot;Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的 <code>-f</code> 或是 <code>--file</code> 参数（ <code>--makefile</code><br />
参数也行）。例如，我们有个makefile的名字是&quot;<a href="http://hchen.mk">hchen.mk</a>&quot;，那么，我们可以这样来让make来执行这个文件：</p>
<pre><code>make –f hchen.mk
</code></pre>
<p>如果在make的命令行是，你不只一次地使用了 <code>-f</code> 参数，那么，所有指定的makefile将会被连在 一起传递给make执行。</p>
<h2 id="83-指定目标"><a class="markdownIt-Anchor" href="#83-指定目标"></a> 8.3 指定目标</h2>
<p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的&quot;make clean&quot;形式）</p>
<p>任何在makefile中的目标都可以被指定成终极目标，但是除了以 <code>-</code> 打头，或是包含了 <code>=</code> 的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个make的环境变量叫 <code>MAKECMDGOALS</code>，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">ifneq</span> ( <span class="variable">$(MAKECMDGOALS)</span>,clean)</span><br><span class="line">    <span class="keyword">include</span> $(sources:.c=.d)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>基于上面的这个例子，只要我们输入的命令不是&quot;make clean&quot;，那么makefile会自动包含&quot;foo.d&quot; 和&quot;bar.d&quot;这两个makefile。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: prog1 prog2 prog3 prog4</span></span><br></pre></td></tr></table></figure>
<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序------“prog1”，“prog2”， “prog3&quot;和 “prog4”，我们可以使用&quot;make all&quot;命令来编译所有的目标（如果把all置成第一个目标，那么只需执行&quot;make”），我们也可以使用 “make prog2&quot;来单独编译目标&quot;prog2”。即然make可以指定所有makefile中的目标，那么也包括&quot;伪目标&quot;，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软<br />
件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<ul>
<li>all:这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</li>
<li>clean:这个伪目标功能是删除所有被make创建的文件。</li>
<li>install:这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</li>
<li>print:这个伪目标的功能是例出改变过的源文件。</li>
<li>tar:这个伪目标功能是把源程序打包备份。也就是一个tar文件。</li>
<li>dist:这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</li>
<li>TAGS:这个伪目标功能是更新所有的目标，以备完整地重编译使用。</li>
<li>check和test:这两个伪目标一般用来测试makefile的流程。</li>
</ul>
<p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的<br />
UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是------不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>
<h2 id="84-检查规则"><a class="markdownIt-Anchor" href="#84-检查规则"></a> 8.4 检查规则</h2>
<p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>
<dl>
<dt><code>-n</code>, <code>--just-print</code>, <code>--dry-run</code>, <code>--recon</code></dt>
<dd>不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不    执行，这些参数对于我们调试makefile很有用处。</dd>
<dt><code>-t</code>, <code>--touch</code></dt>
<dd>这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</dd>
<dt><code>-q</code>, <code>--question</code></dt>
<dd>这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</dd>
<dt><code>-W &lt;file&gt;</code>, <code>--what-if=&lt;file&gt;</code>, <code>--assume-new=&lt;file&gt;</code>, <code>--new-file=&lt;file&gt;</code></dt>
<dd>这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个    文件的命令，一般来说，可以和&quot;-n&quot;参数一同使用，来查看这个依赖文件所发生的规则命令。</dd>
</dl>
<p>另外一个很有意思的用法是结合 <code>-p</code> 和 <code>-v</code> 来输出makefile被执行时的信息（这个将在后面讲述）。</p>
<h2 id="85-make的参数"><a class="markdownIt-Anchor" href="#85-make的参数"></a> 8.5 make的参数</h2>
<p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>
<dl>
<dt><code>-b</code>, <code>-m</code></dt>
<dd>
<p>这两个参数的作用是忽略和其它版本make的兼容性。</p>
</dd>
<dt><code>-B</code>, <code>--always-make</code></dt>
<dd>
<p>认为所有的目标都需要更新（重编译）。</p>
</dd>
<dt><code>-C &lt;dir&gt;</code>, <code>--directory=&lt;dir&gt;</code></dt>
<dd>
<p>指定读取makefile的目录。如果有多个&quot;-C&quot;参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：&quot;make -C ~hchen/test -C  prog&quot;等价于 “make -C ~hchen/test/prog”。</p>
</dd>
<dt><code>-debug[=&lt;options&gt;]</code></dt>
<dd>
<p>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值：</p>
<ul>
<li>a: 也就是all，输出所有的调试信息。（会非常的多）</li>
<li>b: 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。</li>
<li>v: 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。</li>
<li>i: 也就是implicit，输出所以的隐含规则。</li>
<li>j: 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。</li>
<li>m: 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</li>
</ul>
</dd>
<dt><code>-d</code></dt>
<dd>
<p>相当于&quot;--debug=a&quot;。</p>
</dd>
<dt><code>-e</code>, <code>--environment-overrides</code></dt>
<dd>
<p>指明环境变量的值覆盖makefile中定义的变量的值。</p>
</dd>
<dt><code>-f=&lt;file&gt;</code>, <code>--file=&lt;file&gt;</code>, <code>--makefile=&lt;file&gt;</code></dt>
<dd>
<p>指定需要执行的makefile。</p>
</dd>
<dt><code>-h</code>, <code>--help</code></dt>
<dd>
<p>显示帮助信息。</p>
</dd>
<dt><code>-i</code> , <code>--ignore-errors</code></dt>
<dd>
<p>在执行时忽略所有的错误。</p>
</dd>
<dt><code>-I &lt;dir&gt;</code>, <code>--include-dir=&lt;dir&gt;</code></dt>
<dd>
<p>指定一个被包含makefile的搜索目标。可以使用多个&quot;-I&quot;参数来指定多个目录。</p>
</dd>
<dt><code>-j [&lt;jobsnum&gt;]</code>, <code>--jobs [=&lt;jobsnum&gt;]</code></dt>
<dd>
<p>指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的&quot;-j&quot;参数，那么仅最后一个&quot;-j&quot;才是有效的。（注意这个参数在MS-DOS中是无用的）</p>
</dd>
<dt><code>-k</code>, <code>--keep-going</code></dt>
<dd>
<p>出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
</dd>
<dt><code>-l &lt;load&gt;</code>, <code>--load-average[=&lt;load&gt;]</code>, <code>-max-load[=&lt;load&gt;]</code></dt>
<dd>
<p>指定make运行命令的负载。</p>
</dd>
<dt><code>-n</code>, <code>--just-print</code>, <code>--dry-run</code>, <code>--recon</code></dt>
<dd>
<p>仅输出执行过程中的命令序列，但并不执行。</p>
</dd>
<dt><code>-o &lt;file&gt;</code>, <code>--old-file=&lt;file&gt;</code>, <code>--assume-old=&lt;file&gt;</code></dt>
<dd>
<p>不重新生成的指定的<code>&lt;file&gt;</code>，即使这个目标的依赖文件新于它。</p>
</dd>
<dt><code>-p</code>, <code>--print-data-base</code></dt>
<dd>
<p>输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出    一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用&quot;make -qp&quot;命令。如果你想查 看执行makefile前的预设变量和规则，你可以使用&quot;make --p --f /dev/null&quot;。这个参数输出的    信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的 makefile会是很有 用的，特别是当你的环境变量很复杂的时候。</p>
</dd>
<dt><code>-q</code>, <code>--question</code></dt>
<dd>
<p>不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说    明有错误发生。</p>
</dd>
<dt><code>-r</code>, <code>--no-builtin-rules</code></dt>
<dd>
<p>禁止make使用任何隐含规则。</p>
</dd>
<dt><code>-R</code>, <code>--no-builtin-variabes</code></dt>
<dd>
<p>禁止make使用任何作用于变量上的隐含规则。</p>
</dd>
<dt><code>-s</code>, <code>--silent</code>, <code>--quiet</code></dt>
<dd>
<p>在命令运行时不输出命令的输出。</p>
</dd>
<dt><code>-S</code>, <code>--no-keep-going</code>, <code>--stop</code></dt>
<dd>
<p>取消&quot;-k&quot;选项的作用。因为有些时候，make的选项是从环境变量&quot;MAKEFLAGS&quot;中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的&quot;-k&quot;选项失效。</p>
</dd>
<dt><code>-t</code>, <code>--touch</code></dt>
<dd>
<p>相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
</dd>
<dt><code>-v</code>, <code>--version</code></dt>
<dd>
<p>输出make程序的版本、版权等关于make的信息。</p>
</dd>
<dt><code>-w</code>, <code>--print-directory</code></dt>
<dd>
<p>输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>
</dd>
<dt><code>--no-print-directory</code></dt>
<dd>
<p>禁止&quot;-w&quot;选项。</p>
</dd>
<dt><code>-W &lt;file&gt;</code>, <code>--what-if=&lt;file&gt;</code>, <code>--new-file=&lt;file&gt;</code>, <code>--assume-file=&lt;file&gt;</code></dt>
<dd>
<p>假定目标<code>&lt;file&gt;</code>需要更新，如果和&quot;-n&quot;选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有&quot;-n&quot;那么就像运行UNIX的&quot;touch&quot;命令一样，使得<code>&lt;file&gt;</code>的修改时间为当前时间。</p>
</dd>
<dt><code>--warn-undefined-variables</code></dt>
<dd>
<p>只要make发现有未定义的变量，那么就输出警告信息。</p>
</dd>
</dl>
<h1 id="9-隐含规则"><a class="markdownIt-Anchor" href="#9-隐含规则"></a> 9. 隐含规则</h1>
<p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是 <code>.o</code> 文件，Windows下是 <code>.obj</code> 文件）。本章讲述的就是一些在Makefile中的&quot;隐含的&quot;，早先约定了的，不需要我们再写出来的规则。</p>
<p>&quot;隐含规则&quot;也就是一种惯例，make会按照这种&quot;惯例&quot;心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把 <code>.c</code> 文件编译成 <code>.o</code> 文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的 <code>.o</code> 文件。</p>
<p>&quot;隐含规则&quot;会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量 <code>CFLAGS</code> 可以控制编译时的编译器参数。</p>
<p>我们还可以通过&quot;模式规则&quot;的方式写下自己的隐含规则。用&quot;后缀规则&quot;来定义隐含规则会有许多的限制。使用&quot;模式规则&quot;会显得更智能和清楚，但&quot;后缀规则&quot;可以用来保证我们Makefile的兼容性。我们了解了&quot;隐含规则&quot;，可以让其为我们更好的服务，也会让我们知道一些&quot;约定俗成&quot;了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候&quot;隐含规则&quot;也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<h2 id="91-使用隐含规则"><a class="markdownIt-Anchor" href="#91-使用隐含规则"></a> 9.1 使用隐含规则</h2>
<p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">foo : foo.o bar.o</span><br><span class="line">&gt;  cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>我们可以注意到，这个Makefile中并没有写下如何生成 <code>foo.o</code> 和 <code>bar.o</code> 这两目标的规则和命令。因为make的&quot;隐含规则&quot;功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<p>make会在自己的&quot;隐含规则&quot;库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 <code>.o</code> 的目标的依赖文件置成 <code>.c</code> ，并使用C的 编译命令 <code>cc –c $(CFLAGS)  foo.c</code> 来生成 <code>foo.o</code> 的目标。也就是说，我们完全没有必要 写下下面的两条规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">foo.o : foo.c</span><br><span class="line">&gt;  cc –c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">&gt;  cc –c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>因为，这已经是&quot;约定&quot;好了的事了，make和我们约定好了用C编译器 <code>cc</code> 生成 <code>.o</code> 文件的规则， 这就是隐含规则。</p>
<p>当然，如果我们为 <code>.o</code> 文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的&quot;隐含规则库&quot;中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.p</span><br></pre></td></tr></table></figure>
<p>依赖文件 <code>foo.p</code><br />
（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了 <code>foo.c</code> 文件， 那么我们的隐含规则一样会生效，并会通过 <code>foo.c</code> 调用C的编译器生成 <code>foo.o</code> 文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成<code>foo.o</code> 的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出&quot;依赖规则&quot;，而不写命令。</p>
<h2 id="92-隐含规则一览"><a class="markdownIt-Anchor" href="#92-隐含规则一览"></a> 9.2 隐含规则一览</h2>
<p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数 <code>-r</code> 或 <code>--no-builtin-rules</code> 选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了 <code>-r</code> 参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了&quot;后缀规则&quot;来定义的，所以，只要隐含规则中有&quot;后缀列表&quot;（也就一系统定义在目标 <code>.SUFFIXES</code> 的依赖目标），那么隐含规则就会生效。默认的后缀列表是： .out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。 具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<ol>
<li>
<p>编译C程序的隐含规则。</p>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.c</code> ，并且其生成命令是 <code>$(CC) –c $(CPPFLAGS) $(CFLAGS)</code></p>
</li>
<li>
<p>编译C++程序的隐含规则。</p>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.cc</code> 或是 <code>&lt;n&gt;.C</code> ，并且其生成命令是 <code>$(CXX) –c $(CPPFLAGS) $(CXXFLAGS)</code> 。（建议使用 <code>.cc</code> 作为C++源文件的后缀，而不是 <code>.C</code> ）</p>
</li>
<li>
<p>编译Pascal程序的隐含规则。</p>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.p</code> ，并且其生成命令是 <code>$(PC) –c  $(PFLAGS)</code> 。</p>
</li>
<li>
<p>编译Fortran/Ratfor程序的隐含规则。</p>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.r</code> 或 <code>&lt;n&gt;.F</code> 或 <code>&lt;n&gt;.f</code>，并且其生成命令是:</p>
<ul>
<li><code>.f</code> <code>$(FC) –c  $(FFLAGS)</code></li>
<li><code>.F</code> <code>$(FC) –c  $(FFLAGS) $(CPPFLAGS)</code></li>
<li><code>.f</code> <code>$(FC) –c  $(FFLAGS) $(RFLAGS)</code></li>
</ul>
</li>
<li>
<p>预处理Fortran/Ratfor程序的隐含规则。</p>
<p><code>&lt;n&gt;.f</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.r</code> 或 <code>&lt;n&gt;.F</code> 。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：</p>
<ul>
<li><code>.F</code> <code>$(FC) –F $(CPPFLAGS) $(FFLAGS)</code></li>
<li><code>.r</code> <code>$(FC) –F $(FFLAGS) $(RFLAGS)</code></li>
</ul>
</li>
<li>
<p>编译Modula-2程序的隐含规则。</p>
<p><code>&lt;n&gt;.sym</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.def</code>，并且其生成命令是： <code>$(M2C) $(M2FLAGS) $(DEFFLAGS)</code> 。 <code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为 <code>&lt;n&gt;.mod</code> ， 并且其生成命令是： <code>$(M2C) $(M2FLAGS) $(MODFLAGS)</code> 。</p>
</li>
<li>
<p>汇编和汇编预处理的隐含规则。</p>
<p><code>&lt;n&gt;.o</code> 的目标的依赖目标会自动推导为 <code>&lt;n&gt;.s</code> ，默认使用编译器 <code>as</code>，并且其生成 命令是： <code>$ (AS) $(ASFLAGS)</code> 。 <code>&lt;n&gt;.s</code>的目标的依赖目标会自动推导为 <code>&lt;n&gt;.S</code> ， 默认使用C预编译器 <code>cpp</code> ，并且其生成命令是： <code>$(AS) $(ASFLAGS)</code> 。</p>
</li>
<li>
<p>链接Object文件的隐含规则。</p>
<p><code>&lt;n&gt;</code> 目标依赖于 <code>&lt;n&gt;.o</code>，通过运行C的编译器来运行链接程序生成（一般是 <code>ld</code> ），其生成命令是： <code>$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)</code>。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:</p>
<pre><code>x : y.o z.o
</code></pre>
<p>并且 <code>x.c</code> 、 <code>y.c</code> 和 <code>z.c</code> 都存在时，隐含规则将执行如下命令:</p>
<pre><code>cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o
</code></pre>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
</li>
<li>
<p>Yacc C程序时的隐含规则。</p>
<p><code>&lt;n&gt;.c</code> 的依赖文件被自动推导为 <code>n.y</code>（Yacc生成的文件），其生成命令是： <code>$(YACC) $(YFALGS)</code> 。（&quot;Yacc&quot;是一个语法分析器，关于其细节请查看相关资料）</p>
</li>
<li>
<p>Lex C程序时的隐含规则。</p>
<p><code>&lt;n&gt;.c</code> 的依赖文件被自动推导为 <code>n.l</code> Lex生成的文件），其生成命令是： <code>$(LEX) $(LFALGS)</code> 。（关于&quot;Lex&quot;的细节请查看相关资料）</p>
</li>
<li>
<p>Lex Ratfor程序时的隐含规则。</p>
<p><code>&lt;n&gt;.r</code> 的依赖文件被自动推导为 <code>n.l</code>（Lex生成的文件），其生成命令是： <code>$(LEX) $(LFALGS)</code> 。</p>
</li>
<li>
<p>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</p>
<p><code>&lt;n&gt;.ln</code> （lint生成的文件）的依赖文件被自动推导为 <code>n.c</code>，其生成命令是： <code>$(LINT) $(LINTFALGS) $(CPPFLAGS) -i</code> 。对于 <code>&lt;n&gt;.y</code> 和 <code>&lt;n&gt;.l</code> 也是同样的规则。</p>
</li>
</ol>
<h2 id="93-隐含规则使用的变量"><a class="markdownIt-Anchor" href="#93-隐含规则使用的变量"></a> 9.3 隐含规则使用的变量</h2>
<p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的 <code>-R</code> 或 <code>--no–builtin-variables</code> 参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则------编译C程序的隐含规则的命令是 <code>$(CC) –c $(CFLAGS) $(CPPFLAGS)</code> 。 Make默认的编译命令是 <code>cc</code><br />
，如果你把变量 <code>$(CC)</code> 重定义成 <code>gcc</code> ，把变量 <code>$(CFLAGS)</code> 重定义成 <code>-g</code> ，那么，隐含规则中的命令全部会以 <code>gcc –c -g $(CPPFLAGS)</code> 的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如 <code>CC</code> ；一种是参数相的关，如 <code>CFLAGS</code> 。下面是所有隐含规则中会用到的变量：</p>
<h3 id="931-关于命令的变量"><a class="markdownIt-Anchor" href="#931-关于命令的变量"></a> 9.3.1 关于命令的变量。</h3>
<ul>
<li><code>AR</code> : 函数库打包程序。默认命令是 <code>ar</code></li>
<li><code>AS</code> : 汇编语言编译程序。默认命令是 <code>as</code></li>
<li><code>CC</code> : C语言编译程序。默认命令是 <code>cc</code></li>
<li><code>CXX</code> : C++语言编译程序。默认命令是 <code>g++</code></li>
<li><code>CO</code> : 从 RCS文件中扩展文件程序。默认命令是 <code>co</code></li>
<li><code>CPP</code> : C程序的预处理器（输出是标准输出设备）。默认命令是 <code>$(CC) –E</code></li>
<li><code>FC</code> : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 <code>f77</code></li>
<li><code>GET</code> : 从SCCS文件中扩展文件的程序。默认命令是 <code>get</code></li>
<li><code>LEX</code> : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 <code>lex</code></li>
<li><code>PC</code> : Pascal语言编译程序。默认命令是 <code>pc</code></li>
<li><code>YACC</code> : Yacc文法分析器（针对于C程序）。默认命令是 <code>yacc</code></li>
<li><code>YACCR</code> : Yacc文法分析器（针对于Ratfor程序）。默认命令是 <code>yacc –r</code></li>
<li><code>MAKEINFO</code> : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是<br />
<code>makeinfo</code></li>
<li><code>TEX</code> : 从TeX源文件创建TeX DVI文件的程序。默认命令是 <code>tex</code></li>
<li><code>TEXI2DVI</code> : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是<br />
<code>texi2dvi</code></li>
<li><code>WEAVE</code> : 转换Web到TeX的程序。默认命令是 <code>weave</code></li>
<li><code>CWEAVE</code> : 转换C Web 到 TeX的程序。默认命令是 <code>cweave</code></li>
<li><code>TANGLE</code> : 转换Web到Pascal语言的程序。默认命令是 <code>tangle</code></li>
<li><code>CTANGLE</code> : 转换C Web 到 C。默认命令是 <code>ctangle</code></li>
<li><code>RM</code> : 删除文件命令。默认命令是 <code>rm –f</code></li>
</ul>
<h3 id="932-关于命令参数的变量"><a class="markdownIt-Anchor" href="#932-关于命令参数的变量"></a> 9.3.2 关于命令参数的变量</h3>
<p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<ul>
<li><code>ARFLAGS</code> : 函数库打包程序AR命令的参数。默认值是 <code>rv</code></li>
<li><code>ASFLAGS</code> : 汇编语言编译器参数。（当明显地调用 <code>.s</code> 或 <code>.S</code> 文件时）</li>
<li><code>CFLAGS</code> : C语言编译器参数。</li>
<li><code>CXXFLAGS</code> : C++语言编译器参数。</li>
<li><code>COFLAGS</code> : RCS命令参数。</li>
<li><code>CPPFLAGS</code> : C预处理器参数。（ C 和 Fortran 编译器也会用到）。</li>
<li><code>FFLAGS</code> : Fortran语言编译器参数。</li>
<li><code>GFLAGS</code> : SCCS &quot;get&quot;程序参数。</li>
<li><code>LDFLAGS</code> : 链接器参数。（如： <code>ld</code> ）</li>
<li><code>LFLAGS</code> : Lex文法分析器参数。</li>
<li><code>PFLAGS</code> : Pascal语言编译器参数。</li>
<li><code>RFLAGS</code> : Ratfor 程序的Fortran 编译器参数。</li>
<li><code>YFLAGS</code> : Yacc文法分析器参数。</li>
</ul>
<h2 id="94-隐含规则链"><a class="markdownIt-Anchor" href="#94-隐含规则链"></a> 9.4 隐含规则链</h2>
<p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个 <code>.o</code> 的文件生成，可能会是先被 Yacc的[.y]文件先成 <code>.c</code> ，然后再被C的编译器生成。我们把这一系列的隐含规则叫做&quot;隐含规则链&quot;。</p>
<p>在上面的例子中，如果文件 <code>.c</code> 存在，那么就直接调用C的编译器的隐含规则，如果没有 <code>.c</code> 文件， 但有一个 <code>.y</code> 文件，那么Yacc的隐含规则会被调用，生成 <code>.c</code> 文件，然后，再调用C编译的隐含 规则最终由 <code>.c</code> 生成 <code>.o</code> 文件，达到目标。</p>
<p>我们把这种 <code>.c</code> 的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以 <code>rm -f</code> 删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标 <code>.INTERMEDIATE</code> 来强制声明。（如： <code>.INTERMEDIATE : mid</code> ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标 <code>.SECONDARY</code> 来强制声明 （如： <code>.SECONDARY : sec</code>）。你还可以把你的目标，以模式的方式来指定（如： <code>%.o</code> ）成 伪目标<code>.PRECIOUS</code> 的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在&quot;隐含规则链&quot;中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件 <code>foo.c</code> 生成目标程序 <code>foo</code> ， 按道理，make会编译生成中间文件 <code>foo.o</code> ，然后链接成 <code>foo</code> ，但在实际情况下，这一动作可以 被一条 <code>cc</code> 的命令完成（ <code>cc –o foo foo.c</code> ），于是优化过的规则就不会生成中间文件。</p>
<h2 id="95-定义模式规则"><a class="markdownIt-Anchor" href="#95-定义模式规则"></a> 9.5 定义模式规则</h2>
<p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 <code>%</code> 字符。 <code>%</code> 的意思是表示一个或多个任意字符。在依赖目标中同样可以使用 <code>%</code> ，只是依赖目标中的 <code>%</code> 的取值，取决于其目标。</p>
<p>有一点需要注意的是， <code>%</code> 的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的 <code>%</code> 则发生在运行时。</p>
<h3 id="951-模式规则介绍"><a class="markdownIt-Anchor" href="#951-模式规则介绍"></a> 9.5.1 模式规则介绍</h3>
<p>模式规则中，至少在规则的目标定义中要包含 <code>%</code> ，否则，就是一般的规则。目标中的 <code>%</code> 定义 表示对文件名的匹配， <code>%</code> 表示长度任意的非空字符串。例如： <code>%.c</code> 表示以 <code>.c</code> 结尾的文件名（文件名的长度至少为3），而 <code>s.%.c</code> 则表示以 <code>s.</code> 开头， <code>.c</code> 结尾的文件名 （文件名的长度至少为5）。</p>
<p>如果 <code>%</code> 定义在目标中，那么，依赖中的 <code>%</code> 的值决定了目标中的 <code>%</code> 的值，也就是说， 依赖中的模式的 <code>%</code> 决定了目标中 <code>%</code> 的样子。例如有一个模式规则如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c ; &lt;command ......&gt;;</span><br></pre></td></tr></table></figure>
<p>其含义是，指出了怎么从所有的 <code>.c</code> 文件生成相应的 <code>.o</code> 文件的规则。如果要生成的目标是 <code>a.o b.o</code> ，那么 <code>%c</code> 就是 <code>a.c b.c</code> 。</p>
<p>一旦依赖目标中的 <code>%</code> 模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<h3 id="952-模式规则示例"><a class="markdownIt-Anchor" href="#952-模式规则示例"></a> 9.5.2 模式规则示例</h3>
<p>下面这个例子表示了,把所有的 <code>.c</code> 文件都编译成 <code>.o</code> 文件.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">%.o : %.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>其中， <code>$@</code> 表示所有的目标的挨个值， <code>$&lt;</code> 表示了所有依赖目标的挨个值。这些奇怪的变量我们叫&quot;自动化变量&quot;，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">%.tab.c %.tab.h: %.y</span><br><span class="line">&gt;  bison -d <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>这条规则告诉make把所有的 <code>.y</code> 文件都以 <code>bison -d &lt;n&gt;.y</code> 执行，然后生成 <code>&lt;n&gt;.tab.c</code> 和 <code>&lt;n&gt;.tab.h</code> 文件。（其中， <code>&lt;n&gt;</code> 表示一个任意字符串）。如果我们的执行程序 <code>foo</code> 依赖于文件 <code>parse.tab.o</code> 和 <code>scan.o</code> ，并且文件 <code>scan.o</code> 依赖于文件 <code>parse.tab.h</code> ， 如果 <code>parse.y</code> 文件被更新了，那么根据上述的规则， <code>bison -d parse.y</code> 就会被执行一次， 于是， <code>parse.tab.o</code> 和 <code>scan.o</code> 的依赖文件就齐了。（假设， <code>parse.tab.o</code> 由 <code>parse.tab.c</code> 生成，和 <code>scan.o</code> 由 <code>scan.c</code> 生成，而 <code>foo</code> 由 <code>parse.tab.o</code> 和 <code>scan.o</code> 链接生成，而且 <code>foo</code> 和其 <code>.o</code> 文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>
<h3 id="953-自动化变量"><a class="markdownIt-Anchor" href="#953-自动化变量"></a> 9.5.3 自动化变量</h3>
<p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<ul>
<li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，  <code>$@</code> 就是匹配于 目标中模式定义的集合。</li>
<li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a(bar.o)</code> ， 那么， <code>$%</code> 就是 <code>bar.o</code> ， <code>$@</code> 就是 <code>foo.a</code> 。如果目标不是函数库文件 （Unix下是 <code>.a</code> ，Windows下是 <code>.lib</code>），那么，其值为空。</li>
<li><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code>%</code>）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li>
<li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。</li>
<li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</li>
<li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li>
<li><code>$*</code> : 这个变量表示目标模式中 <code>%</code> 及其之前的部分。如果目标是 <code>dir/a.foo.b</code> ，并且 目标的模式是 <code>a.%.b</code> ，那么， <code>$*</code> 的值就是 <code>dir/foo</code> 。这个变量对于构造有关联的文件名是比较有效。如果目标中没有模式的定义，那么 <code>$*</code> 也就不能被推导出，但是，如果目标文件的 后缀是make所识别的，那么 <code>$*</code>  就是除了后缀的那一部分。例如：如果目标是 <code>foo.c</code> ，因为 <code>.c</code> 是make所能识别的后缀名，所以， <code>$*</code> 的值就是 <code>foo</code> 。这个特性是GNU make的， 很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 <code>$*</code> ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 <code>$*</code> 就是空值。</li>
</ul>
<p>当你希望只对更新过的依赖文件进行操作时， <code>$?</code> 在显式规则中很有用，例如，假设有一个函数库文件 叫 <code>lib</code> ，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">lib : foo.o bar.o lose.o win.o</span><br><span class="line">&gt;  ar r lib <span class="variable">$?</span></span><br></pre></td></tr></table></figure>
<p>在上述所列出来的自动量变量中。四个变量（ <code>$@</code> 、 <code>$&lt;</code> 、 <code>$%</code> 、 <code>$*</code>）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 <code>D</code> 或 <code>F</code> 字样。这是GNU make中老版本的特性， 在新版本中，我们使用函数 <code>dir</code> 或 <code>notdir</code> 就可以做到了。 <code>D</code> 的含义就是Directory， 就是目录， <code>F</code> 的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上 <code>D</code> 或是 <code>F</code> 的含义：</p>
<dl>
<dt><code>$(@D)</code></dt>
<dd>表示 <code>$@</code> 的目录部分（不以斜杠作为结尾），如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@D)</code> 就是 <code>dir</code> ，而如果 <code>$@</code> 中没有包含斜杠的话，其值就是 <code>.</code> （当前目录）。</dd>
<dt><code>$(@F)</code></dt>
<dd>表示 <code>$@</code> 的文件部分，如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@F)</code> 就是    <code>foo.o</code> ， <code>$(@F)</code> 相当于函数 <code>$(notdir $@)</code> 。</dd>
<dt><code>$(*D)</code>, <code>$(*F)</code></dt>
<dd>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， <code>$(*D)</code> 返回 <code>dir</code> ， 而 <code>$(*F)</code> 返回 <code>foo</code></dd>
<dt><code>$(%D)</code>, <code>$(%F)</code></dt>
<dd>分别表示了函数包文件成员的目录部分和文件部分。这对于形同 <code>archive(member)</code> 形式的目标中的 <code>member</code> 中包含了不同的目录很有用。</dd>
<dt><code>$(&lt;D)</code>, <code>$(&lt;F)</code></dt>
<dd>分别表示依赖文件的目录部分和文件部分。</dd>
<dt><code>$(^D)</code>, <code>$(^F)</code></dt>
<dd>分别表示所有依赖文件的目录部分和文件部分。（无相同的）</dd>
<dt><code>$(+D)</code>, <code>$(+F)</code></dt>
<dd>分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</dd>
<dt><code>$(?D)</code>, <code>$(?F)</code></dt>
<dd>分别表示被更新的依赖文件的目录部分和文件部分。</dd>
</dl>
<p>最后想提醒一下的是，对于 <code>$&lt;</code> ，为了避免产生不必要的麻烦，我们最好给 <code>$</code> 后面的那个特定 字符都加上圆括号，比如， <code>$(&lt;)</code> 就要比 <code>$&lt;</code> 要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是&quot;显式规则&quot;和&quot;静态模式规则&quot; （参见前面&quot;书写规则&quot;一章）。其在隐含规则中并没有意义。</p>
<h3 id="954-模式的匹配"><a class="markdownIt-Anchor" href="#954-模式的匹配"></a> 9.5.4 模式的匹配</h3>
<p>一般来说，一个目标的模式有一个有前缀或是后缀的 <code>%</code> ，或是没有前后缀，直接就是一个 <code>%</code> 。 因为 <code>%</code> 代表一个或多个字符，所以在定义好了的模式中，我们把 <code>%</code> 所匹配的内容叫做&quot;茎&quot;，例如 <code>%.c</code> 所匹配的文件&quot;test.c&quot;中&quot;test&quot;就是&quot;茎&quot;。因为在目标和依赖目标中同时有 <code>%</code> 时，依赖 目标的&quot;茎&quot;会传给目标，当做目标中的&quot;茎&quot;。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开， 然后进行匹配，成功后，再把目录加回去。在进行&quot;茎&quot;的传递时，我们需要知道这个步骤。例如有一个模式 <code>e%t</code> ，文件 <code>src/eat</code> 匹配于该模式，于是 <code>src/a</code> 就是其&quot;茎&quot;，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 <code>c%r</code> ，那么，目标就是<br />
<code>src/car</code> 。（&quot;茎&quot;被传递）</p>
<h3 id="955-重载内建隐含规则"><a class="markdownIt-Anchor" href="#955-重载内建隐含规则"></a> 9.5.5 重载内建隐含规则</h3>
<p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">%.o : %.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span> -D<span class="variable">$(date)</span></span><br></pre></td></tr></table></figure>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.s</span><br></pre></td></tr></table></figure>
<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h2 id="96-老式风格的后缀规则"><a class="markdownIt-Anchor" href="#96-老式风格的后缀规则"></a> 9.6 老式风格的&quot;后缀规则&quot;</h2>
<p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：“双后缀&quot;和&quot;单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如 <code>.c.o</code> 相当于 <code>%o : %c</code> 。单后缀规则只定义一个后缀，也就是源文件的后缀。如 <code>.c</code> 相当于 <code>% : %.c</code><br />
。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如： <code>.c</code> 和 <code>.o</code> 都是make所知道。 因而，如果你定义了一个规则是 <code>.c.o</code> 那么其就是双后缀规则，意义就是 <code>.c</code> 是源文件的后缀， <code>.o</code> 是目标文件的后缀。如下示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">.c.o: foo.h</span></span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子，就是说，文件 <code>.c.o</code> 依赖于文件 <code>foo.h</code><br />
，而不是我们想要的这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">%.o: %.c foo.h</span></span><br><span class="line">&gt;  <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>
<p>而要让make知道一些特定的后缀，我们可以使用伪目标 <code>.SUFFIXES</code> 来定义或是删除，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.SUFFIXES: .hack .win</span></span><br></pre></td></tr></table></figure>
<p>把后缀 <code>.hack</code> 和 <code>.win</code> 加入后缀列表中的末尾。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.SUFFIXES:              # 删除默认的后缀</span></span><br><span class="line"><span class="section">.SUFFIXES: .c .o .h   # 定义自己的后缀</span></span><br></pre></td></tr></table></figure>
<p>先清除默认后缀，后定义自己的后缀列表。</p>
<p>make的参数 <code>-r</code> 或 <code>-no-builtin-rules</code> 也会使用得默认的后缀列表为空。而变量 <code>SUFFIXE</code> 被用来定义默认的后缀列表，你可以用 <code>.SUFFIXES</code> 来改变后缀列表，但请不要改变变量 <code>SUFFIXE</code> 的值。</p>
<h2 id="97-隐含规则搜索算法"><a class="markdownIt-Anchor" href="#97-隐含规则搜索算法"></a> 9.7 隐含规则搜索算法</h2>
<p>比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是 <code>archive(member)</code> 的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 <code>member</code> 当作T来搜索。</p>
<ol>
<li>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 <code>src/foo.o</code> ，那么，D就是 <code>src/</code> ，N就是 <code>foo.o</code> ）</li>
<li>创建所有匹配于T或是N的模式规则列表。</li>
<li>如果在模式规则列表中有匹配所有文件的模式，如 <code>%</code> ，那么从列表中移除其它的模式。</li>
<li>移除列表中没有命令的规则。</li>
<li>对于第一个在列表中的模式规则：
<ol>
<li>推导其&quot;茎&quot;S，S应该是T或是N匹配于模式中 <code>%</code> 非空的部分。</li>
<li>计算依赖文件。把依赖文件中的 <code>%</code> 都替换成&quot;茎&quot;S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</li>
<li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫&quot;理当存在&quot;）</li>
<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li>
</ol>
</li>
<li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：
<ol>
<li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li>
<li>计算依赖文件。（同第5步）</li>
<li>测试所有的依赖文件是否存在或是理当存在。</li>
<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li>
<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li>
<li>如果没有隐含规则可以使用，查看 <code>.DEFAULT</code> 规则，如果有，采用，把 <code>.DEFAULT</code> 的命令给T使用。</li>
</ol>
</li>
</ol>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h1 id="10-使用make更新函数库文件"><a class="markdownIt-Anchor" href="#10-使用make更新函数库文件"></a> 10. 使用make更新函数库文件</h1>
<p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令 <code>ar</code> 来完成打包工作。</p>
<h2 id="101-函数库文件的成员"><a class="markdownIt-Anchor" href="#101-函数库文件的成员"></a> 10.1 函数库文件的成员</h2>
<p>一个函数库文件由多个文件组成。你可以用如下格式指定函数库文件及其组成:</p>
<pre><code>archive(member)
</code></pre>
<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了 <code>ar</code> 命令来服务的。如:</p>
<pre><code>foolib(hack.o) : hack.o
    ar cr foolib hack.o
</code></pre>
<p>如果要指定多个member，那就以空格分开，如:</p>
<pre><code>foolib(hack.o kludge.o)
</code></pre>
<p>其等价于:</p>
<pre><code>foolib(hack.o) foolib(kludge.o)
</code></pre>
<p>你还可以使用Shell的文件通配符来定义，如:</p>
<pre><code>foolib(*.o)
</code></pre>
<h2 id="102-函数库成员的隐含规则"><a class="markdownIt-Anchor" href="#102-函数库成员的隐含规则"></a> 10.2 函数库成员的隐含规则</h2>
<p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 <code>a(m)</code> 形式 的，其会把目标变成 <code>(m)</code> 。于是，如果我们的成员是 <code>%.o</code> 的模式定义，并且如果 我们使用 <code>make foo.a(bar.o)</code> 的形式调用Makefile时，隐含规则会去找 <code>bar.o</code> 的 规则，如果没有定义 <code>bar.o</code> 的规则，那么内建隐含规则生效，make会去找 <code>bar.c</code> 文件来生成 <code>bar.o</code> ，如果找得到的话，make执行的命令大致如下:</p>
<pre><code>cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o
</code></pre>
<p>还有一个变量要注意的是 <code>$%</code> ，这是专属函数库文件的自动化变量，有关其说明请参 见&quot;自动化变量&quot;一节。</p>
<h2 id="103-函数库文件的后缀规则"><a class="markdownIt-Anchor" href="#103-函数库文件的后缀规则"></a> 10.3 函数库文件的后缀规则</h2>
<p>你可以使用&quot;后缀规则&quot;和&quot;隐含规则&quot;来生成函数库打包文件，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">.c.a:</span></span><br><span class="line">&gt;  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">&gt;  <span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">&gt;  <span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure>
<p>其等效于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">(%.o) : %.c</span><br><span class="line">&gt;  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">&gt;  <span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">&gt;  <span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure>
<h2 id="104-注意事项"><a class="markdownIt-Anchor" href="#104-注意事项"></a> 10.4 注意事项</h2>
<p>在进行函数库打包文件生成时，请小心使用make的并行机制（ <code>-j</code> 参数）。如果多个 <code>ar</code> 命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。</p>
<p>但就目前而言，你还是应该不要尽量不要使用 <code>-j</code> 参数。</p>
<h1 id="11-后序"><a class="markdownIt-Anchor" href="#11-后序"></a> 11. 后序</h1>
<p>终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的厂商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测&quot;函数&quot;那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）“杀伤力”。</p>
<p>对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、ftp等等，等等，来完成诸如&quot;程序打包&quot;、“程序备份”、“制作程序安装包”、“提交代码”、“使用程序模板”、“合并文件&quot;等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如”@@@N、###N&quot;奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的&quot;@@@N、###N&quot;等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的&quot;扩展C&quot;语言（即在C语言中用&quot;EXEC SQL&quot;的样子执行SQL语句，在用cc/gcc编译之前，需要使用&quot;扩展C&quot;的翻译程序，如cpre，把其翻译成标准C）。如果你在使用make时有一些更为绝妙的方法，请记得告诉我啊。</p>
<p>回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入&quot;!make&quot;时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。</p>
<p>现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间钻研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精炼，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和提纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地等待各位给我指正和建议，以及任何的反馈。</p>
<p>最后，还是利用这个后序，介绍一下自己。我目前从事于所有Unix平台下的软件研发，主要是做分布式计算/网格计算方面的系统产品软件，并且我对于下一代的计算机革命------网格计算非常地感兴趣，对于分布式计算、P2P、Web Service、J2EE技术方向也很感兴趣，同时，对于项目实施、团队管理、项目管理也小有心得，希望同样和我战斗在&quot;技术和管理并重&quot;的阵线上的年轻一代，能够和我多多地交流。我的MSN是：<a href="mailto:haoel@hotmail.com">haoel@hotmail.com</a>（常用），QQ是：753640（不常用）。（注：请勿给我MSN的邮箱发信，由于hotmail的垃圾邮件导致我拒收这个邮箱的所有来信）</p>
<p>我欢迎任何形式的交流，无论是讨论技术还是管理，或是其它海阔天空的东西。除了政治和娱乐新闻我不关心，其它只要积极向上的东西我都欢迎！</p>
<p>最最后，我还想介绍一下make程序的设计开发者。</p>
<p>首当其冲的是：Richard Stallman</p>
<p>开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页：<a href="http://www.stallman.org/">http://www.stallman.org/</a> 。这里只贴上一张他的近照：</p>
<p><img src="https://media.libreplanet.org/mgoblin_media/media_entries/2207/rms-closeup.medium.jpg" alt="Richard Stallman, at LibrePlanet 2019" /></p>
<p>第二位是：Roland McGrath</p>
<p>个人主页是：<a href="http://www.frob.com/%5C~roland/">http://www.frob.com/\~roland/</a> ，下面是他的一些事迹：</p>
<ol>
<li>合作编写了并维护GNU make。</li>
<li>和Thomas Bushnell一同编写了GNU Hurd。</li>
<li>编写并维护着GNU C library。</li>
<li>合作编写并维护着部分的GNU Emacs。</li>
</ol>
<p>在此，向这两位开源项目的斗士致以最真切的敬意。</p>
<p>（全文完）</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>笔记摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_28_寻找字符串_KMP</title>
    <url>/2022/11/10/leetcode-28-%E5%AF%BB%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2-KMP/</url>
    <content><![CDATA[<p>从我学习数据结构以来, 这应该是碰到的第一个比较难的算法了, 学习算法虽然我已经大概了解了, 但是就是使用cpp实现的时候很难实现, 这次算是第一次实现比较难的算法, 最后还是失败了, leetcode上面的样例没有全过, 后来听了老师讲课才大概理解书本上面的代码是什么意思.</p>
<p>先贴一下我最后过了的代码, 实际上也没有多厉害, 最后还是一直没过, 反正就是总是差一点.</p>
<span id="more"></span>
<p><img src="https://pic1.imgdb.cn/item/63478d8c16f2c2beb111fc69.png" alt="img" /></p>
<p>就总是像这种……</p>
<p>我还是直接贴一下我最后过了的代码吧.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> needle_length = needle.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> haystack_length = haystack.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (needle_length &gt; haystack_length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> next[needle_length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先给needle生成next数组 让next[0]=-1真是方便</span></span><br><span class="line">    <span class="comment">//知道第前i个next数组, 求i+1位</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; needle_length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      j = next[i];</span><br><span class="line">      <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) j = next[j];</span><br><span class="line">      next[i + <span class="number">1</span>] = ++j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是重复使用i和j, 其中i指向长串. j指向短串</span></span><br><span class="line">    i = j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; haystack_length &amp;&amp; j &lt; needle_length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">-1</span> || haystack[i] == needle[j]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= needle_length)</span><br><span class="line">      <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.imgdb.cn/item/634ac26716f2c2beb1cc08e1.jpg" alt="img" /></p>
<p>效果是真不戳! (其实leetcode平台确实是多次提交同一个代码会造成不一样的结果)</p>
<p>对于整个题目, 是在haystack字符串里面寻找needle这个字符串, 首先假如说needle还长一些那肯定是没有办法找到的, 所以返回-1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先给needle生成next数组 让next[0]=-1真是方便</span></span><br><span class="line"><span class="comment">//知道第前i个next数组, 求i+1位</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; needle_length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  j = next[i];</span><br><span class="line">  <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) j = next[j];</span><br><span class="line">  next[i + <span class="number">1</span>] = ++j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充说明一下这里next数组的意义. 就是needle的指针失配之后, needle指针应该重新指向的位置. 例如ababc的next数组为: <code>-1, 0, 0, 1, 2</code>, 从值来看, next[i]意思就是从0到i-1这个字符串的最长相等的前后缀的长度. 为什么第四项是1, 因为如果是第四项失配了, 那就是前面是有aba主串和子串一样, 那么子串的指针只需要指到b处就可以了.</p>
<p>首先, 只有匹配失败的时候才会去寻找下一个可能性, 所以循环条件是不匹配, 但是假如j&lt;0了也就是说可能性已经用完了(因为只有next[0]是小于0的), 这个时候也不能循环了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还是重复使用i和j, 其中i指向长串. j指向短串</span></span><br><span class="line">i = j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; haystack_length &amp;&amp; j &lt; needle_length) &#123;</span><br><span class="line">  <span class="keyword">if</span> (j == <span class="number">-1</span> || haystack[i] == needle[j]) &#123;</span><br><span class="line">	i++;</span><br><span class="line">	j++;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">	j = next[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= needle_length)</span><br><span class="line">  <span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//排版有点小问题 不影响阅读</span></span><br></pre></td></tr></table></figure>
<p>不想解说了, 太妙了, 多看几遍.</p>
<p>当然匹配字符串还有很多其他的算法, 比如说BM算法. <s>我不想看了</s></p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_50_快速幂</title>
    <url>/2022/11/10/leetcode-50-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>因为老师上课讲过了这个方法, 所以我一开始是样例过了大半的, 我一开始的代码是这样:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span> / x;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myPow</span>(x, (<span class="type">int</span>)(n / <span class="number">2</span>)) * <span class="built_in">myPow</span>(x, n - (<span class="type">int</span>)(n / <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>说实话我一开始还没看出来这个为什么老师超时. 甚至我看了官解之后还在疑惑.</p>
<p>后来代码改进后:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">quickMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> y * y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> y * y * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span> (N &gt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">quickMul</span>(x, N);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>问题在于, 我现在来想, 最开始的方法虽然用了这个f(n)-&gt;f(n/2)但是复杂度却不是logn, 原因我递归的return语句里面有两个这样的函数…</p>
<p>假如f(1)算一次基本操作, 好不容易写出来了折半, 又有两个, 相当于时间复杂度是O(n).</p>
<p>而后来的解里面很明显, 改进的地方是第一次做的时候返回两个return, 实际上这两个是有关系的, 和奇偶有关系, 很妙.</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/11/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-基本匹配"><a class="markdownIt-Anchor" href="#1-基本匹配"></a> 1. 基本匹配</h2>
<p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。<br />
例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;the&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/dmRygT/1">在线练习</a></p>
<p>正则表达式<code>123</code>匹配字符串<code>123</code>。它逐个字符的与输入的正则表达式做比较。</p>
<p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;The&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/1paXsy/1">在线练习</a></p>
<h2 id="2-元字符"><a class="markdownIt-Anchor" href="#2-元字符"></a> 2. 元字符</h2>
<p>正则表达式主要依赖于元字符。<br />
元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>句号匹配任意单个字符除了换行符。</td>
</tr>
<tr>
<td style="text-align:center">[ ]</td>
<td>字符种类。匹配方括号内的任意字符。</td>
</tr>
<tr>
<td style="text-align:center">[^ ]</td>
<td>否定的字符种类。匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td>匹配&gt;=0个重复的在*号之前的字符。</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td>匹配&gt;=1个重复的+号前的字符。</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td>标记?之前的字符为可选.</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td style="text-align:center">(xyz)</td>
<td>字符集，匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td style="text-align:center">管道符</td>
<td>或运算符，匹配符号前或后的字符.</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>转义字符,用于匹配一些保留的字符.</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td>从开始行开始匹配.</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td>从末端开始匹配.</td>
</tr>
</tbody>
</table>
<h2 id="21-点运算符"><a class="markdownIt-Anchor" href="#21-点运算符"></a> 2.1 点运算符 <code>.</code></h2>
<p><code>.</code>是元字符中最简单的例子。<br />
<code>.</code>匹配任意单个字符，但不匹配换行符。<br />
例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;.ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/xc9GkU/1">在线练习</a></p>
<h2 id="22-字符集"><a class="markdownIt-Anchor" href="#22-字符集"></a> 2.2 字符集</h2>
<p>字符集也叫做字符类。<br />
方括号用来指定一个字符集。<br />
在方括号中使用连字符来指定字符集的范围。<br />
在方括号中的字符集不关心顺序。<br />
例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[Tt]he&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/2ITLQ4/1">在线练习</a></p>
<p>方括号的句号就表示句号。<br />
表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;ar[.]&quot; =&gt; A garage is a good place to park a car.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/wL3xtE/1">在线练习</a></p>
<h3 id="221-否定字符集"><a class="markdownIt-Anchor" href="#221-否定字符集"></a> 2.2.1 否定字符集</h3>
<p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。<br />
例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[^c]ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/nNNlq3/1">在线练习</a></p>
<h2 id="23-重复次数"><a class="markdownIt-Anchor" href="#23-重复次数"></a> 2.3 重复次数</h2>
<p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。<br />
这些元字符在不同的情况下有着不同的意思。</p>
<h3 id="231-号"><a class="markdownIt-Anchor" href="#231-号"></a> 2.3.1 <code>*</code> 号</h3>
<p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。<br />
例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[a-z]*&quot; =&gt; The car parked in the garage #21.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/7m8me5/1">在线练习</a></p>
<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。<br />
<code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;\s*cat\s*&quot; =&gt; The fat cat sat on the concatenation.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/gGrwuz/1">在线练习</a></p>
<h3 id="232-号"><a class="markdownIt-Anchor" href="#232-号"></a> 2.3.2 <code>+</code> 号</h3>
<p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。<br />
例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;c.+t&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/Dzf9Aa/1">在线练习</a></p>
<h3 id="233-号"><a class="markdownIt-Anchor" href="#233-号"></a> 2.3.3 <code>?</code> 号</h3>
<p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。<br />
例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[T]he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/cIg9zm/1">在线练习</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[T]?he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/kPpO2x/1">在线练习</a></p>
<h2 id="24-号"><a class="markdownIt-Anchor" href="#24-号"></a> 2.4 <code>&#123;&#125;</code> 号</h2>
<p>在正则表达式中 <code>&#123;&#125;</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。<br />
例如， 表达式 <code>[0-9]&#123;2,3&#125;</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/juM86s/1">在线练习</a></p>
<p>我们可以省略第二个参数。<br />
例如，<code>[0-9]&#123;2,&#125;</code> 匹配至少两位 0~9 的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/Gdy4w5/1">在线练习</a></p>
<p>如果逗号也省略掉则表示重复固定的次数。<br />
例如，<code>[0-9]&#123;3&#125;</code> 匹配3位数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/Sivu30/1">在线练习</a></p>
<h2 id="25-特征标群"><a class="markdownIt-Anchor" href="#25-特征标群"></a> 2.5 <code>(...)</code> 特征标群</h2>
<p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>&#123;&#125;</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(c|g|p)ar&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/tUxrBG/1">在线练习</a></p>
<h2 id="26-或运算符"><a class="markdownIt-Anchor" href="#26-或运算符"></a> 2.6 <code>|</code> 或运算符</h2>
<p>或运算符就表示或，用作判断条件。</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he|car&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/fBXyX0/1">在线练习</a></p>
<h2 id="27-转码特殊字符"><a class="markdownIt-Anchor" href="#27-转码特殊字符"></a> 2.7 转码特殊字符</h2>
<p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(f|c|m)at\.?&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/DOc5Nu/1">在线练习</a></p>
<h2 id="28-锚点"><a class="markdownIt-Anchor" href="#28-锚点"></a> 2.8 锚点</h2>
<p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p>
<h3 id="281-号"><a class="markdownIt-Anchor" href="#281-号"></a> 2.8.1 <code>^</code> 号</h3>
<p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p>
<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p>
<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/5ljjgB/1">在线练习</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;^(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/jXrKne/1">在线练习</a></p>
<h3 id="282-号"><a class="markdownIt-Anchor" href="#282-号"></a> 2.8.2 <code>$</code> 号</h3>
<p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p>
<p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(at\.)&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/y4Au4D/1">在线练习</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(at\.)$&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/t0AkOd/1">在线练习</a></p>
<h2 id="3-简写字符集"><a class="markdownIt-Anchor" href="#3-简写字符集"></a> 3. 简写字符集</h2>
<p>正则表达式提供一些常用的字符集简写。如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td>匹配数字： <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td>匹配非数字： <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td>匹配所有非空格字符： <code>[^\s]</code></td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td style="text-align:center">\p</td>
<td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td>
</tr>
</tbody>
</table>
<h2 id="4-零宽度断言前后预查"><a class="markdownIt-Anchor" href="#4-零宽度断言前后预查"></a> 4. 零宽度断言（前后预查）</h2>
<p>先行断言和后发断言（合称 lookaround）都属于<strong>非捕获组</strong>（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。</p>
<p>例如，我们希望从下面的输入字符串 字符开头的数字，我们将使用以下的正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>。意思是：获取所有包含 <code>.</code> 并且前面是 <code>$</code> 的数字。</p>
<p>零宽度断言如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">?=</td>
<td>正先行断言-存在</td>
</tr>
<tr>
<td style="text-align:center">?!</td>
<td>负先行断言-排除</td>
</tr>
<tr>
<td style="text-align:center">?&lt;=</td>
<td>正后发断言-存在</td>
</tr>
<tr>
<td style="text-align:center">?&lt;!</td>
<td>负后发断言-排除</td>
</tr>
</tbody>
</table>
<h3 id="41-正先行断言"><a class="markdownIt-Anchor" href="#41-正先行断言"></a> 4.1 <code>?=...</code> 正先行断言</h3>
<p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p>
<p>返回结果只包含满足匹配条件的第一部分表达式。<br />
定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p>
<p>正先行断言的内容写在括号中的等号后面。<br />
例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he(?=\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/IDDARt/1">在线练习</a></p>
<h3 id="42-负先行断言"><a class="markdownIt-Anchor" href="#42-负先行断言"></a> 4.2 <code>?!...</code> 负先行断言</h3>
<p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。<br />
<code>正先行断言</code> 定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he(?!\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/V32Npg/1">在线练习</a></p>
<h3 id="43-正后发断言"><a class="markdownIt-Anchor" href="#43-正后发断言"></a> 4.3 <code>?&lt;= ...</code> 正后发断言</h3>
<p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。<br />
例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(?&lt;=(T|t)he\s)(fat|mat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/avH165/1">在线练习</a></p>
<h3 id="44-负后发断言"><a class="markdownIt-Anchor" href="#44-负后发断言"></a> 4.4 <code>?&lt;!...</code> 负后发断言</h3>
<p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。<br />
例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(?&lt;!(T|t)he\s)(cat)&quot; =&gt; The cat sat on cat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/8Efx5G/1">在线练习</a></p>
<h2 id="5-标志"><a class="markdownIt-Anchor" href="#5-标志"></a> 5. 标志</h2>
<p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。<br />
这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td>忽略大小写。</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td>全局搜索。</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td>
</tr>
</tbody>
</table>
<h3 id="51-忽略大小写-case-insensitive"><a class="markdownIt-Anchor" href="#51-忽略大小写-case-insensitive"></a> 5.1 忽略大小写 (Case Insensitive)</h3>
<p>修饰语 <code>i</code> 用于忽略大小写。<br />
例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;The&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/dpQyf9/1">在线练习</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/The/gi&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/ahfiuh/1">在线练习</a></p>
<h3 id="52-全局搜索-global-search"><a class="markdownIt-Anchor" href="#52-全局搜索-global-search"></a> 5.2 全局搜索 (Global search)</h3>
<p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。<br />
例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/.(at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/jnk6gM/1">在线练习</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/.(at)/g&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/dO1nef/1">在线练习</a></p>
<h3 id="53-多行修饰符-multiline"><a class="markdownIt-Anchor" href="#53-多行修饰符-multiline"></a> 5.3 多行修饰符 (Multiline)</h3>
<p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p>
<p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/.at(.)?$/&quot; =&gt; The fat</span><br><span class="line">                cat sat</span><br><span class="line">                on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/hoGMkP/1">在线练习</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/.at(.)?$/gm&quot; =&gt; The fat</span><br><span class="line">                  cat sat</span><br><span class="line">                  on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/E88WE2/1">在线练习</a></p>
<h3 id="6-贪婪匹配与惰性匹配-greedy-vs-lazy-matching"><a class="markdownIt-Anchor" href="#6-贪婪匹配与惰性匹配-greedy-vs-lazy-matching"></a> 6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3>
<p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/(.*at)/&quot; =&gt; The fat cat sat on the mat. </span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/AyAdgJ/1">在线练习</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/(.*?at)/&quot; =&gt; The fat cat sat on the mat. </span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/AyAdgJ/2">在线练习</a></p>
<h2 id="贡献"><a class="markdownIt-Anchor" href="#贡献"></a> 贡献</h2>
<ul>
<li>报告问题</li>
<li>开放合并请求</li>
<li>传播此文档</li>
<li>直接和我联系 <a href="mailto:ziishaned@gmail.com">ziishaned@gmail.com</a> 或<a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&amp;label=Follow%20%40ziishaned" alt="Twitter URL" /></a></li>
</ul>
<h2 id="许可证"><a class="markdownIt-Anchor" href="#许可证"></a> 许可证</h2>
<p>MIT © <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>笔记摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马笔记</title>
    <url>/2022/11/10/%E9%BB%91%E9%A9%AC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="黑马笔记"><a class="markdownIt-Anchor" href="#黑马笔记"></a> 黑马笔记</h1>
<h2 id="1-模板"><a class="markdownIt-Anchor" href="#1-模板"></a> 1 模板</h2>
<h3 id="11-模板的概念"><a class="markdownIt-Anchor" href="#11-模板的概念"></a> 1.1 模板的概念</h3>
<p>模板就是建立 <strong>通用的模具</strong> ，大大<strong>提高复用性</strong></p>
<span id="more"></span>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="12-函数模板"><a class="markdownIt-Anchor" href="#12-函数模板"></a> 1.2 函数模板</h3>
<ul>
<li>C++另一种编程思想称为 =泛型编程= ，主要利用的技术就是模板</li>
<li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></li>
</ul>
<h4 id="121-函数模板语法"><a class="markdownIt-Anchor" href="#121-函数模板语法"></a> 1.2.1 函数模板语法</h4>
<p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<p>template — 声明创建模板</p>
<p>typename — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T — 通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用模板实现交换</span></span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	<span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h4 id="122-函数模板注意事项"><a class="markdownIt-Anchor" href="#122-函数模板注意事项"></a> 1.2.2 函数模板注意事项</h4>
<p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">	<span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">	<span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="123-函数模板案例"><a class="markdownIt-Anchor" href="#123-函数模板案例"></a> 1.2.3 函数模板案例</h4>
<p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试char数组</span></span><br><span class="line">	<span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试int数组</span></span><br><span class="line">	<span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h4 id="124-普通函数与函数模板的区别"><a class="markdownIt-Anchor" href="#124-普通函数与函数模板的区别"></a> 1.2.4 普通函数与函数模板的区别</h4>
<p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="125-普通函数与函数模板的调用规则"><a class="markdownIt-Anchor" href="#125-普通函数与函数模板的调用规则"></a> 1.2.5 普通函数与函数模板的调用规则</h4>
<p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">	<span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">	myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="126-模板的局限性"><a class="markdownIt-Anchor" href="#126-模板的局限性"></a> 1.2.6 模板的局限性</h4>
<p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	<span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">	<span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="13-类模板"><a class="markdownIt-Anchor" href="#13-类模板"></a> 1.3 类模板</h3>
<h4 id="131-类模板语法"><a class="markdownIt-Anchor" href="#131-类模板语法"></a> 1.3.1 类模板语法</h4>
<p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<p>template — 声明创建模板</p>
<p>typename — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T — 通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">	P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="132-类模板与函数模板区别"><a class="markdownIt-Anchor" href="#132-类模板与函数模板区别"></a> 1.3.2 类模板与函数模板区别</h4>
<p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h4 id="133-类模板中成员函数创建时机"><a class="markdownIt-Anchor" href="#133-类模板中成员函数创建时机"></a> 1.3.3 类模板中成员函数创建时机</h4>
<p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;Person1&gt; m;</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="134-类模板对象做函数参数"><a class="markdownIt-Anchor" href="#134-类模板对象做函数参数"></a> 1.3.4 类模板对象做函数参数</h4>
<p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型 — 直接显示对象的数据类型</li>
<li>参数模板化 — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化 — 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h4 id="135-类模板与继承"><a class="markdownIt-Anchor" href="#135-类模板与继承"></a> 1.3.5 类模板与继承</h4>
<p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="136-类模板成员函数类外实现"><a class="markdownIt-Anchor" href="#136-类模板成员函数类外实现"></a> 1.3.6 类模板成员函数类外实现</h4>
<p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="137-类模板分文件编写"><a class="markdownIt-Anchor" href="#137-类模板分文件编写"></a> 1.3.7 类模板分文件编写</h4>
<p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="138-类模板与友元"><a class="markdownIt-Anchor" href="#138-类模板与友元"></a> 1.3.8 类模板与友元</h4>
<p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="139-类模板案例"><a class="markdownIt-Anchor" href="#139-类模板案例"></a> 1.3.9 类模板案例</h4>
<p>案例描述: 实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p><strong>示例：</strong></p>
<p>myArray.hpp中代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line">			<span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组容量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组大小</span></span><br><span class="line">	<span class="function"><span class="type">int</span>	<span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">MyArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line">	<span class="type">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line">	<span class="type">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类模板案例—数组类封装.cpp中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		array1.<span class="built_in">Push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">	array2.<span class="built_in">Pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125; </span><br><span class="line">		<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建数组</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入数据</span></span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>能够利用所学知识点实现通用的数组</p>
<h2 id="2-stl初识"><a class="markdownIt-Anchor" href="#2-stl初识"></a> 2 STL初识</h2>
<h3 id="21-stl的诞生"><a class="markdownIt-Anchor" href="#21-stl的诞生"></a> 2.1 STL的诞生</h3>
<ul>
<li>长久以来，软件界一直希望建立一种可重复利用的东西</li>
<li>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li>
<li>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</li>
<li>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></li>
</ul>
<h3 id="22-stl基本概念"><a class="markdownIt-Anchor" href="#22-stl基本概念"></a> 2.2 STL基本概念</h3>
<ul>
<li>STL(Standard Template Library, <strong>标准模板库</strong> )</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="23-stl六大组件"><a class="markdownIt-Anchor" href="#23-stl六大组件"></a> 2.3 STL六大组件</h3>
<p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="24-stl中容器-算法-迭代器"><a class="markdownIt-Anchor" href="#24-stl中容器-算法-迭代器"></a> 2.4 STL中容器、算法、迭代器</h3>
<p>**容器：**置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p><strong>序列式容器</strong> :强调值的排序，序列式容器中的每个元素均有固定的位置。<br />
<strong>关联式容器</strong> :二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p>**算法：**问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和 <strong>非质变算法</strong> 。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p>**迭代器：**容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody>
</table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h3 id="25-容器算法迭代器初识"><a class="markdownIt-Anchor" href="#25-容器算法迭代器初识"></a> 2.5 容器算法迭代器初识</h3>
<p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="251-vector存放内置数据类型"><a class="markdownIt-Anchor" href="#251-vector存放内置数据类型"></a> 2.5.1 vector存放内置数据类型</h4>
<p>容器： <code>vector</code></p>
<p>算法： <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器中放数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">	<span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line">	<span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种遍历方式：</span></span><br><span class="line">	<span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">		pBegin++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种遍历方式：</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种遍历方式：</span></span><br><span class="line">	<span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="252-vector存放自定义数据类型"><a class="markdownIt-Anchor" href="#252-vector存放自定义数据类型"></a> 2.5.2 Vector存放自定义数据类型</h4>
<p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		mName = name;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		Person * p = (*it);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="253-vector容器嵌套容器"><a class="markdownIt-Anchor" href="#253-vector容器嵌套容器"></a> 2.5.3 Vector容器嵌套容器</h4>
<p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">		v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">		v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-stl-常用容器"><a class="markdownIt-Anchor" href="#3-stl-常用容器"></a> 3 STL- 常用容器</h2>
<h3 id="31-string容器"><a class="markdownIt-Anchor" href="#31-string容器"></a> 3.1 string容器</h3>
<h4 id="311-string基本概念"><a class="markdownIt-Anchor" href="#311-string基本概念"></a> 3.1.1 string基本概念</h4>
<p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="312-string构造函数"><a class="markdownIt-Anchor" href="#312-string构造函数"></a> 3.1.2 string构造函数</h4>
<p>构造函数原型：</p>
<ul>
<li><code>string();</code> //创建一个空的字符串 例如: string str;<br />
<code>string(const char* s);</code> //使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code> //使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code> //使用n个字符c初始化</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="313-string赋值操作"><a class="markdownIt-Anchor" href="#313-string赋值操作"></a> 3.1.3 string赋值操作</h4>
<p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code> //char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code> //把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code> //字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code> //把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code> //把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code> //把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code> //用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3;</span><br><span class="line">	str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str4;</span><br><span class="line">	str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str5;</span><br><span class="line">	str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	string str6;</span><br><span class="line">	str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str7;</span><br><span class="line">	str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>string的赋值方式很多，<code>operator=</code> 这种方式是比较实用的</p>
<h4 id="314-string字符串拼接"><a class="markdownIt-Anchor" href="#314-string字符串拼接"></a> 3.1.4 string字符串拼接</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code> //重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code> //重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code> //重载+=操作符</li>
<li><code>string&amp; append(const char *s);</code> //把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code> //把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code> //同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += str2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//str3.append(str2);</span></span><br><span class="line">	str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="315-string查找和替换"><a class="markdownIt-Anchor" href="#315-string查找和替换"></a> 3.1.5 string查找和替换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code> //查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const;</code> //查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const;</code> //从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const;</code> //查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code> //查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code> //查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code> //从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;</code> //查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str);</code> //替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s);</code> //替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">	str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="316-string字符串比较"><a class="markdownIt-Anchor" href="#316-string字符串比较"></a> 3.1.6 string字符串比较</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回 0</p>
<p>&gt;返回 1</p>
<p>&lt; 返回 -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const;</code> //与字符串s比较</li>
<li><code>int compare(const char *s) const;</code> //与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="317-string字符存取"><a class="markdownIt-Anchor" href="#317-string字符存取"></a> 3.1.7 string字符存取</h4>
<p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n);</code> //通过[]方式取字符</li>
<li><code>char&amp; at(int n);</code> //通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符修改</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="318-string插入和删除"><a class="markdownIt-Anchor" href="#318-string插入和删除"></a> 3.1.8 string插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);</code> //插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str);</code> //插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code> //在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code> //删除从Pos开始的n个字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**插入和删除的起始下标都是从0开始</p>
<h4 id="319-string子串"><a class="markdownIt-Anchor" href="#319-string子串"></a> 3.1.9 string子串</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code> //返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">	string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h3 id="32-vector容器"><a class="markdownIt-Anchor" href="#32-vector容器"></a> 3.2 vector容器</h3>
<h4 id="321-vector基本概念"><a class="markdownIt-Anchor" href="#321-vector基本概念"></a> 3.2.1 vector基本概念</h4>
<p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和 <strong>数组非常相似</strong> ，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-p7chZeA2-1599302221765)(assets/clip_image002.jpg)]</p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="322-vector构造函数"><a class="markdownIt-Anchor" href="#322-vector构造函数"></a> 3.2.2 vector构造函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v;</code> //采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());</code> //将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code> //构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code> //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="323-vector赋值操作"><a class="markdownIt-Anchor" href="#323-vector赋值操作"></a> 3.2.3 vector赋值操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li>
<li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">	v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">	v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h4 id="324-vector容量和大小"><a class="markdownIt-Anchor" href="#324-vector容量和大小"></a> 3.2.4 vector容量和大小</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>empty();</code> //判断容器是否为空</li>
<li><code>capacity();</code> //容器的容量</li>
<li><code>size();</code> //返回容器中元素的个数</li>
<li><code>resize(int num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。<br />
//如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li><code>resize(int num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<br />
//如果容器变短，则末尾超出容器长度的元素被删除</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>判断是否为空 — empty</li>
<li>返回元素个数 — size</li>
<li>返回容器容量 — capacity</li>
<li>重新指定大小 — resize</li>
</ul>
<h4 id="325-vector插入和删除"><a class="markdownIt-Anchor" href="#325-vector插入和删除"></a> 3.2.5 vector插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code> //尾部插入元素ele</li>
<li><code>pop_back();</code> //删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code> //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code> //删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear();</code> //删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	v1.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	v1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>尾插 — push_back</li>
<li>尾删 — pop_back</li>
<li>插入 — insert (位置迭代器)</li>
<li>删除 — erase （位置迭代器）</li>
<li>清空 — clear</li>
</ul>
<h4 id="326-vector数据存取"><a class="markdownIt-Anchor" href="#326-vector数据存取"></a> 3.2.6 vector数据存取</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx);</code> //返回索引idx所指的数据</li>
<li><code>operator[];</code> //返回索引idx所指的数据</li>
<li><code>front();</code> //返回容器中第一个数据元素</li>
<li><code>back();</code> //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="327-vector互换容器"><a class="markdownIt-Anchor" href="#327-vector互换容器"></a> 3.2.7 vector互换容器</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code> // 将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//互换容器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="328-vector预留空间"><a class="markdownIt-Anchor" href="#328-vector预留空间"></a> 3.2.8 vector预留空间</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预留空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="33-deque容器"><a class="markdownIt-Anchor" href="#33-deque容器"></a> 3.3 deque容器</h3>
<h4 id="331-deque容器基本概念"><a class="markdownIt-Anchor" href="#331-deque容器基本概念"></a> 3.3.1 deque容器基本概念</h4>
<p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p>deque内部工作原理:</p>
<p>deque内部有个 <strong>中控器</strong> ，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VTzWcXKx-1599302221768)(assets/clip_image002-1547547896341.jpg)]</p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="332-deque构造函数"><a class="markdownIt-Anchor" href="#332-deque构造函数"></a> 3.3.2 deque构造函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt;</code> deqT; //默认构造形式</li>
<li><code>deque(beg, end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code> //构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code> //拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4 = d3;</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="333-deque赋值操作"><a class="markdownIt-Anchor" href="#333-deque赋值操作"></a> 3.3.3 deque赋值操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&amp; operator=(const deque &amp;deq);</code> //重载等号操作符</li>
<li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d2 = d1;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d3;</span><br><span class="line">	d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4;</span><br><span class="line">	d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="334-deque大小操作"><a class="markdownIt-Anchor" href="#334-deque大小操作"></a> 3.3.4 deque大小操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque.empty();</code> //判断容器是否为空</li>
<li><code>deque.size();</code> //返回容器中元素的个数</li>
<li><code>deque.resize(num);</code> //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。<br />
//如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li><code>deque.resize(num, elem);</code> //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。<br />
//如果容器变短，则末尾超出容器长度的元素被删除。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断容器是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//统计大小</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空 — empty</li>
<li>返回元素个数 — size</li>
<li>重新指定个数 — resize</li>
</ul>
<h4 id="335-deque-插入和删除"><a class="markdownIt-Anchor" href="#335-deque-插入和删除"></a> 3.3.5 deque 插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code> //在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code> //在容器头部插入一个数据</li>
<li><code>pop_back();</code> //删除容器最后一个数据</li>
<li><code>pop_front();</code> //删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li><code>insert(pos,elem);</code> //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li>
<li><code>insert(pos,n,elem);</code> //在pos位置插入n个elem数据，无返回值。</li>
<li><code>insert(pos,beg,end);</code> //在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li><code>clear();</code> //清空容器的所有数据</li>
<li><code>erase(beg,end);</code> //删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li><code>erase(pos);</code> //删除pos位置的数据，返回下一个数据的位置。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	d.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	d.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	d.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插 — push_back</li>
<li>尾删 — pop_back</li>
<li>头插 — push_front</li>
<li>头删 — pop_front</li>
</ul>
<h4 id="336-deque-数据存取"><a class="markdownIt-Anchor" href="#336-deque-数据存取"></a> 3.3.6 deque 数据存取</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx);</code> //返回索引idx所指的数据</li>
<li><code>operator[];</code> //返回索引idx所指的数据</li>
<li><code>front();</code> //返回容器中第一个数据元素</li>
<li><code>back();</code> //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="337-deque-排序"><a class="markdownIt-Anchor" href="#337-deque-排序"></a> 3.3.7 deque 排序</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code> //对beg和end区间内元素进行排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>
<h3 id="34-案例-评委打分"><a class="markdownIt-Anchor" href="#34-案例-评委打分"></a> 3.4 案例-评委打分</h3>
<h4 id="341-案例描述"><a class="markdownIt-Anchor" href="#341-案例描述"></a> 3.4.1 案例描述</h4>
<p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<h4 id="342-实现步骤"><a class="markdownIt-Anchor" href="#342-实现步骤"></a> 3.4.2 实现步骤</h4>
<ol>
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> score)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createPerson</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">		name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line">		deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//去除最高和最低分</span></span><br><span class="line">		d.<span class="built_in">pop_back</span>();</span><br><span class="line">		d.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取平均分</span></span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator dit = d.<span class="built_in">begin</span>(); dit != d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> avg = sum / d.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">		it-&gt;m_Score = avg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//随机数种子</span></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建5名选手</span></span><br><span class="line">	vector&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">	<span class="built_in">createPerson</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、给5名选手打分</span></span><br><span class="line">	<span class="built_in">setScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示最后得分</span></span><br><span class="line">	<span class="built_in">showScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>
<h3 id="35-stack容器"><a class="markdownIt-Anchor" href="#35-stack容器"></a> 3.5 stack容器</h3>
<h4 id="351-stack-基本概念"><a class="markdownIt-Anchor" href="#351-stack-基本概念"></a> 3.5.1 stack 基本概念</h4>
<p><strong>概念：<strong>stack是一种</strong>先进后出</strong> (First In Last Out,FILO)的数据结构，它只有一个出口</p>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<p>栈中进入数据称为 — <strong>入栈</strong> <code>push</code></p>
<p>栈中弹出数据称为 — <strong>出栈</strong> <code>pop</code></p>
<h4 id="352-stack-常用接口"><a class="markdownIt-Anchor" href="#352-stack-常用接口"></a> 3.5.2 stack 常用接口</h4>
<p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code> //stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code> //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code> //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code> //向栈顶添加元素</li>
<li><code>pop();</code> //从栈顶移除第一个元素</li>
<li><code>top();</code> //返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code> //判断堆栈是否为空</li>
<li><code>size();</code> //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>入栈 — push</li>
<li>出栈 — pop</li>
<li>返回栈顶 — top</li>
<li>判断栈是否为空 — empty</li>
<li>返回栈大小 — size</li>
</ul>
<h3 id="36-queue-容器"><a class="markdownIt-Anchor" href="#36-queue-容器"></a> 3.6 queue 容器</h3>
<h4 id="361-queue-基本概念"><a class="markdownIt-Anchor" href="#361-queue-基本概念"></a> 3.6.1 queue 基本概念</h4>
<p><strong>概念：<strong>Queue是一种</strong>先进先出</strong> (First In First Out,FIFO)的数据结构，它有两个出口</p>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 — <strong>入队</strong> <code>push</code></p>
<p>队列中出数据称为 — <strong>出队</strong> <code>pop</code></p>
<h4 id="362-queue-常用接口"><a class="markdownIt-Anchor" href="#362-queue-常用接口"></a> 3.6.2 queue 常用接口</h4>
<p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code> //queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code> //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code> //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code> //往队尾添加元素</li>
<li><code>pop();</code> //从队头移除第一个元素</li>
<li><code>back();</code> //返回最后一个元素</li>
<li><code>front();</code> //返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code> //判断堆栈是否为空</li>
<li><code>size();</code> //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建队列</span></span><br><span class="line">	queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">	q.<span class="built_in">push</span>(p1);</span><br><span class="line">	q.<span class="built_in">push</span>(p2);</span><br><span class="line">	q.<span class="built_in">push</span>(p3);</span><br><span class="line">	q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出队头元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">      </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">      </span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出队头元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>入队 — push</li>
<li>出队 — pop</li>
<li>返回队头元素 — front</li>
<li>返回队尾元素 — back</li>
<li>判断队是否为空 — empty</li>
<li>返回队列大小 — size</li>
</ul>
<h3 id="37-list容器"><a class="markdownIt-Anchor" href="#37-list容器"></a> 3.7 list容器</h3>
<h4 id="371-list基本概念"><a class="markdownIt-Anchor" href="#371-list基本概念"></a> 3.7.1 list基本概念</h4>
<p>**功能：**将数据进行链式存储</p>
<p><strong>链表</strong> （list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的 <strong>数据域</strong> ，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表</p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结：STL中 <strong>List和vector是两个最常被使用的容器</strong> ，各有优缺点</p>
<h4 id="372-list构造函数"><a class="markdownIt-Anchor" href="#372-list构造函数"></a> 3.7.2 list构造函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code> //list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code> //构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code> //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="373-list-赋值和交换"><a class="markdownIt-Anchor" href="#373-list-赋值和交换"></a> 3.7.3 list 赋值和交换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code> //重载等号操作符</li>
<li><code>swap(lst);</code> //将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L2 = L1;</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L3;</span><br><span class="line">	L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L4;</span><br><span class="line">	L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：list赋值和交换操作能够灵活运用即可</p>
<h4 id="374-list-大小操作"><a class="markdownIt-Anchor" href="#374-list-大小操作"></a> 3.7.4 list 大小操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>size();</code> //返回容器中元素的个数</p>
</li>
<li>
<p><code>empty();</code> //判断容器是否为空</p>
</li>
<li>
<p><code>resize(num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。<br />
//如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li>
<p><code>resize(num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>判断是否为空 — empty</li>
<li>返回元素个数 — size</li>
<li>重新指定个数 — resize</li>
</ul>
<h4 id="375-list-插入和删除"><a class="markdownIt-Anchor" href="#375-list-插入和删除"></a> 3.7.5 list 插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>push_back(elem);//在容器尾部加入一个元素</li>
<li>pop_back();//删除容器中最后一个元素</li>
<li>push_front(elem);//在容器开头插入一个元素</li>
<li>pop_front();//从容器开头移除第一个元素</li>
<li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();//移除容器的所有数据</li>
<li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);//删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	L.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">erase</span>(++it);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">	L.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>尾插 — push_back</li>
<li>尾删 — pop_back</li>
<li>头插 — push_front</li>
<li>头删 — pop_front</li>
<li>插入 — insert</li>
<li>删除 — erase</li>
<li>移除 — remove</li>
<li>清空 — clear</li>
</ul>
<h4 id="376-list-数据存取"><a class="markdownIt-Anchor" href="#376-list-数据存取"></a> 3.7.6 list 数据存取</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code> //返回第一个元素。</li>
<li><code>back();</code> //返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素 — front</li>
<li>返回最后一个元素 — back</li>
</ul>
<h4 id="377-list-反转和排序"><a class="markdownIt-Anchor" href="#377-list-反转和排序"></a> 3.7.7 list 反转和排序</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code> //反转链表</li>
<li><code>sort();</code> //链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转容器的元素</span></span><br><span class="line">	L.<span class="built_in">reverse</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>反转 — reverse</li>
<li>排序 — sort （成员函数）</li>
</ul>
<h4 id="378-排序案例"><a class="markdownIt-Anchor" href="#378-排序案例"></a> 3.7.8 排序案例</h4>
<p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age , <span class="type">int</span> height) &#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">		m_Height = height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">		<span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li>
<li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li>
</ul>
<h3 id="38-set-multiset-容器"><a class="markdownIt-Anchor" href="#38-set-multiset-容器"></a> 3.8 set/ multiset 容器</h3>
<h4 id="381-set基本概念"><a class="markdownIt-Anchor" href="#381-set基本概念"></a> 3.8.1 set基本概念</h4>
<p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>
<p>set/multiset属于 <strong>关联式容器</strong> ，底层结构是用<strong>二叉树</strong>实现。</p>
<p><strong>set和multiset区别</strong> ：</p>
</li>
<li>
<p>set不允许容器中有重复的元素</p>
</li>
<li>
<p>multiset允许容器中有重复的元素</p>
</li>
</ul>
<h4 id="382-set构造和赋值"><a class="markdownIt-Anchor" href="#382-set构造和赋值"></a> 3.8.2 set构造和赋值</h4>
<p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code> //默认构造函数：</li>
<li><code>set(const set &amp;st);</code> //拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code> //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h4 id="383-set大小和交换"><a class="markdownIt-Anchor" href="#383-set大小和交换"></a> 3.8.3 set大小和交换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code> //返回容器中元素的数目</li>
<li><code>empty();</code> //判断容器是否为空</li>
<li><code>swap(st);</code> //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>统计大小 — size</li>
<li>判断是否为空 — empty</li>
<li>交换容器 — swap</li>
</ul>
<h4 id="384-set插入和删除"><a class="markdownIt-Anchor" href="#384-set插入和删除"></a> 3.8.4 set插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code> //在容器中插入元素。</li>
<li><code>clear();</code> //清除所有元素</li>
<li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code> //删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">	s1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>插入 — insert</li>
<li>删除 — erase</li>
<li>清空 — clear</li>
</ul>
<h4 id="385-set查找和统计"><a class="markdownIt-Anchor" href="#385-set查找和统计"></a> 3.8.5 set查找和统计</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code> //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>查找 — find （返回的是迭代器）</li>
<li>统计 — count （对于set，结果为0或者1）</li>
</ul>
<h4 id="386-set和multiset区别"><a class="markdownIt-Anchor" href="#386-set和multiset区别"></a> 3.8.6 set和multiset区别</h4>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握set和multiset的区别</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//multiset</span></span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h4 id="387-pair对组创建"><a class="markdownIt-Anchor" href="#387-pair对组创建"></a> 3.8.7 pair对组创建</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>两种方式都可以创建对组，记住一种即可</p>
<h4 id="388-set容器排序"><a class="markdownIt-Anchor" href="#388-set容器排序"></a> 3.8.8 set容器排序</h4>
<p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong> set存放内置数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定排序规则</span></span><br><span class="line">	set&lt;<span class="type">int</span>,MyCompare&gt; s2;</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">		<span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">insert</span>(p1);</span><br><span class="line">	s.<span class="built_in">insert</span>(p2);</span><br><span class="line">	s.<span class="built_in">insert</span>(p3);</span><br><span class="line">	s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="39-map-multimap容器"><a class="markdownIt-Anchor" href="#39-map-multimap容器"></a> 3.9 map/ multimap容器</h3>
<h4 id="391-map基本概念"><a class="markdownIt-Anchor" href="#391-map基本概念"></a> 3.9.1 map基本概念</h4>
<p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map/multimap属于 <strong>关联式容器</strong> ，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap <strong>区别</strong> ：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="392-map构造和赋值"><a class="markdownIt-Anchor" href="#392-map构造和赋值"></a> 3.9.2 map构造和赋值</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code> //map默认构造函数:</li>
<li><code>map(const map &amp;mp);</code> //拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code> //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m3;</span><br><span class="line">	m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="393-map大小和交换"><a class="markdownIt-Anchor" href="#393-map大小和交换"></a> 3.9.3 map大小和交换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code> //返回容器中元素的数目</li>
<li><code>empty();</code> //判断容器是否为空</li>
<li><code>swap(st);</code> //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m2;</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m.<span class="built_in">swap</span>(m2);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>统计大小 — size</li>
<li>判断是否为空 — empty</li>
<li>交换容器 — swap</li>
</ul>
<h4 id="394-map插入和删除"><a class="markdownIt-Anchor" href="#394-map插入和删除"></a> 3.9.4 map插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code> //在容器中插入元素。</li>
<li><code>clear();</code> //清除所有元素</li>
<li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code> //删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="comment">//第一种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//第二种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//第三种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">//第四种插入方式</span></span><br><span class="line">	m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
<li>插入 — insert</li>
<li>删除 — erase</li>
<li>清空 — clear</li>
</ul>
<h4 id="395-map查找和统计"><a class="markdownIt-Anchor" href="#395-map查找和统计"></a> 3.9.5 map查找和统计</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code> //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>查找 — find （返回的是迭代器）</li>
<li>统计 — count （对于map，结果为0或者1）</li>
</ul>
<h4 id="396-map容器排序"><a class="markdownIt-Anchor" href="#396-map容器排序"></a> 3.9.6 map容器排序</h4>
<p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//默认从小到大排序</span></span><br><span class="line">	<span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<h3 id="310-案例-员工分组"><a class="markdownIt-Anchor" href="#310-案例-员工分组"></a> 3.10 案例-员工分组</h3>
<h4 id="3101-案例描述"><a class="markdownIt-Anchor" href="#3101-案例描述"></a> 3.10.1 案例描述</h4>
<ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入 key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<h4 id="3102-实现步骤"><a class="markdownIt-Anchor" href="#3102-实现步骤"></a> 3.10.2 实现步骤</h4>
<ol>
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息</li>
</ol>
<p><strong>案例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Worker worker;</span><br><span class="line">		worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">		worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line">		<span class="comment">//将员工放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//产生随机部门编号</span></span><br><span class="line">		<span class="type">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将员工插入到分组中</span></span><br><span class="line">		<span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">		m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="type">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line">	<span class="type">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">	count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">	count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建员工</span></span><br><span class="line">	vector&lt;Worker&gt;vWorker;</span><br><span class="line">	<span class="built_in">createWorker</span>(vWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、员工分组</span></span><br><span class="line">	multimap&lt;<span class="type">int</span>, Worker&gt;mWorker;</span><br><span class="line">	<span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、分组显示员工</span></span><br><span class="line">	<span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line"></span><br><span class="line">	测试</span><br><span class="line">	<span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h2 id="4-stl-函数对象"><a class="markdownIt-Anchor" href="#4-stl-函数对象"></a> 4 STL- 函数对象</h2>
<h3 id="41-函数对象"><a class="markdownIt-Anchor" href="#41-函数对象"></a> 4.1 函数对象</h3>
<h4 id="411-函数对象概念"><a class="markdownIt-Anchor" href="#411-函数对象概念"></a> 4.1.1 函数对象概念</h4>
<p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个 <strong>类</strong> ，不是一个函数</p>
<h4 id="412-函数对象使用"><a class="markdownIt-Anchor" href="#412-函数对象使用"></a> 4.1.2 函数对象使用</h4>
<p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">		count++; <span class="comment">//统计使用次数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="42-谓词"><a class="markdownIt-Anchor" href="#42-谓词"></a> 4.2 谓词</h3>
<h4 id="421-谓词概念"><a class="markdownIt-Anchor" href="#421-谓词概念"></a> 4.2.1 谓词概念</h4>
<p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="422-一元谓词"><a class="markdownIt-Anchor" href="#422-一元谓词"></a> 4.2.2 一元谓词</h4>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="423-二元谓词"><a class="markdownIt-Anchor" href="#423-二元谓词"></a> 4.2.3 二元谓词</h4>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：参数只有两个的谓词，称为二元谓词</p>
<h3 id="43-内建函数对象"><a class="markdownIt-Anchor" href="#43-内建函数对象"></a> 4.3 内建函数对象</h3>
<h4 id="431-内建函数对象意义"><a class="markdownIt-Anchor" href="#431-内建函数对象意义"></a> 4.3.1 内建函数对象意义</h4>
<p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h4 id="432-算术仿函数"><a class="markdownIt-Anchor" href="#432-算术仿函数"></a> 4.3.2 算术仿函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code> //加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code> //减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code> //乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code> //除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code> //取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code> //取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h4 id="433-关系仿函数"><a class="markdownIt-Anchor" href="#433-关系仿函数"></a> 4.3.3 关系仿函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code> //等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code> //不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code> //大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code> //大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code> //小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code> //小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己实现仿函数</span></span><br><span class="line">	<span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">	<span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="434-逻辑仿函数"><a class="markdownIt-Anchor" href="#434-逻辑仿函数"></a> 4.3.4 逻辑仿函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code> //逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code> //逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code> //逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h2 id="5-stl-常用算法"><a class="markdownIt-Anchor" href="#5-stl-常用算法"></a> 5 STL- 常用算法</h2>
<p><strong>概述</strong> :</p>
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li>
<li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h3 id="51-常用遍历算法"><a class="markdownIt-Anchor" href="#51-常用遍历算法"></a> 5.1 常用遍历算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code> //遍历容器</li>
<li><code>transform</code> //搬运容器到另一个容器中</li>
</ul>
<h4 id="511-for_each"><a class="markdownIt-Anchor" href="#511-for_each"></a> 5.1.1 for_each</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>for_each(iterator beg, iterator end, _func);</code><br />
// 遍历算法 遍历容器元素<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// _func 函数或者函数对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历算法</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h4 id="512-transform"><a class="markdownIt-Anchor" href="#512-transform"></a> 5.1.2 transform</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li>
</ul>
<p>//beg1 源容器开始迭代器</p>
<p>//end1 源容器结束迭代器</p>
<p>//beg2 目标容器开始迭代器</p>
<p>//_func 函数或者函数对象</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h3 id="52-常用查找算法"><a class="markdownIt-Anchor" href="#52-常用查找算法"></a> 5.2 常用查找算法</h3>
<p>学习目标：</p>
<ul>
<li>掌握常用的查找算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code> //查找元素</li>
<li><code>find_if</code> //按条件查找元素</li>
<li><code>adjacent_find</code> //查找相邻重复元素</li>
<li><code>binary_search</code> //二分查找法</li>
<li><code>count</code> //统计元素个数</li>
<li><code>count_if</code> //按条件统计元素个数</li>
</ul>
<h4 id="521-find"><a class="markdownIt-Anchor" href="#521-find"></a> 5.2.1 find</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(iterator beg, iterator end, value);</code><br />
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// value 查找的元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载==</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h4 id="522-find_if"><a class="markdownIt-Anchor" href="#522-find_if"></a> 5.2.2 find_if</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find_if(iterator beg, iterator end, _Pred);</code><br />
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// _Pred 函数或者谓词（返回bool类型的仿函数）</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="523-adjacent_find"><a class="markdownIt-Anchor" href="#523-adjacent_find"></a> 5.2.3 adjacent_find</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>adjacent_find(iterator beg, iterator end);</code><br />
// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器<br />
// beg 开始迭代器<br />
// end 结束迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找相邻重复元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="524-binary_search"><a class="markdownIt-Anchor" href="#524-binary_search"></a> 5.2.4 binary_search</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>bool binary_search(iterator beg, iterator end, value);</code><br />
// 查找指定的元素，查到 返回true 否则false<br />
// 注意: 在<strong>无序序列中不可用</strong><br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// value 查找的元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//二分查找</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="525-count"><a class="markdownIt-Anchor" href="#525-count"></a> 5.2.5 count</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>count(iterator beg, iterator end, value);</code><br />
// 统计元素出现次数<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// value 统计的元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">  </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h4 id="526-count_if"><a class="markdownIt-Anchor" href="#526-count_if"></a> 5.2.6 count_if</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>count_if(iterator beg, iterator end, _Pred);</code><br />
// 按条件统计元素出现次数<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// _Pred 谓词</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**按值统计用count，按条件统计用count_if</p>
<h3 id="53-常用排序算法"><a class="markdownIt-Anchor" href="#53-常用排序算法"></a> 5.3 常用排序算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code> //对容器内元素进行排序</li>
<li><code>random_shuffle</code> //洗牌 指定范围内的元素随机调整次序</li>
<li><code>merge</code> // 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code> // 反转指定范围的元素</li>
</ul>
<h4 id="531-sort"><a class="markdownIt-Anchor" href="#531-sort"></a> 5.3.1 sort</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end, _Pred);</code><br />
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// _Pred 谓词</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="532-random_shuffle"><a class="markdownIt-Anchor" href="#532-random_shuffle"></a> 5.3.2 random_shuffle</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>洗牌 指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>random_shuffle(iterator beg, iterator end);</code><br />
// 指定范围内的元素随机调整次序<br />
// beg 开始迭代器<br />
// end 结束迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打乱顺序</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="533-merge"><a class="markdownIt-Anchor" href="#533-merge"></a> 5.3.3 merge</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br />
// 容器元素合并，并存储到另一容器中<br />
// 注意: 两个容器必须是<strong>有序的</strong><br />
// beg1 容器1开始迭代器<br />
// end1 容器1结束迭代器<br />
// beg2 容器2开始迭代器<br />
// end2 容器2结束迭代器<br />
// dest 目标容器开始迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line">	<span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">	vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">	<span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**merge合并的两个容器必须的有序序列</p>
<h4 id="534-reverse"><a class="markdownIt-Anchor" href="#534-reverse"></a> 5.3.4 reverse</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse(iterator beg, iterator end);</code><br />
// 反转指定范围的元素<br />
// beg 开始迭代器<br />
// end 结束迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="54-常用拷贝和替换算法"><a class="markdownIt-Anchor" href="#54-常用拷贝和替换算法"></a> 5.4 常用拷贝和替换算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code> // 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code> // 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if</code> // 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code> // 互换两个容器的元素</li>
</ul>
<h4 id="541-copy"><a class="markdownIt-Anchor" href="#541-copy"></a> 5.4.1 copy</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>copy(iterator beg, iterator end, iterator dest);</code><br />
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// dest 目标起始迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="542-replace"><a class="markdownIt-Anchor" href="#542-replace"></a> 5.4.2 replace</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code><br />
// 将区间内旧元素 替换成 新元素<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// oldvalue 旧元素<br />
// newvalue 新元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**replace会替换区间内满足条件的元素</p>
<h4 id="543-replace_if"><a class="markdownIt-Anchor" href="#543-replace_if"></a> 5.4.3 replace_if</h4>
<p><strong>功能描述:</strong></p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code><br />
// 按条件替换元素，满足条件的替换成指定元素<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// _pred 谓词<br />
// newvalue 替换的新元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="544-swap"><a class="markdownIt-Anchor" href="#544-swap"></a> 5.4.4 swap</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(container c1, container c2);</code><br />
// 互换两个容器的元素<br />
// c1容器1<br />
// c2容器2</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="55-常用算术生成算法"><a class="markdownIt-Anchor" href="#55-常用算术生成算法"></a> 5.5 常用算术生成算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>accumulate</code> // 计算容器元素累计总和</li>
<li><code>fill</code> // 向容器中添加元素</li>
</ul>
<h4 id="551-accumulate"><a class="markdownIt-Anchor" href="#551-accumulate"></a> 5.5.1 accumulate</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>accumulate(iterator beg, iterator end, value);</code><br />
// 计算容器元素累计总和<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// value 起始值</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="552-fill"><a class="markdownIt-Anchor" href="#552-fill"></a> 5.5.2 fill</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>fill(iterator beg, iterator end, value);</code><br />
// 向容器中填充元素<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// value 填充的值</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="56-常用集合算法"><a class="markdownIt-Anchor" href="#56-常用集合算法"></a> 5.6 常用集合算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>set_intersection</code> // 求两个容器的交集</li>
<li><code>set_union</code> // 求两个容器的并集</li>
<li><code>set_difference</code> // 求两个容器的差集</li>
</ul>
<h4 id="561-set_intersection"><a class="markdownIt-Anchor" href="#561-set_intersection"></a> 5.6.1 set_intersection</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br />
// 求两个集合的交集<br />
// <strong>注意:两个集合必须是有序序列</strong><br />
// beg1 容器1开始迭代器<br />
// end1 容器1结束迭代器<br />
// beg2 容器2开始迭代器<br />
// end2 容器2结束迭代器<br />
// dest 目标容器开始迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="562-set_union"><a class="markdownIt-Anchor" href="#562-set_union"></a> 5.6.2 set_union</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br />
// 求两个集合的并集<br />
// <strong>注意:两个集合必须是有序序列</strong><br />
// beg1 容器1开始迭代器<br />
// end1 容器1结束迭代器<br />
// beg2 容器2开始迭代器<br />
// end2 容器2结束迭代器<br />
// dest 目标容器开始迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="563-set_difference"><a class="markdownIt-Anchor" href="#563-set_difference"></a> 5.6.3 set_difference</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br />
// 求两个集合的差集<br />
// <strong>注意:两个集合必须是有序序列</strong><br />
// beg1 容器1开始迭代器<br />
// end1 容器1结束迭代器<br />
// beg2 容器2开始迭代器<br />
// end2 容器2结束迭代器<br />
// dest 目标容器开始迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong><br />
id test01()<br />
{<br />
vector v1;<br />
for (int i = 0; i &lt; 10; i++) {<br />
v1.push_back(i + 1);<br />
}<br />
vector v2;<br />
v2.resize(v1.size());<br />
copy(v1.begin(), v1.end(), v2.begin());<br />
for_each(v2.begin(), v2.end(), myPrint());<br />
cout &lt;&lt; endl;<br />
}</li>
</ul>
<p>int main() {</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>}</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">**总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="number">5.4</span><span class="number">.2</span> replace</span><br><span class="line"></span><br><span class="line">**功能描述：**</span><br><span class="line"></span><br><span class="line">* 将容器内指定范围的旧元素修改为新元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**函数原型：**</span><br><span class="line"></span><br><span class="line">- `<span class="built_in">replace</span>(iterator beg, iterator end, oldvalue, newvalue);  `</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将区间内旧元素 替换成 新元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// beg 开始迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// end 结束迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// oldvalue 旧元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// newvalue 新元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**示例：**</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**replace会替换区间内满足条件的元素</p>
<h4 id="543-replace_if-2"><a class="markdownIt-Anchor" href="#543-replace_if-2"></a> 5.4.3 replace_if</h4>
<p><strong>功能描述:</strong></p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code><br />
// 按条件替换元素，满足条件的替换成指定元素<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// _pred 谓词<br />
// newvalue 替换的新元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="544-swap-2"><a class="markdownIt-Anchor" href="#544-swap-2"></a> 5.4.4 swap</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(container c1, container c2);</code><br />
// 互换两个容器的元素<br />
// c1容器1<br />
// c2容器2</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="55-常用算术生成算法-2"><a class="markdownIt-Anchor" href="#55-常用算术生成算法-2"></a> 5.5 常用算术生成算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>accumulate</code> // 计算容器元素累计总和</li>
<li><code>fill</code> // 向容器中添加元素</li>
</ul>
<h4 id="551-accumulate-2"><a class="markdownIt-Anchor" href="#551-accumulate-2"></a> 5.5.1 accumulate</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>accumulate(iterator beg, iterator end, value);</code><br />
// 计算容器元素累计总和<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// value 起始值</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="552-fill-2"><a class="markdownIt-Anchor" href="#552-fill-2"></a> 5.5.2 fill</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>fill(iterator beg, iterator end, value);</code><br />
// 向容器中填充元素<br />
// beg 开始迭代器<br />
// end 结束迭代器<br />
// value 填充的值</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="56-常用集合算法-2"><a class="markdownIt-Anchor" href="#56-常用集合算法-2"></a> 5.6 常用集合算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>set_intersection</code> // 求两个容器的交集</li>
<li><code>set_union</code> // 求两个容器的并集</li>
<li><code>set_difference</code> // 求两个容器的差集</li>
</ul>
<h4 id="561-set_intersection-2"><a class="markdownIt-Anchor" href="#561-set_intersection-2"></a> 5.6.1 set_intersection</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br />
// 求两个集合的交集<br />
// <strong>注意:两个集合必须是有序序列</strong><br />
// beg1 容器1开始迭代器<br />
// end1 容器1结束迭代器<br />
// beg2 容器2开始迭代器<br />
// end2 容器2结束迭代器<br />
// dest 目标容器开始迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="562-set_union-2"><a class="markdownIt-Anchor" href="#562-set_union-2"></a> 5.6.2 set_union</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br />
// 求两个集合的并集<br />
// <strong>注意:两个集合必须是有序序列</strong><br />
// beg1 容器1开始迭代器<br />
// end1 容器1结束迭代器<br />
// beg2 容器2开始迭代器<br />
// end2 容器2结束迭代器<br />
// dest 目标容器开始迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="563-set_difference-2"><a class="markdownIt-Anchor" href="#563-set_difference-2"></a> 5.6.3 set_difference</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><br />
// 求两个集合的差集<br />
// <strong>注意:两个集合必须是有序序列</strong><br />
// beg1 容器1开始迭代器<br />
// end1 容器1结束迭代器<br />
// beg2 容器2开始迭代器<br />
// end2 容器2结束迭代器<br />
// dest 目标容器开始迭代器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>笔记摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_204_计数质数</title>
    <url>/2022/11/10/leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<p>这一题暴力法肯定不行……</p>
<p>但是还是有几个可以优化的地方, 首先就是, 如果想判断一个数是不是质数, 不需要让一个变量从2开始一直除到n-1, 事实上假如这个大数不是质数的话, 它的一个因数一定在sqrt(n)以内(小于等于), 所以循环做到这样就够了.</p>
<span id="more"></span>
<p>然后就是关于sqrt不需要放在for循环语句里面, 比如像是这样:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="built_in">sqrt</span>(n); i++)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样其实很不好, 每一次循环到这里都要算一次sqrt(n), 一个优化办法是使用一个已经算好的sqrt(n), 这样不用每次都算.</p>
<p>实际上最后是使用这个叫做埃氏筛选的方法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#作者：LeetCode-Solution</span><br><span class="line">#链接：https:<span class="comment">//leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/</span></span><br><span class="line">#来源：力扣（LeetCode）</span><br><span class="line">#著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>这是官网的解析. 先创建一个大数组(大小是n), 一开始全部置1表示默认全都是质数. 然后从2开始, 每次读到一个为1的数字, 就把所有它的倍数全部置0, 并且把最后的结果++, 读到0就跳过.</p>
<p>我一开始没有细看上面的官方题解, 照着官方的思路写了一遍, 代码是下面:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prime</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;  <span class="comment">//使用n个1初始化prime</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prime[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j = j + i) &#123;</span><br><span class="line">          prime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>但是实际上这样肯定是慢了. 可以发现大体思路都差不多, 但是有几点不同的就是这一段:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)i * i &lt; n) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">    isPrime[j] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在置0的时候, 我是把所有i到n之间的所有倍数置0, 而这里的代码只把i*i到n之间部分置0. 这就省下来了一部分. 简单来说, 对于合数(正是我们要标记的), 都可以分解成两个数的乘积(比如说是a乘b). 而如果a和b相等, 则这个合数会在循环变量为a的时候被标记. 如果说a和b不相等, 一定是一大一小. 为什么循环到i的时候, 只需要查看i*i到n的部分呢? 比如说<code>a&lt;b</code>那么<code>a*b</code>是落在<code>a*a ~ n</code>这个区间里面的, 所以等到循环变量为b(较大者)的时候就不用讨论<code>a*b</code>这个合数了. 所以对于每个循环来说都只需要讨论<code>i*i ~ n</code>. 然后官方题解里面有一个<code>if ((long long)i * i &lt; n)</code>此时也就很好理解了. 因为如果<code>i*i&gt;n</code>那么也就没有不被讨论的合数了. 所以虽然大致的思路能够知道, 在小细节上还是要多学习.</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>missing_semester粗看</title>
    <url>/2022/11/10/missing-semester%E7%B2%97%E7%9C%8B/</url>
    <content><![CDATA[<p>虽然Missing semester的网站很贴心准备了笔记, 但是笔记里面提到的知识点非常多而且繁杂. 还是有必要开一篇文章来注解一下. 官方对这个课真的很用心, 还有专门的中文翻译(当然这个有可能是别的中国人贡献的). 实际上即使是有笔记我还是没办法理解每一条命令的内涵, 也只是稍稍理解一下罢了.</p>
<p><a href="https://missing-semester-cn.github.io/">官方笔记</a></p>
<span id="more"></span>
<h1 id="数据整理"><a class="markdownIt-Anchor" href="#数据整理"></a> 数据整理</h1>
<h2 id="ssh"><a class="markdownIt-Anchor" href="#ssh"></a> ssh</h2>
<p>虽然数据整理和SSH没有什么关系, 仅仅只是使用ssh举了一个例子. 但是秉持着探索的态度, 还是有必要了解一下ssh. 毕竟在我前面的学习生活中其实已经不少见了.</p>
<p>ssh全名叫做Secure Shell. 提供了一种安全的方式登录远程桌面. 在同一个局域网下面ssh的用法十分简单, 我手机termux使用ssh可以在局域网下面轻松登录电脑的shell. 在tldr(一个我非常喜欢的简洁版本的man手册)里面列出来了一些最经典的ssh命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Secure Shell is a protocol used to securely log onto remote systems.It can be used for logging or executing commands on a remote server.More information: https://man.openbsd.org/ssh.</span><br><span class="line"></span><br><span class="line"> - Connect to a remote server:</span><br><span class="line">   ssh &#123;&#123;username&#125;&#125;@&#123;&#123;remote_host&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Connect to a remote server with a specific identity (private key):</span><br><span class="line">   ssh -i &#123;&#123;path/to/key_file&#125;&#125; &#123;&#123;username&#125;&#125;@&#123;&#123;remote_host&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Connect to a remote server using a specific port:</span><br><span class="line">   ssh &#123;&#123;username&#125;&#125;@&#123;&#123;remote_host&#125;&#125; -p &#123;&#123;2222&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Run a command on a remote server with a [t]ty allocation allowing interaction with the remote command:</span><br><span class="line">   ssh &#123;&#123;username&#125;&#125;@&#123;&#123;remote_host&#125;&#125; -t &#123;&#123;command&#125;&#125; &#123;&#123;command_arguments&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:1080):</span><br><span class="line">   ssh -D &#123;&#123;1080&#125;&#125; &#123;&#123;username&#125;&#125;@&#123;&#123;remote_host&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - SSH tunneling: Forward a specific port (localhost:9999 to example.org:80) along with disabling pseudo-[T]ty allocation and executio[N] of remote commands:</span><br><span class="line">   ssh -L &#123;&#123;9999&#125;&#125;:&#123;&#123;example.org&#125;&#125;:&#123;&#123;80&#125;&#125; -N -T &#123;&#123;username&#125;&#125;@&#123;&#123;remote_host&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - SSH jumping: Connect through a jumphost to a remote server (Multiple jump hops may be specified separated by comma characters):</span><br><span class="line">   ssh -J &#123;&#123;username&#125;&#125;@&#123;&#123;jump_host&#125;&#125; &#123;&#123;username&#125;&#125;@&#123;&#123;remote_host&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Agent forwarding: Forward the authentication information to the remote machine (see man ssh_config for available options):</span><br><span class="line">   ssh -A &#123;&#123;username&#125;&#125;@&#123;&#123;remote_host&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>当然在使用ssh的过程中还可以配置免密码登录之类的操作, [这个B站视频](<a href="https://oiaom.github.io/2022/08/29/missing-semester/%E3%80%90%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%EF%BC%9FSSH%E4%B8%8Efrp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%E3%80%91">https://oiaom.github.io/2022/08/29/missing-semester/【如何优雅地访问远程主机？SSH与frp内网穿透配置教程】</a> <a href="https://www.bilibili.com/video/BV13L411w7XU?share_source=copy_web&amp;vd_source=c825e8a8735a644c2c384d551af8125e">https://www.bilibili.com/video/BV13L411w7XU?share_source=copy_web&amp;vd_source=c825e8a8735a644c2c384d551af8125e</a>)讲得很好.</p>
<p>不过在这里ssh其实也就是起到一个来输出日志的作用, 目的还是讲解grep的用法.</p>
<p>其中有一个很妙的思想. 首先ssh传输是比较慢的, 远程运行命令和本机运行命令是远远快于ssh的传输的.</p>
<p>看下面命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh myserver journalctl | grep sshd</span><br></pre></td></tr></table></figure>
<p>这个意思是, 把这个日志打印出来, 并且过滤出含有sshd的内容.</p>
<p>但是这个缺陷很大. 首先, 我是在本机上面运行这条命令, grep是在本机上面运行的, 所以对于ssh来说, 还是需要传输完整的日志输出到本机, 之后本机执行grep来过滤到我需要的数据. 中间传输比较慢.</p>
<p>所以可以作如下改进:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh &#x27;myserver journalctl | grep sshd&#x27;</span><br></pre></td></tr></table></figure>
<p>但是不知道是不是因为手机是termux的缘故, 目前还没有成功打印出来正常的ssh日志.</p>
<h2 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h2>
<p>正则表达式在计算机中的应用很广泛, 很多代码补全的插件就是使用这个工具来判断的. 对于基本的正则表达式了解可以参看:<a href="https://www.bilibili.com/video/BV1da4y1p7iZ?share_source=copy_web&amp;vd_source=c825e8a8735a644c2c384d551af8125e">10分钟快速掌握正则表达式</a></p>
<p>详细一点的文档可以参看:<a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">ziishaned/learn-regex</a></p>
<p>我估计在我看llvm的那个时候可以用到相关知识, 所以这个文档我就是粗略地过一遍吧.</p>
<h2 id="awk"><a class="markdownIt-Anchor" href="#awk"></a> awk</h2>
<p>grep, sed, awk是比较出名的处理文本的三个工具.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ which awk         </span><br><span class="line">/usr/bin/awk</span><br><span class="line">➜  ~ ls -l /usr/bin/awk</span><br><span class="line">lrwxrwxrwx root root 21 B Thu Aug 11 07:05:20 2022  /usr/bin/awk ⇒ /etc/alternatives/awk</span><br><span class="line">➜  ~ </span><br></pre></td></tr></table></figure>
<p>这是我电脑上面的awk情况.</p>
<p>这个工具非常抽象, 我就不学了. <a href="https://www.runoob.com/linux/linux-comm-awk.html">菜鸟教程点此</a></p>
<p>虽然在grep sed awk里面awk应该是最强大的.</p>
<h1 id="命令行环境"><a class="markdownIt-Anchor" href="#命令行环境"></a> 命令行环境</h1>
<h2 id="kill命令"><a class="markdownIt-Anchor" href="#kill命令"></a> kill命令</h2>
<p><a href="https://www.runoob.com/linux/linux-comm-kill.html">菜鸟教程kill</a></p>
<h2 id="ps命令"><a class="markdownIt-Anchor" href="#ps命令"></a> ps命令</h2>
<p><a href="https://www.runoob.com/linux/linux-comm-ps.html">菜鸟教程ps</a></p>
<p>这个内容太杂了, 我还是多学一点东西之后再来学吧, 只是粗略地看了一遍.</p>
]]></content>
      <tags>
        <tag>touchfish</tag>
        <tag>残缺的笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数学公式符号</title>
    <url>/2022/11/10/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<p>主要是离散数学的笔记需要一些符号, 但是又不想老是百度上面找, 可以记笔记的过程中自己就留下来一些, 方便自己找. 用了Latex的部分语法.</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord"><span class="mord textrm mtight sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span></span></p>
<p><a href="https://blog.csdn.net/xxzhangx/article/details/52778539">latex中的希腊字母</a></p>
<span id="more"></span>
<p>\times <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 叉乘</p>
<p>\cdot <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">⋅</span></span></span></span> 点乘</p>
<p>\mid <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> 中竖线 整除</p>
<p>\nmid <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∤</mo></mrow><annotation encoding="application/x-tex">\nmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.99253em;vertical-align:-0.25142em;"></span><span class="mrel amsrm">∤</span></span></span></span> 反中竖线 中竖线上一斜线</p>
<p>\in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> 属于</p>
<p>\notin <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">∉</mo></mrow><annotation encoding="application/x-tex">\notin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span></span></span></span></span> 不属于</p>
<p>\supset <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊃</mo></mrow><annotation encoding="application/x-tex">\supset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊃</span></span></span></span> 含于</p>
<p>\supseteq <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊇</mo></mrow><annotation encoding="application/x-tex">\supseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊇</span></span></span></span> 含于</p>
<p>\subset <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span> 含于</p>
<p>\subseteq <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span></span></span></span> 含于</p>
<p>\cup <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span></span></span></span> 并</p>
<p>\varnothing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66334em;vertical-align:-0.08167em;"></span><span class="mord amsrm">∅</span></span></span></span> 空集</p>
<p>\neq <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 不等于</p>
<p>\leq <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> 小于等于</p>
<p>\geq <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 大于等于</p>
<p>\vee <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\vee</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∨</span></span></span></span> 析取(或)</p>
<p>\wedge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∧</span></span></span></span> 合取(且)</p>
<p>\rightarrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 右箭头</p>
<p>\Rightarrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> 推出</p>
<p>\leftarrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">←</span></span></span></span> 左箭头</p>
<p>\Leftarrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇐</mo></mrow><annotation encoding="application/x-tex">\Leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇐</span></span></span></span> 左推出</p>
<p>\leftrightarrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">↔</span></span></span></span> 等价</p>
<p>\Leftrightarrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇔</mo></mrow><annotation encoding="application/x-tex">\Leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇔</span></span></span></span> 大等价</p>
<p>\exists <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span></span></span></span> 存在</p>
<p>\forall <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">\forall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span> 任意</p>
<p>\neg <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">¬</span></span></span></span> 非</p>
<p>\equiv <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span> 合同于 恒等于</p>
<p>\quad <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span> 空格</p>
<p>; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>  </mtext></mrow><annotation encoding="application/x-tex">\;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span></span></span> 短空格长度</p>
<p>\space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext></mrow><annotation encoding="application/x-tex">\space</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace"> </span></span></span></span> 空格</p>
<p>\pm <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo></mrow><annotation encoding="application/x-tex">\pm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">±</span></span></span></span> 正负号</p>
<p>\underline <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mi>a</mi><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\underline{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63056em;vertical-align:-0.19999999999999996em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43056000000000005em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19999999999999996em;"><span></span></span></span></span></span></span></span></span> 给字母添加下划线</p>
<p>\overline <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63056em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span> 给字母添加上划线</p>
<p>\frac{a}{b} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 分数线</p>
<p>\sqrt[2]{} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mrow></mrow><mn>2</mn></mroot></mrow><annotation encoding="application/x-tex">\sqrt[2]{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2395em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.65882em;"><span style="top:-2.8366em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8005em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"></span></span><span style="top:-2.7605em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2395em;"><span></span></span></span></span></span></span></span></span> 根号(方框里面控制数字)</p>
<p>\lim_{} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\lim_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 极限下标</p>
<p>\partial <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi></mrow><annotation encoding="application/x-tex">\partial</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span></span></span></span> 偏导</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>[</span><br><span class="line">    <span class="keyword">\begin</span>&#123;array&#125;&#123;ccc&#125;</span><br><span class="line">        1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 0<span class="keyword">\\</span></span><br><span class="line">        0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0<span class="keyword">\\</span></span><br><span class="line">        0 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1<span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\right</span>]</span><br></pre></td></tr></table></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[
    \begin{array}{ccc}
        1 &amp; 0 &amp; 0\\
        0 &amp; 1 &amp; 0\\
        0 &amp; 0 &amp; 1\\
    \end{array}
\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>矩阵({ccc}是指元素的对齐方法（居中），此外还有<code>l</code>和<code>r</code>的参数可选，分别表示左和右)</p>
<p>\int_{a}^{b} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup></mrow><annotation encoding="application/x-tex">\int_{a}^{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.399828em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span></span></span></span> 积分号和上下限</p>
<p>\iint_{a}^{b} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∬</mo><mi>a</mi><mi>b</mi></msubsup></mrow><annotation encoding="application/x-tex">\iint_{a}^{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.399708em;vertical-align:-0.3557em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0004999999999999727em;">∬</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.3443em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3557em;"><span></span></span></span></span></span></span></span></span></span> 二重积分</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span><span class="keyword">\&#123;</span><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">x=x(t)<span class="keyword">\\</span></span><br><span class="line">y=y(t)<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;<span class="keyword">\right</span>.</span><br></pre></td></tr></table></figure>
<p>方程组</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>y</mi><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{aligned}
x=x(t)\\
y=y(t)\\
\end{aligned}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.00003em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这里, <code>\left\和\right.</code>是用来确定左括号的, 中间的\是用来换行的, aligned表示按照aligned的方式来排版公式, 一般推荐使用这种公式.</p>
<p>当然也可以左对齐:</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;l&#125;</span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>&#123;L&#125;f(x,y)ds=<span class="keyword">\int</span><span class="built_in">_</span>&#123;a&#125;<span class="built_in">^</span>&#123;b&#125;f(x(t), y(t)) <span class="keyword">\sqrt</span>&#123;x<span class="built_in">^</span>&#123;&#x27;2&#125;(t)+y<span class="built_in">^</span>&#123;&#x27;2&#125;(t)&#125; dt <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>&#123;<span class="keyword">\Gamma</span>&#125;f(x,y,z)ds=<span class="keyword">\int</span><span class="built_in">_</span>&#123;a&#125;<span class="built_in">^</span>&#123;b&#125;f(x(t), y(t), z(t)) <span class="keyword">\sqrt</span>&#123;x<span class="built_in">^</span>&#123;&#x27;2&#125;(t)+y<span class="built_in">^</span>&#123;&#x27;2&#125;(t)+z<span class="built_in">^</span>&#123;&#x27;2&#125;(t)&#125; dt</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∫</mo><mi>L</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mi>d</mi><mi>s</mi><mo>=</mo><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msqrt><mrow><msup><mi>x</mi><mrow><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mn>2</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>y</mi><mrow><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mn>2</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></msqrt><mi>d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo>∫</mo><mi mathvariant="normal">Γ</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mi>d</mi><mi>s</mi><mo>=</mo><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msqrt><mrow><msup><mi>x</mi><mrow><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mn>2</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>y</mi><mrow><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mn>2</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>z</mi><mrow><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mn>2</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></msqrt><mi>d</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}
\int_{L}f(x,y)ds=\int_{a}^{b}f(x(t), y(t)) \sqrt{x^{&#x27;2}(t)+y^{&#x27;2}(t)} dt \\\\
\int_{\Gamma}f(x,y,z)ds=\int_{a}^{b}f(x(t), y(t), z(t)) \sqrt{x^{&#x27;2}(t)+y^{&#x27;2}(t)+z^{&#x27;2}(t)} dt
\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.0080160000000005em;vertical-align:-1.7540080000000002em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.2540080000000002em;"><span style="top:-4.254008em;"><span class="pstrut" style="height:3.044008em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.12251099999999993em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9434899999999999em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.76698em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.76698em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-2.90349em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29651000000000005em;"><span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.0540079999999996em;"><span class="pstrut" style="height:3.044008em;"></span><span class="mord"></span></span><span style="top:-1.6499999999999997em;"><span class="pstrut" style="height:3.044008em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.12251099999999993em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9434899999999999em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.76698em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.76698em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.76698em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-2.90349em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29651000000000005em;"><span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.7540080000000002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<p>不过array需要一个参数才能够正常用.</p>
<p>但是实际上latex使用cases可以快速写方程组. 但是cases默认是带大括号的, 对于上面的这两个积分公式, 使用cases来左对齐就不合适.</p>
<p>但是对于一般的带大括号的表达式, cases更加方便.</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">x=x(t)<span class="keyword">\\</span></span><br><span class="line">y=y(t)<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
x=x(t)\\
y=y(t)\\
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>\oint <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∮</mo></mrow><annotation encoding="application/x-tex">\oint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11112em;vertical-align:-0.30612em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∮</span></span></span></span> 闭合曲线积分</p>
<p>\oiint <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>\oiint</mo></mrow><annotation encoding="application/x-tex">\oiint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.111em;vertical-align:-0.306em;"></span><span class="mop vlist-t vlist-t2" style="position:relative;top:-0.0005000000000000282em;"><span class="vlist-r"><span class="vlist" style="height:0.8049999999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∬</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="overlay" style="height:0.499em;width:0.957em;"><svg width='0.957em' height='0.499em' style='width:0.957em' viewBox='0 0 957 499' preserveAspectRatio='xMinYMin'><path d='M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.306em;"><span></span></span></span></span></span></span></span> 同理的闭合曲面积分</p>
<p>\prod_{2}^{1} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∏</mo><mn>2</mn><mn>1</mn></msubsup></mrow><annotation encoding="application/x-tex">\prod_{2}^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span> 连乘</p>
<p>\sum_{k=1}^{3} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mn>3</mn></msubsup></mrow><annotation encoding="application/x-tex">\sum_{k=1}^{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span> 求和符号(和直接Sigma不一样 在大代码块下面式子会在正上下)</p>
<p>对比:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Σ</mi><mspace width="1em"/><mo>∑</mo></mrow><annotation encoding="application/x-tex">\Sigma\quad \sum
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span></span></span></span></span></p>
<p>\sim <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span></span></span></span> 波浪线</p>
<p>\textasciitilde <span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \textasciitilde at position 1: \̲t̲e̲x̲t̲a̲s̲c̲i̲i̲t̲i̲l̲d̲e̲'>\textasciitilde</span> 波浪线 其实这个符号键盘上用~这个也行</p>
<p>\cong <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.589em;vertical-align:0em;"></span><span class="mrel">≅</span></span></span></span> 同构 全等</p>
<p>\nabla <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∇</mi></mrow><annotation encoding="application/x-tex">\nabla</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">∇</span></span></span></span> 梯度</p>
<p>\lfloor \rfloor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>a</mi><mo>+</mo><mn>1</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor a+1\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⌋</span></span></span></span> 向下取整</p>
<p>\lceil \rceil <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>a</mi><mo>+</mo><mn>1</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil a+1\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⌉</span></span></span></span> 向上取整</p>
<p>❌ ✖️ 🚫👷‍♀️ 🚧🎉 ✅ 🎊📝 🔜常用emoji</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>排版</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>月色真美小评</title>
    <url>/2022/11/10/%E6%9C%88%E8%89%B2%E7%9C%9F%E7%BE%8E%E5%B0%8F%E8%AF%84/</url>
    <content><![CDATA[<p>说实话嗷, 我是看了这么久的番剧, 还没有什么番剧有二刷的欲望. 但是月色真美确实让我想再看一遍.</p>
<p>首先是制作精良, 画风非常喜欢. 这种画风并不是一般日漫的那种大眼画风, 而是一种很特别的, 让人看上去很舒服的画风. <s>好吧虽然眼睛比例还是挺大的</s></p>
<span id="more"></span>
<p><img src="https://pic.imgdb.cn/item/630c82ec16f2c2beb12c74d3.jpg" alt="alt" /></p>
<p>不会给人一种”逼人”的感觉, 太漂亮的女主或者太帅气的男主会让人有一种疏离感, 你在看别人拉扯, 觉得很甜, 没什么代入感. 或者说这样类似的东西看得越多, 自己越是苦闷. 人经常感叹的”这样的xxx现实生活中可能没有吧”.</p>
<p>这个番就没有这样的感觉, 确实能很清晰地感受到男女主之间的情感线, 这就是这个番最突出的特点: 真情实感无论在什么时候都是更打动人的.</p>
<p>在看番剧的时候, 有的时候会有一些奇怪的点, 比如很难理解, 经常弹幕都会说这为什么不A上去, 这样的人为什么还要继续谈恋爱此类, 还有一些莫名其妙的情节, 一点小误会闹好几集. 是, 我理解, 这样写编剧可以更好地发糖, 或者说这样一些情节能够所谓推进情感线, 虽然观众看完之后, 就是在这些情节结束之后吗, 会感到很舒服, 啊终于合好了之类, 但是在看的时候会有一些疑问, 或者是会有一些吐槽, 让人感觉有些”出戏”.</p>
<p>出现这样离谱情节或者老套情节的原因就是这是为了甜而甜, 有一些番啊(只是比较少的一部分), 确实可以称得上是”工业糖精”, B站弹幕这样称呼是有原因的, 因为是把甜当成了目的, 所以会有一些看上去很熟悉的部分, 忽视了中间的情感. 说实话其实这样也行, 毕竟大家看番也就看一乐呵, 但是假如在做到这样的同时加上感情的塑造, 这样是不是更加好呢?</p>
<p>这部剧设定的时候在初中, 真的是非常真实, 很好地把握了初中时期男女主的情感变化. 没有像是很多其他番剧里面的主动啊智斗啊, 通篇给人一种未成熟的感觉(当然有些地方确实是有一些过了, 其实现在初中生知道事情也挺多了hhhhh). 但是无论如何是很真实的. 包括最开始两人也不知道什么是所谓”交往”, 只是想要在一起.</p>
<p>最后是一个特点是对这个叙事的把握, 不会是那种大把大把撒糖(虽然这样也好, 也有很多人喜欢看, 我有的时候也看一下), 而是一种注重现实规律的缓慢发展.</p>
<p>不管怎么说真情实感就是最好的招牌了, 在我心里我暂时宣布这是最好的恋爱番, 但是不一定是最甜的.(其实我是不想写了)</p>
]]></content>
      <tags>
        <tag>touchfish</tag>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>clangd+codelldb的vscode表现</title>
    <url>/2022/11/10/clangd-codelldb%E7%9A%84vscode%E8%A1%A8%E7%8E%B0/</url>
    <content><![CDATA[<p>对于vsocde巨硬官方的C++调试插件, 许多学长们非常不满. 对于我来讲, 我目前用着感觉很差的方面主要就是堆栈帧看不了.(当然不是一般的函数调用堆栈帧, 例如cout这种函数就看不了说是没权限. 还有就是头文件的跳转, 在我电脑的环境下iostream跳转好像没问题, 但是进入这个头内部之后再想跳转似乎不行?) 我这里目前是ubuntu22.04的环境. 先看下下面这个视频, 文章是对它的补充:</p>
<p><a href="https://www.bilibili.com/video/BV1sW411v7VZ?share_source=copy_web">https://www.bilibili.com/video/BV1sW411v7VZ?share_source=copy_web</a></p>
<span id="more"></span>
<p>所以看了网上很多家方案之后, 我最后选择了clangd补全分析, lldb调试, <s>llvm不知道干什么</s>.</p>
<p><img src="https://pic.imgdb.cn/item/62bd5a5d1d64b0706614c2e0.png" alt="img" /></p>
<h1 id="linux环境配置"><a class="markdownIt-Anchor" href="#linux环境配置"></a> linux环境配置</h1>
<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2>
<p>安装好clang, clangd, llvm(所以这个 干什么的). lldb就不用装了, 可以直接用vscode扩展里面自带的codelldb来, 没必要全局安装了. 全局安装了反而不好配hhhh.</p>
<p><strong>注意, 在我后来重新看来, 这里完全没有必要安装clang. 我十分建议使用g++作为工具链. clang自身并不自带stdc++标准库, 所以用的时候可能会出现头文件缺失的问题(虽然也好解决), 但是clangd和clang没啥关系, vscode的cmake工具也可以使用g++工具链. 所以完全可以把这里的clang安装换成g++. 直接安装clang反而可能会出现头文件确实的可能性.</strong></p>
<p>以ubuntu作为例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install clang clangd llvm</span><br></pre></td></tr></table></figure>
<p>然后在vscode里面把原来的配置文件以及其他的扩展都删掉. 新建文件夹.vscode, 再新建tasks.json和launch.json. 这里有一点还需要注意, 好像这个tasks.json啊, 它只认自己创建的, 它不认新建的. 遇到这种情况就点终端-&gt;配置任务-&gt;使用模板创建tasks.json文件-&gt;others(其实这里怎么点都一样, 只要把文件搞出来就可以了.) 或者重启一下, 如果你在命名有./.vscode/tasks.json的情况下还被说任务不存在, 那就说明是这样.</p>
<h2 id="安装相应的调试扩展"><a class="markdownIt-Anchor" href="#安装相应的调试扩展"></a> 安装相应的调试扩展</h2>
<p>下载这几个插件:clangd codelldb.</p>
<h2 id="运行和调试配置"><a class="markdownIt-Anchor" href="#运行和调试配置"></a> 运行和调试配置</h2>
<p>然后就是json怎么写的问题. 我这里举几个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //task.json</span><br><span class="line">  &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">  &quot;tasks&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">      &quot;label&quot;: &quot;Build C++&quot;,</span><br><span class="line">      &quot;command&quot;: &quot;clang++&quot;,</span><br><span class="line">      &quot;args&quot;: [</span><br><span class="line">        &quot;-g&quot;,</span><br><span class="line">        &quot;-Wall&quot;,</span><br><span class="line">        &quot;-o&quot;,</span><br><span class="line">        &quot;$&#123;workspaceFolder&#125;/output/$&#123;fileBasenameNoExtension&#125;&quot;,</span><br><span class="line">        &quot;$&#123;workspaceFolder&#125;/*.cpp&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;options&quot;: &#123;</span><br><span class="line">        &quot;cwd&quot;: &quot;/usr/bin&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;group&quot;: &#123;</span><br><span class="line">        &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">        &quot;isDefault&quot;: true</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;detail&quot;: &quot;Task generated by Debugger.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面具体的细节性的东西我也不是很清楚, 但是有几个关键的必须要明白, 要是照搬照抄很有可能在自己的电脑上面运行不起来.</p>
<p>首先先注意command这里, 虽然说clang也可以编译C++代码, 但是C++有的用法还是不兼容, 好像常见的std::cout这种说法就不行(这里我没有试过, 反正确实有一些写法是没法用). 所以填clang++, 这也是官方提供的解决方法.</p>
<p>再就是args(arguments)这一栏, 里面的args含义必须要知道. -g这个都知道是完整的调试信息, -Wall的意思是显示完整的warning信息, -o明显是一个重命名选项. 然后重要的是后面两个, 第一个参数是编译后生成的可执行文件的路径, 我这里写的是 <code>$&#123;workspaceFolder&#125;/output/$&#123;fileBasenameNoExtension&#125;</code>, 这里带有$的都是vscode里面定义的宏, 表示编译之后的可执行文件生成在我当前vscode工作区的文件夹下面的output文件夹里面, 然后生成的可执行文件的名字是我编译的这个文件去掉扩展名(NoExtension). 所以假如想用我这一套配置, 就必须在工作目录下面新建一个output文件夹, 我这样设计有一个好处就是可以把源文件放在工作目录下面, 可执行文件单独放到一个文件夹里面. 整个工作目录比较简洁.</p>
<p>下一个是需要编译的文件的路径. 我这里路径写的是*.cpp, 这是一个通配符写法, 意思是编译的时候把当前目录下面的所有cpp文件都编译了. 这个主要是针对有些代码不止一个源文件, 当然这样写就有一个坏处, 那就是不能把所有的作品都存到工作目录下面, 不然出现多个main函数就没法报错. 我的目录树结构是这样的:</p>
<p>.<br />
├── archive<br />
├── .clang-format<br />
├── main.cpp<br />
├── output<br />
├── .vscode<br />
└── .vscode.bkbk(这是vscode的配置备份, 忽略)</p>
<p>可以看见, 当前目录下面留3个文件夹, 一个是.vscode正常, 一个是output用来储存可执行文件的, 还有一个就是归档, 每次代码写好了之后就把代码放到那个文件夹里面, 保证外面的代码都是当前编辑的项目且只有一个main函数. 当然你也可以新建一个src目录, 了解了这些args的含义都好办. 设置成编译src目录下面的所有cpp文件很容易的, 通过json可以控制整个编译过程.</p>
<p>假如vscode只是想写单文件的东西, 可以直接把上面的*.cpp改成${file}, 这样就只是编译当前的单文件. 这个时候所有代码都放到工作区文件夹下面就可以了. 对于一些人这样的结构只写单文件, 多文件都是单独开文件夹用cmake写的.</p>
<p>接下来是launch.json实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">  // 悬停以查看现有属性的描述。</span><br><span class="line">  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // 刘的注释: 这个tasks.json和launch.json的作用是, 在vscode当前打开的目录下, 使用clang++编译工作区目录下面的所有cpp文件(所以同一时间下build目录里面只能有一个项目), 并且把输出放到当前目录下面的output目录下面.</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;lldb&quot;,</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;Debug&quot;,</span><br><span class="line">      &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/output/$&#123;fileBasenameNoExtension&#125;&quot;,</span><br><span class="line">      &quot;args&quot;: [],</span><br><span class="line">      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">      &quot;preLaunchTask&quot;: &quot;Build C++&quot;,</span><br><span class="line">      &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;,</span><br><span class="line">      &quot;console&quot;: &quot;integratedTerminal&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>type是和扩展有关, 安装了codelldb之后就可以填这个type了. program填的位置就是可执行文件出现的目录, 注意和task.json保持一致. 本质上就是launch.json是管调试的, task.json是管编译的. 还有一个很重要的就是”prelaunchtask”, 这一项是说在调试之前要干什么, 如果没有这个每次调试按钮之前还要手动编译一下. 这里的名字要和前面task的label保持一致. 其他的意思倒也无所谓.</p>
<p><s>紧接着是clang-format, 在上面的目录树里面, 出现了.clang-format. 这个文件是用来格式化代码用的, 而且标准规定得很硬性. 在工作目录下面新建一个这个文件之后, clangd扩展内置的clang-format可以对内容进行读取, 自动规定tab宽度啊, 什么乱七八糟的, 只要这个文件到位了, 基本上以后新电脑就再也不用配置代码风格相关的东西了. 这个文件可以自己写, 也可以安装clang-format生成, 我这里生成了google风格的文件作为实例:</s></p>
<blockquote>
<p>这里出错了, 实际上当时我没有搞清楚clangd其实自己也有格式化的功能, 其实原来讲的配置clangformat就不行. 其实根本就没有配置上.</p>
<p>其实clang-format自己也有很严重的问题—版本不兼容. 在vscode扩展商场里面下载clang-format, 这个时候我在我电脑上面下载了clang-format:</p>
<p><code>sudo apt install clang-format</code></p>
<p>然后用:</p>
<p><code>clang-format -style=google -dump-config &gt; .clang-format</code></p>
<p>生成了google风格的配置文件, 接着把这个文件copy到项目中, 然后vscode中右键, 选择&quot;Format Document With…&quot;, 上面会弹出来一个框, 里面configure了一下默认的formatter.</p>
<p>然后我再格式化就报错了.</p>
<p>这其实是因为这个插件没更新导致的. 所以应该控制好版本. 我当前电脑上是Ubuntu22.10, 能在包管理器里面找到的最老的clang-format是11.</p>
<p><code>sudo apt install clang-format-11</code></p>
<p>然后:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/bin</span><br><span class="line">sudo ln -s clang-format-11 clang-format</span><br></pre></td></tr></table></figure>
<p>这样我输入clang-format就会调用这个11, 不这样进行一个<strong>软链接</strong>结果就是很多插件都会找不到, 插件比较笨, 一般只会找clang-format在不在环境变量里面. 然后目前为止在vscode里面就可以正常clang-format了. 然后我把这个配置文件放到clion里面发现还是报错, 总之就是值不兼容. 很典, 就是提示这个地方只能填某三个值, 结果生成的文件里面是true. 很大程度上是clang-format更新之后的语法变了. 我只好把那些标高亮的都注释掉了.(所以clion为什么你不自带一个format)</p>
<p>我这里再贴一份.clang-format, 是由clang-format-11生成的, 如果说老版本clion想要用的话需要自行改一些高亮的, 好在不是太多.(适用于vscode的Clang-Format插件):</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">Language:</span>        <span class="string">Cpp</span></span><br><span class="line"><span class="comment"># BasedOnStyle:  Google</span></span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-1</span></span><br><span class="line"><span class="attr">AlignAfterOpenBracket:</span> <span class="string">Align</span></span><br><span class="line"><span class="attr">AlignConsecutiveMacros:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AlignConsecutiveAssignments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AlignConsecutiveBitFields:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AlignConsecutiveDeclarations:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AlignEscapedNewlines:</span> <span class="string">Left</span></span><br><span class="line"><span class="attr">AlignOperands:</span>   <span class="string">Align</span></span><br><span class="line"><span class="attr">AlignTrailingComments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowAllArgumentsOnNextLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowAllConstructorInitializersOnNextLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowShortEnumsOnASingleLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AllowShortBlocksOnASingleLine:</span> <span class="string">Never</span></span><br><span class="line"><span class="attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AllowShortFunctionsOnASingleLine:</span> <span class="string">All</span></span><br><span class="line"><span class="attr">AllowShortLambdasOnASingleLine:</span> <span class="string">All</span></span><br><span class="line"><span class="attr">AllowShortIfStatementsOnASingleLine:</span> <span class="string">WithoutElse</span></span><br><span class="line"><span class="attr">AllowShortLoopsOnASingleLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterReturnType:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AlwaysBreakTemplateDeclarations:</span> <span class="literal">Yes</span></span><br><span class="line"><span class="attr">BinPackArguments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BinPackParameters:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BraceWrapping:</span></span><br><span class="line"><span class="attr">AfterCaseLabel:</span>  <span class="literal">false</span></span><br><span class="line"><span class="attr">AfterClass:</span>      <span class="literal">false</span></span><br><span class="line"><span class="attr">AfterControlStatement:</span> <span class="string">Never</span></span><br><span class="line"><span class="attr">AfterEnum:</span>       <span class="literal">false</span></span><br><span class="line"><span class="attr">AfterFunction:</span>   <span class="literal">false</span></span><br><span class="line"><span class="attr">AfterNamespace:</span>  <span class="literal">false</span></span><br><span class="line"><span class="attr">AfterObjCDeclaration:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AfterStruct:</span>     <span class="literal">false</span></span><br><span class="line"><span class="attr">AfterUnion:</span>      <span class="literal">false</span></span><br><span class="line"><span class="attr">AfterExternBlock:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BeforeCatch:</span>     <span class="literal">false</span></span><br><span class="line"><span class="attr">BeforeElse:</span>      <span class="literal">false</span></span><br><span class="line"><span class="attr">BeforeLambdaBody:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BeforeWhile:</span>     <span class="literal">false</span></span><br><span class="line"><span class="attr">IndentBraces:</span>    <span class="literal">false</span></span><br><span class="line"><span class="attr">SplitEmptyFunction:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SplitEmptyRecord:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SplitEmptyNamespace:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BreakBeforeBinaryOperators:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">BreakBeforeBraces:</span> <span class="string">Attach</span></span><br><span class="line"><span class="attr">BreakBeforeInheritanceComma:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakInheritanceList:</span> <span class="string">BeforeColon</span></span><br><span class="line"><span class="attr">BreakBeforeTernaryOperators:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BreakConstructorInitializersBeforeComma:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakConstructorInitializers:</span> <span class="string">BeforeColon</span></span><br><span class="line"><span class="attr">BreakAfterJavaFieldAnnotations:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakStringLiterals:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ColumnLimit:</span>     <span class="number">80</span></span><br><span class="line"><span class="attr">CommentPragmas:</span>  <span class="string">&#x27;^ IWYU pragma:&#x27;</span></span><br><span class="line"><span class="attr">CompactNamespaces:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">ConstructorInitializerAllOnOneLineOrOnePerLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ConstructorInitializerIndentWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">ContinuationIndentWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">Cpp11BracedListStyle:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">DeriveLineEnding:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">DerivePointerAlignment:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">DisableFormat:</span>   <span class="literal">false</span></span><br><span class="line"><span class="attr">ExperimentalAutoDetectBinPacking:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">FixNamespaceComments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ForEachMacros:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">foreach</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Q_FOREACH</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOST_FOREACH</span></span><br><span class="line"><span class="attr">IncludeBlocks:</span>   <span class="string">Regroup</span></span><br><span class="line"><span class="attr">IncludeCategories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">&#x27;^&lt;ext/.*\.h&gt;&#x27;</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">2</span></span><br><span class="line">    <span class="attr">SortPriority:</span>    <span class="number">0</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">&#x27;^&lt;.*\.h&gt;&#x27;</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">1</span></span><br><span class="line">    <span class="attr">SortPriority:</span>    <span class="number">0</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">&#x27;^&lt;.*&#x27;</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">2</span></span><br><span class="line">    <span class="attr">SortPriority:</span>    <span class="number">0</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">&#x27;.*&#x27;</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">3</span></span><br><span class="line">    <span class="attr">SortPriority:</span>    <span class="number">0</span></span><br><span class="line"><span class="attr">IncludeIsMainRegex:</span> <span class="string">&#x27;([-_](test|unittest))?$&#x27;</span></span><br><span class="line"><span class="attr">IncludeIsMainSourceRegex:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">IndentCaseLabels:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">IndentCaseBlocks:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">IndentGotoLabels:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">IndentPPDirectives:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">IndentExternBlock:</span> <span class="string">AfterExternBlock</span></span><br><span class="line"><span class="attr">IndentWidth:</span>     <span class="number">2</span></span><br><span class="line"><span class="attr">IndentWrappedFunctionNames:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">InsertTrailingCommas:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">JavaScriptQuotes:</span> <span class="string">Leave</span></span><br><span class="line"><span class="attr">JavaScriptWrapImports:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">MacroBlockBegin:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">MacroBlockEnd:</span>   <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">MaxEmptyLinesToKeep:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">NamespaceIndentation:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">ObjCBinPackProtocolList:</span> <span class="string">Never</span></span><br><span class="line"><span class="attr">ObjCBlockIndentWidth:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">ObjCBreakBeforeNestedBlockParam:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ObjCSpaceAfterProperty:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">ObjCSpaceBeforeProtocolList:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">PenaltyBreakAssignment:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">PenaltyBreakComment:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">PenaltyBreakFirstLessLess:</span> <span class="number">120</span></span><br><span class="line"><span class="attr">PenaltyBreakString:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">PenaltyBreakTemplateDeclaration:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">PenaltyExcessCharacter:</span> <span class="number">1000000</span></span><br><span class="line"><span class="attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Left</span></span><br><span class="line"><span class="attr">RawStringFormats:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Language:</span>        <span class="string">Cpp</span></span><br><span class="line">    <span class="attr">Delimiters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cc</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CC</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cpp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Cpp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CPP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;c++&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;C++&#x27;</span></span><br><span class="line">    <span class="attr">CanonicalDelimiter:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">BasedOnStyle:</span>    <span class="string">google</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Language:</span>        <span class="string">TextProto</span></span><br><span class="line">    <span class="attr">Delimiters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PB</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">proto</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PROTO</span></span><br><span class="line">    <span class="attr">EnclosingFunctions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">EqualsProto</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">EquivToProto</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PARSE_PARTIAL_TEXT_PROTO</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PARSE_TEST_PROTO</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PARSE_TEXT_PROTO</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ParseTextOrDie</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ParseTextProtoOrDie</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ParseTestProto</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ParsePartialTestProto</span></span><br><span class="line">    <span class="attr">CanonicalDelimiter:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">BasedOnStyle:</span>    <span class="string">google</span></span><br><span class="line"><span class="attr">ReflowComments:</span>  <span class="literal">true</span></span><br><span class="line"><span class="attr">SortIncludes:</span>    <span class="literal">true</span></span><br><span class="line"><span class="attr">SortUsingDeclarations:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceAfterCStyleCast:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpaceAfterLogicalNot:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpaceAfterTemplateKeyword:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeAssignmentOperators:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeCpp11BracedList:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpaceBeforeCtorInitializerColon:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeInheritanceColon:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeParens:</span> <span class="string">ControlStatements</span></span><br><span class="line"><span class="attr">SpaceBeforeRangeBasedForLoopColon:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceInEmptyBlock:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpaceInEmptyParentheses:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesBeforeTrailingComments:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">SpacesInAngles:</span>  <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesInConditionalStatement:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesInContainerLiterals:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpacesInCStyleCastParentheses:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesInParentheses:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesInSquareBrackets:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpaceBeforeSquareBrackets:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Standard:</span>        <span class="string">Auto</span></span><br><span class="line"><span class="attr">StatementMacros:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Q_UNUSED</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">QT_REQUIRE_VERSION</span></span><br><span class="line"><span class="attr">TabWidth:</span>        <span class="number">8</span></span><br><span class="line"><span class="attr">UseCRLF:</span>         <span class="literal">false</span></span><br><span class="line"><span class="attr">UseTab:</span>          <span class="string">Never</span></span><br><span class="line"><span class="attr">WhitespaceSensitiveMacros:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">STRINGIZE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PP_STRINGIZE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOST_PP_STRINGIZE</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时更新到ubuntu22.10之后, clang-format也更新到了15, 这里是15生成的配置文件, Google的:</p>
<pre class="highlight"><code class="yaml"><span class="meta">---</span>
<span class="attr">Language:</span>        <span class="string">Cpp</span>
<span class="comment"># BasedOnStyle:  Google</span>
<span class="attr">AccessModifierOffset:</span> <span class="number">-1</span>
<span class="attr">AlignAfterOpenBracket:</span> <span class="string">Align</span>
<span class="attr">AlignArrayOfStructures:</span> <span class="string">None</span>
<span class="attr">AlignConsecutiveAssignments:</span>
  <span class="attr">Enabled:</span>         <span class="literal">false</span>
  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>
  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>
  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>
  <span class="attr">PadOperators:</span>    <span class="literal">true</span>
<span class="attr">AlignConsecutiveBitFields:</span>
  <span class="attr">Enabled:</span>         <span class="literal">false</span>
  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>
  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>
  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>
  <span class="attr">PadOperators:</span>    <span class="literal">false</span>
<span class="attr">AlignConsecutiveDeclarations:</span>
  <span class="attr">Enabled:</span>         <span class="literal">false</span>
  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>
  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>
  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>
  <span class="attr">PadOperators:</span>    <span class="literal">false</span>
<span class="attr">AlignConsecutiveMacros:</span>
  <span class="attr">Enabled:</span>         <span class="literal">false</span>
  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>
  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>
  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>
  <span class="attr">PadOperators:</span>    <span class="literal">false</span>
<span class="attr">AlignEscapedNewlines:</span> <span class="string">Left</span>
<span class="attr">AlignOperands:</span>   <span class="string">Align</span>
<span class="attr">AlignTrailingComments:</span> <span class="literal">true</span>
<span class="attr">AllowAllArgumentsOnNextLine:</span> <span class="literal">true</span>
<span class="attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="literal">true</span>
<span class="attr">AllowShortEnumsOnASingleLine:</span> <span class="literal">true</span>
<span class="attr">AllowShortBlocksOnASingleLine:</span> <span class="string">Never</span>
<span class="attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="literal">false</span>
<span class="attr">AllowShortFunctionsOnASingleLine:</span> <span class="string">All</span>
<span class="attr">AllowShortLambdasOnASingleLine:</span> <span class="string">All</span>
<span class="attr">AllowShortIfStatementsOnASingleLine:</span> <span class="string">WithoutElse</span>
<span class="attr">AllowShortLoopsOnASingleLine:</span> <span class="literal">true</span>
<span class="attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="string">None</span>
<span class="attr">AlwaysBreakAfterReturnType:</span> <span class="string">None</span>
<span class="attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="literal">true</span>
<span class="attr">AlwaysBreakTemplateDeclarations:</span> <span class="literal">Yes</span>
<span class="attr">AttributeMacros:</span>
  <span class="bullet">-</span> <span class="string">__capability</span>
<span class="attr">BinPackArguments:</span> <span class="literal">true</span>
<span class="attr">BinPackParameters:</span> <span class="literal">true</span>
<span class="attr">BraceWrapping:</span>
  <span class="attr">AfterCaseLabel:</span>  <span class="literal">false</span>
  <span class="attr">AfterClass:</span>      <span class="literal">false</span>
  <span class="attr">AfterControlStatement:</span> <span class="string">Never</span>
  <span class="attr">AfterEnum:</span>       <span class="literal">false</span>
  <span class="attr">AfterFunction:</span>   <span class="literal">false</span>
  <span class="attr">AfterNamespace:</span>  <span class="literal">false</span>
  <span class="attr">AfterObjCDeclaration:</span> <span class="literal">false</span>
  <span class="attr">AfterStruct:</span>     <span class="literal">false</span>
  <span class="attr">AfterUnion:</span>      <span class="literal">false</span>
  <span class="attr">AfterExternBlock:</span> <span class="literal">false</span>
  <span class="attr">BeforeCatch:</span>     <span class="literal">false</span>
  <span class="attr">BeforeElse:</span>      <span class="literal">false</span>
  <span class="attr">BeforeLambdaBody:</span> <span class="literal">false</span>
  <span class="attr">BeforeWhile:</span>     <span class="literal">false</span>
  <span class="attr">IndentBraces:</span>    <span class="literal">false</span>
  <span class="attr">SplitEmptyFunction:</span> <span class="literal">true</span>
  <span class="attr">SplitEmptyRecord:</span> <span class="literal">true</span>
  <span class="attr">SplitEmptyNamespace:</span> <span class="literal">true</span>
<span class="attr">BreakBeforeBinaryOperators:</span> <span class="string">None</span>
<span class="attr">BreakBeforeConceptDeclarations:</span> <span class="string">Always</span>
<span class="attr">BreakBeforeBraces:</span> <span class="string">Attach</span>
<span class="attr">BreakBeforeInheritanceComma:</span> <span class="literal">false</span>
<span class="attr">BreakInheritanceList:</span> <span class="string">BeforeColon</span>
<span class="attr">BreakBeforeTernaryOperators:</span> <span class="literal">true</span>
<span class="attr">BreakConstructorInitializersBeforeComma:</span> <span class="literal">false</span>
<span class="attr">BreakConstructorInitializers:</span> <span class="string">BeforeColon</span>
<span class="attr">BreakAfterJavaFieldAnnotations:</span> <span class="literal">false</span>
<span class="attr">BreakStringLiterals:</span> <span class="literal">true</span>
<span class="attr">ColumnLimit:</span>     <span class="number">80</span>
<span class="attr">CommentPragmas:</span>  <span class="string">&#x27;^ IWYU pragma:&#x27;</span>
<span class="attr">QualifierAlignment:</span> <span class="string">Leave</span>
<span class="attr">CompactNamespaces:</span> <span class="literal">false</span>
<span class="attr">ConstructorInitializerIndentWidth:</span> <span class="number">4</span>
<span class="attr">ContinuationIndentWidth:</span> <span class="number">4</span>
<span class="attr">Cpp11BracedListStyle:</span> <span class="literal">true</span>
<span class="attr">DeriveLineEnding:</span> <span class="literal">true</span>
<span class="attr">DerivePointerAlignment:</span> <span class="literal">true</span>
<span class="attr">DisableFormat:</span>   <span class="literal">false</span>
<span class="attr">EmptyLineAfterAccessModifier:</span> <span class="string">Never</span>
<span class="attr">EmptyLineBeforeAccessModifier:</span> <span class="string">LogicalBlock</span>
<span class="attr">ExperimentalAutoDetectBinPacking:</span> <span class="literal">false</span>
<span class="attr">PackConstructorInitializers:</span> <span class="string">NextLine</span>
<span class="attr">BasedOnStyle:</span>    <span class="string">&#x27;&#x27;</span>
<span class="attr">ConstructorInitializerAllOnOneLineOrOnePerLine:</span> <span class="literal">false</span>
<span class="attr">AllowAllConstructorInitializersOnNextLine:</span> <span class="literal">true</span>
<span class="attr">FixNamespaceComments:</span> <span class="literal">true</span>
<span class="attr">ForEachMacros:</span>
  <span class="bullet">-</span> <span class="string">foreach</span>
  <span class="bullet">-</span> <span class="string">Q_FOREACH</span>
  <span class="bullet">-</span> <span class="string">BOOST_FOREACH</span>
<span class="attr">IfMacros:</span>
  <span class="bullet">-</span> <span class="string">KJ_IF_MAYBE</span>
<span class="attr">IncludeBlocks:</span>   <span class="string">Regroup</span>
<span class="attr">IncludeCategories:</span>
  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">&#x27;^&lt;ext/.*\.h&gt;&#x27;</span>
    <span class="attr">Priority:</span>        <span class="number">2</span>
    <span class="attr">SortPriority:</span>    <span class="number">0</span>
    <span class="attr">CaseSensitive:</span>   <span class="literal">false</span>
  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">&#x27;^&lt;.*\.h&gt;&#x27;</span>
    <span class="attr">Priority:</span>        <span class="number">1</span>
    <span class="attr">SortPriority:</span>    <span class="number">0</span>
    <span class="attr">CaseSensitive:</span>   <span class="literal">false</span>
  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">&#x27;^&lt;.*&#x27;</span>
    <span class="attr">Priority:</span>        <span class="number">2</span>
    <span class="attr">SortPriority:</span>    <span class="number">0</span>
    <span class="attr">CaseSensitive:</span>   <span class="literal">false</span>
  <span class="bullet">-</span> <span class="attr">Regex:</span>           <span class="string">&#x27;.*&#x27;</span>
    <span class="attr">Priority:</span>        <span class="number">3</span>
    <span class="attr">SortPriority:</span>    <span class="number">0</span>
    <span class="attr">CaseSensitive:</span>   <span class="literal">false</span>
<span class="attr">IncludeIsMainRegex:</span> <span class="string">&#x27;([-_](test|unittest))?$&#x27;</span>
<span class="attr">IncludeIsMainSourceRegex:</span> <span class="string">&#x27;&#x27;</span>
<span class="attr">IndentAccessModifiers:</span> <span class="literal">false</span>
<span class="attr">IndentCaseLabels:</span> <span class="literal">true</span>
<span class="attr">IndentCaseBlocks:</span> <span class="literal">false</span>
<span class="attr">IndentGotoLabels:</span> <span class="literal">true</span>
<span class="attr">IndentPPDirectives:</span> <span class="string">None</span>
<span class="attr">IndentExternBlock:</span> <span class="string">AfterExternBlock</span>
<span class="attr">IndentRequiresClause:</span> <span class="literal">true</span>
<span class="attr">IndentWidth:</span>     <span class="number">2</span>
<span class="attr">IndentWrappedFunctionNames:</span> <span class="literal">false</span>
<span class="attr">InsertBraces:</span>    <span class="literal">false</span>
<span class="attr">InsertTrailingCommas:</span> <span class="string">None</span>
<span class="attr">JavaScriptQuotes:</span> <span class="string">Leave</span>
<span class="attr">JavaScriptWrapImports:</span> <span class="literal">true</span>
<span class="attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="literal">false</span>
<span class="attr">LambdaBodyIndentation:</span> <span class="string">Signature</span>
<span class="attr">MacroBlockBegin:</span> <span class="string">&#x27;&#x27;</span>
<span class="attr">MacroBlockEnd:</span>   <span class="string">&#x27;&#x27;</span>
<span class="attr">MaxEmptyLinesToKeep:</span> <span class="number">1</span>
<span class="attr">NamespaceIndentation:</span> <span class="string">None</span>
<span class="attr">ObjCBinPackProtocolList:</span> <span class="string">Never</span>
<span class="attr">ObjCBlockIndentWidth:</span> <span class="number">2</span>
<span class="attr">ObjCBreakBeforeNestedBlockParam:</span> <span class="literal">true</span>
<span class="attr">ObjCSpaceAfterProperty:</span> <span class="literal">false</span>
<span class="attr">ObjCSpaceBeforeProtocolList:</span> <span class="literal">true</span>
<span class="attr">PenaltyBreakAssignment:</span> <span class="number">2</span>
<span class="attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="number">1</span>
<span class="attr">PenaltyBreakComment:</span> <span class="number">300</span>
<span class="attr">PenaltyBreakFirstLessLess:</span> <span class="number">120</span>
<span class="attr">PenaltyBreakOpenParenthesis:</span> <span class="number">0</span>
<span class="attr">PenaltyBreakString:</span> <span class="number">1000</span>
<span class="attr">PenaltyBreakTemplateDeclaration:</span> <span class="number">10</span>
<span class="attr">PenaltyExcessCharacter:</span> <span class="number">1000000</span>
<span class="attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="number">200</span>
<span class="attr">PenaltyIndentedWhitespace:</span> <span class="number">0</span>
<span class="attr">PointerAlignment:</span> <span class="string">Left</span>
<span class="attr">PPIndentWidth:</span>   <span class="number">-1</span>
<span class="attr">RawStringFormats:</span>
  <span class="bullet">-</span> <span class="attr">Language:</span>        <span class="string">Cpp</span>
    <span class="attr">Delimiters:</span>
      <span class="bullet">-</span> <span class="string">cc</span>
      <span class="bullet">-</span> <span class="string">CC</span>
      <span class="bullet">-</span> <span class="string">cpp</span>
      <span class="bullet">-</span> <span class="string">Cpp</span>
      <span class="bullet">-</span> <span class="string">CPP</span>
      <span class="bullet">-</span> <span class="string">&#x27;c++&#x27;</span>
      <span class="bullet">-</span> <span class="string">&#x27;C++&#x27;</span>
    <span class="attr">CanonicalDelimiter:</span> <span class="string">&#x27;&#x27;</span>
    <span class="attr">BasedOnStyle:</span>    <span class="string">google</span>
  <span class="bullet">-</span> <span class="attr">Language:</span>        <span class="string">TextProto</span>
    <span class="attr">Delimiters:</span>
      <span class="bullet">-</span> <span class="string">pb</span>
      <span class="bullet">-</span> <span class="string">PB</span>
      <span class="bullet">-</span> <span class="string">proto</span>
      <span class="bullet">-</span> <span class="string">PROTO</span>
    <span class="attr">EnclosingFunctions:</span>
      <span class="bullet">-</span> <span class="string">EqualsProto</span>
      <span class="bullet">-</span> <span class="string">EquivToProto</span>
      <span class="bullet">-</span> <span class="string">PARSE_PARTIAL_TEXT_PROTO</span>
      <span class="bullet">-</span> <span class="string">PARSE_TEST_PROTO</span>
      <span class="bullet">-</span> <span class="string">PARSE_TEXT_PROTO</span>
      <span class="bullet">-</span> <span class="string">ParseTextOrDie</span>
      <span class="bullet">-</span> <span class="string">ParseTextProtoOrDie</span>
      <span class="bullet">-</span> <span class="string">ParseTestProto</span>
      <span class="bullet">-</span> <span class="string">ParsePartialTestProto</span>
    <span class="attr">CanonicalDelimiter:</span> <span class="string">pb</span>
    <span class="attr">BasedOnStyle:</span>    <span class="string">google</span>
<span class="attr">ReferenceAlignment:</span> <span class="string">Pointer</span>
<span class="attr">ReflowComments:</span>  <span class="literal">true</span>
<span class="attr">RemoveBracesLLVM:</span> <span class="literal">false</span>
<span class="attr">RequiresClausePosition:</span> <span class="string">OwnLine</span>
<span class="attr">SeparateDefinitionBlocks:</span> <span class="string">Leave</span>
<span class="attr">ShortNamespaceLines:</span> <span class="number">1</span>
<span class="attr">SortIncludes:</span>    <span class="string">CaseSensitive</span>
<span class="attr">SortJavaStaticImport:</span> <span class="string">Before</span>
<span class="attr">SortUsingDeclarations:</span> <span class="literal">true</span>
<span class="attr">SpaceAfterCStyleCast:</span> <span class="literal">false</span>
<span class="attr">SpaceAfterLogicalNot:</span> <span class="literal">false</span>
<span class="attr">SpaceAfterTemplateKeyword:</span> <span class="literal">true</span>
<span class="attr">SpaceBeforeAssignmentOperators:</span> <span class="literal">true</span>
<span class="attr">SpaceBeforeCaseColon:</span> <span class="literal">false</span>
<span class="attr">SpaceBeforeCpp11BracedList:</span> <span class="literal">false</span>
<span class="attr">SpaceBeforeCtorInitializerColon:</span> <span class="literal">true</span>
<span class="attr">SpaceBeforeInheritanceColon:</span> <span class="literal">true</span>
<span class="attr">SpaceBeforeParens:</span> <span class="string">ControlStatements</span>
<span class="attr">SpaceBeforeParensOptions:</span>
  <span class="attr">AfterControlStatements:</span> <span class="literal">true</span>
  <span class="attr">AfterForeachMacros:</span> <span class="literal">true</span>
  <span class="attr">AfterFunctionDefinitionName:</span> <span class="literal">false</span>
  <span class="attr">AfterFunctionDeclarationName:</span> <span class="literal">false</span>
  <span class="attr">AfterIfMacros:</span>   <span class="literal">true</span>
  <span class="attr">AfterOverloadedOperator:</span> <span class="literal">false</span>
  <span class="attr">AfterRequiresInClause:</span> <span class="literal">false</span>
  <span class="attr">AfterRequiresInExpression:</span> <span class="literal">false</span>
  <span class="attr">BeforeNonEmptyParentheses:</span> <span class="literal">false</span>
<span class="attr">SpaceAroundPointerQualifiers:</span> <span class="string">Default</span>
<span class="attr">SpaceBeforeRangeBasedForLoopColon:</span> <span class="literal">true</span>
<span class="attr">SpaceInEmptyBlock:</span> <span class="literal">false</span>
<span class="attr">SpaceInEmptyParentheses:</span> <span class="literal">false</span>
<span class="attr">SpacesBeforeTrailingComments:</span> <span class="number">2</span>
<span class="attr">SpacesInAngles:</span>  <span class="string">Never</span>
<span class="attr">SpacesInConditionalStatement:</span> <span class="literal">false</span>
<span class="attr">SpacesInContainerLiterals:</span> <span class="literal">true</span>
<span class="attr">SpacesInCStyleCastParentheses:</span> <span class="literal">false</span>
<span class="attr">SpacesInLineCommentPrefix:</span>
  <span class="attr">Minimum:</span>         <span class="number">1</span>
  <span class="attr">Maximum:</span>         <span class="number">-1</span>
<span class="attr">SpacesInParentheses:</span> <span class="literal">false</span>
<span class="attr">SpacesInSquareBrackets:</span> <span class="literal">false</span>
<span class="attr">SpaceBeforeSquareBrackets:</span> <span class="literal">false</span>
<span class="attr">BitFieldColonSpacing:</span> <span class="string">Both</span>
<span class="attr">Standard:</span>        <span class="string">Auto</span>
<span class="attr">StatementAttributeLikeMacros:</span>
  <span class="bullet">-</span> <span class="string">Q_EMIT</span>
<span class="attr">StatementMacros:</span>
  <span class="bullet">-</span> <span class="string">Q_UNUSED</span>
  <span class="bullet">-</span> <span class="string">QT_REQUIRE_VERSION</span>
<span class="attr">TabWidth:</span>        <span class="number">8</span>
<span class="attr">UseCRLF:</span>         <span class="literal">false</span>
<span class="attr">UseTab:</span>          <span class="string">Never</span>
<span class="attr">WhitespaceSensitiveMacros:</span>
  <span class="bullet">-</span> <span class="string">STRINGIZE</span>
  <span class="bullet">-</span> <span class="string">PP_STRINGIZE</span>
  <span class="bullet">-</span> <span class="string">BOOST_PP_STRINGIZE</span>
  <span class="bullet">-</span> <span class="string">NS_SWIFT_NAME</span>
  <span class="bullet">-</span> <span class="string">CF_SWIFT_NAME</span>
<span class="string">...</span>
</code></pre>
</blockquote>
<p>注意, 在安装了官方的扩展之后, 默认的格式化工具就是官方的. clangd插件和官方的是冲突的, 卸载掉官方的插件之后再次格式化, 会提示找不到格式化工具, 然后再点击配置, 选择clangd提供的格式化工具, 这样就非常好.</p>
<p>那写到这里, 基本上问题都解决了.</p>
<h2 id="视频里面的一些小问题仅针对第二节"><a class="markdownIt-Anchor" href="#视频里面的一些小问题仅针对第二节"></a> 视频里面的一些小问题(仅针对第二节)</h2>
<p>视频评论区底下的task.json命令写的是clang不是clang++, 有的时候一些CPP的写法会出现问题.</p>
<p>使用这个插件进行调试的时候, 假如没办法看到全局变量, 就尝试切换一下左下侧的堆栈帧.</p>
<h1 id="windows环境下的配置"><a class="markdownIt-Anchor" href="#windows环境下的配置"></a> windows环境下的配置</h1>
<p>我认为还是得像视频里面一样, 使用wsl2. 首先对于一个程序员的windows系统, wsl2总是少不了的. 所以换言之windows下面想使用clangd基本上就是wsl2的配置, 视频中间的wsl2是第三方做的arch的发行版, 我个人还偏向使用微软商店提供的发行版, 更加可靠.<s>(再说了要那么新的软件干什么)</s> 下面是官方给的安装参考文档:</p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">https://docs.microsoft.com/zh-cn/windows/wsl/install</a></p>
<p>有几个注意点需要特别提醒:</p>
<ol>
<li>为了体验最好还是下载一个windows terminal. 还送一个很好看的默认字体.</li>
<li>如果勾选了磁盘压缩来节省空间(就是文件夹上面看到蓝色压缩箭头了的.)可能会在安装子系统的时候出现问题, 需要取消勾选某个特定位置. 如果是在微软商店安装的, 就需要取消家目录下面的AppData/Local/Packages/Canonical…(最后这个根据你选的发行版而定)这个文件夹的”压缩以节省空间”选项.</li>
<li>默认会把wsl安装到C盘, 其实是有办法安装到D盘, 详情可以看微软商店里面搜ubuntu的第一条评论.(就是赞最多的那个) 当然我个人C盘不少那点空间, 而且默认安装目录其实更加方便(教程命令什么的都能适用, 不用抄官方命令的时候还要注意路径问题)</li>
<li>假如ubuntu不要安装最新的22.04, 我也不知道为什么我一直失败, 最后还是选了20.04.</li>
</ol>
<p>我现在假设安装好了(其实安装wsl2还是有点费劲的…)</p>
<p>下面需要vscode里面非常好用的扩展—-“remote-wsl”, 接下来的步骤就和开始看的视频一样了. windows下面的小问题就重启解.</p>
]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>touchfish</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu使用建议</title>
    <url>/2022/11/10/ubuntu%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>最开始这里仅仅是一个20.04的问题解决文章集合. 随着时间的推移, 也遇到了更多问题和更多补充的内容, 所以今天将这篇文章标题和内容进行重写.</p>
<p>这些问题的解决顺序还是希望按照时间来排序, 也就是有一些操作可能会影响后续问题的解决.</p>
<p><strong>本文除开特别标注部分, 指的都是gnome版本的官方Ubuntu镜像.</strong></p>
<span id="more"></span>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>written in:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">            .-/+oossssoo+/-.               liu@liu-Swift-SFX14-41G </span><br><span class="line">        `:+ssssssssssssssssss+:`           ----------------------- </span><br><span class="line">      -+ssssssssssssssssssyyssss+-         OS: Ubuntu 22.10 x86_64 </span><br><span class="line">    .ossssssssssssssssssdMMMNysssso.       Host: Swift SFX14-41G V1.00 </span><br><span class="line">   /ssssssssssshdmmNNmmyNMMMMhssssss/      Kernel: 5.19.0-29-generic </span><br><span class="line">  +ssssssssshmydMMMMMMMNddddyssssssss+     Uptime: 40 mins </span><br><span class="line"> /sssssssshNMMMyhhyyyyhmNMMMNhssssssss/    Packages: 1719 (dpkg) </span><br><span class="line">.ssssssssdMMMNhsssssssssshNMMMdssssssss.   Shell: zsh 5.9 </span><br><span class="line">+sssshhhyNMMNyssssssssssssyNMMMysssssss+   Resolution: 1920x1080 </span><br><span class="line">ossyNMMMNyMMhsssssssssssssshmmmhssssssso   DE: GNOME 43.1 </span><br><span class="line">ossyNMMMNyMMhsssssssssssssshmmmhssssssso   WM: Mutter </span><br><span class="line">+sssshhhyNMMNyssssssssssssyNMMMysssssss+   WM Theme: Adwaita </span><br><span class="line">.ssssssssdMMMNhsssssssssshNMMMdssssssss.   Theme: Yaru-dark [GTK2/3] </span><br><span class="line"> /sssssssshNMMMyhhyyyyhdNMMMNhssssssss/    Icons: Yaru-dark [GTK2/3] </span><br><span class="line">  +sssssssssdmydMMMMMMMMddddyssssssss+     Terminal: x-terminal-emul </span><br><span class="line">   /ssssssssssshdmNNNNmyNMMMMhssssss/      CPU: AMD Ryzen 7 5700U 4.372GHz </span><br><span class="line">    .ossssssssssssssssssdMMMNysssso.       GPU: AMD ATI 05:00.0 Lucienne </span><br><span class="line">      -+sssssssssssssssssyyyssss+-         GPU: NVIDIA GeForce GTX 1650</span><br><span class="line">        `:+ssssssssssssssssss+:`           Memory: 2255MiB / 15328MiB </span><br><span class="line">            .-/+oossssoo+/-.</span><br></pre></td></tr></table></figure>
<p>有时候系统做了一些更改之后, 比如说装完字体应用里面还是找不到, 这个时候善用重启.</p>
<h1 id="系统优化部分"><a class="markdownIt-Anchor" href="#系统优化部分"></a> 系统优化部分</h1>
<h2 id="关闭默认按键"><a class="markdownIt-Anchor" href="#关闭默认按键"></a> 关闭默认按键</h2>
<p>很多人不想使用win+number的形式来打开快捷栏, 比如说我, 我使用win+2来切换到工作区2, 所以必须关闭这个快捷键. <a href="https://askubuntu.com/questions/968103/disable-the-default-app-key-supernum-functionality-on-ubuntu-17-10-and-later">参考文章</a>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock hot-keys false</span><br><span class="line">for i in $(seq 1 9); do gsettings set org.gnome.shell.keybindings switch-to-application-$&#123;i&#125; &#x27;[]&#x27;; done</span><br></pre></td></tr></table></figure>
<h2 id="btrfsb-tree-filesystem和timeshift"><a class="markdownIt-Anchor" href="#btrfsb-tree-filesystem和timeshift"></a> btrfs(B-tree filesystem)和timeshift</h2>
<p>在安装ubuntu的时候, 在选取主分区的时候默认都是使用ext4作为<strong>文件系统</strong>. 常年在Windows下面待确实让我对文件系统的理解没有什么. Windows默认是使用NTFS的文件系统. 文件系统的不同决定了文件在磁盘里面如何存储. 对于linux来说, 经常会用到备份(每次整大活之前先把系统拍个照片, 万一大活整烂了还可以像时光机器一样回滚到快照的时候). 和ext4相比, btrfs的最显著的优势就是方便备份. ext4备份的话需要复制很多文件, 而btrfs是一种比较奇特的方式, 可以瞬间完成备份, 也不用进行复杂的文件赋值. 恢复备份的时候也是瞬间恢复, 这给折腾Linux提供很多便利.</p>
<p>更加细节的东西可以参看学长的博客:<a href="https://blog.kaaass.net/archives/1748">点此</a></p>
<p>timeshift是一个备份的软件, 即使你没有使用btrfs作为文件系统, 使用timeshift经常备份也是一个好习惯.</p>
<h2 id="wayland和x11"><a class="markdownIt-Anchor" href="#wayland和x11"></a> wayland和X11</h2>
<p>这两者之间我也不是很懂, 但是确定的是, wayland是近年来新出现的协议, 带来一些新功能新改变. 但是有一些软件在这个下面表现不佳, 好像腾讯会议就是这个典型. 所以在进入ubuntu图形化界面的时候还是推荐选择x11而不是wayland. <strong>在ubuntu的设置-&gt;关于-&gt;窗口系统这一栏里面可以看到现在是不是x11</strong>. 在登录页面的右下角有一个设置一样的按钮. 选的时候选ubuntu on xorg, 不要选ubuntu on wayland.(有的时候只会显示ubuntu, 但是不管怎么样肯定有一个显示全了的, 反正能选出来). 有时候软件打不开等奇怪的bug就是wayland导致的.</p>
<h2 id="联网-换源-设置时间-更改root用户密码-更改家目录中英文"><a class="markdownIt-Anchor" href="#联网-换源-设置时间-更改root用户密码-更改家目录中英文"></a> 联网 换源 设置时间 更改root用户密码 更改家目录中英文</h2>
<p>这一系列东西基本上是必做的. 首先是换源问题, 这个其实现在也淡化了, 因为如果现在安装ubuntu的话, ubuntu会分配ubuntucn源, 速度也是挺快. 早期换源主要是因为ubuntu的服务器在国外, 安装软件包会不方便, 所以需要使用国内的镜像站(每隔一段时间copy原站, 给国内用户提供linux软件源服务, 也包括镜像的下载, 出名的包括清华大学开源镜像站). 如果对这一步不是很确定怎么做或者说觉得自己<code>sudo apt install</code>的速度足够快, 就不需要换了.</p>
<p>在时间问题上, linux默认使用<strong>协调世界时</strong>. 所以安装完系统时间会不对, 和现在时间相隔八小时. 但是近年来ubuntu都有联网校准时间功能, 只要连上网之后时间就会自动校准, 但是这样还是治标不治本. 如果ubuntu的时间对那么可以重启回Windows看看, 如果Windows时间也是对(当然你不能联网)那么才说明不存在这个问题. 否则需要让ubuntu使用本地时间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo timedatectl set-local-rtc 1</span><br></pre></td></tr></table></figure>
<p>总之就是在断网的情况下来回启动两个系统, 来印证此问题的解决.</p>
<p>设置完之后可以使用<code>sudo timedatectl</code>来查看时间的信息, 当然这里会有warning, 说明ubuntu建议还是使用协调世界时.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo timedatectl</span><br><span class="line">               Local time: 日 2023-02-05 22:31:30 CST</span><br><span class="line">           Universal time: 日 2023-02-05 14:31:30 UTC</span><br><span class="line">                 RTC time: 日 2023-02-05 22:31:31</span><br><span class="line">                Time zone: Asia/Shanghai (CST, +0800)</span><br><span class="line">System clock synchronized: <span class="built_in">yes</span></span><br><span class="line">              NTP service: active</span><br><span class="line">          RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">Warning: The system is configured to <span class="built_in">read</span> the RTC time <span class="keyword">in</span> the <span class="built_in">local</span> time zone.</span><br><span class="line">         This mode cannot be fully supported. It will create various problems</span><br><span class="line">         with time zone changes and daylight saving time adjustments. The RTC</span><br><span class="line">         time is never updated, it relies on external facilities to maintain it.</span><br><span class="line">         If at all possible, use RTC <span class="keyword">in</span> UTC by calling</span><br><span class="line">         <span class="string">&#x27;timedatectl set-local-rtc 0&#x27;</span>.</span><br></pre></td></tr></table></figure>
<p>完成设置时间后, 重启回Windows矫正一次时间, 之后双系统就不会出现时间问题了.</p>
<p>然后就是root用户密码的问题. 在linux里面, 权限最高的用户是root用户. sudo的意思就是super user do, 是让当前用户拥有root的权限. 关键问题是<strong>当前用户拥有root权限并不等于root用户</strong>. 有一些脚本是写死了使用root用户来执行了, 因为对于脚本的开发者来说root用户能够改变一些系统设置. 比如吉林大学的校园网的linux脚本, 默认就是使用root用户来执行. <strong>注意并不是root权限的普通用户, 或者说并不是sudo.</strong> 这种情况下它让你输入密码的时候输入的是root密码, 但是ubuntu的root用户默认没有设置密码.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">passwd</span><br></pre></td></tr></table></figure>
<p>想设置root用户密码, 首先得是root用户, 切换到root用户却需要密码, 这怎么办? 这个时候就是sudo了, 因为sudo能够让普通用户用自己的密码拿到root权限, 通过这个权限的提高直接进入root用户即可. 然后成为root用户之后再passwd就可以更改密码了. (因为用户最高, 即使它说你密码安全性不够也不用管它, 照常输入两边它还是听你的). 你可以使用<code>whoami</code>来打印当前用户的名字.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">whoami</span></span><br><span class="line">liu</span><br><span class="line">➜  ~ sudo su         </span><br><span class="line">root@liu-Swift-SFX14-41G:/home/liu: <span class="built_in">whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<p>而如果你使用中文安装ubuntu, 那你的家目录会全都是中文, 但是对于linux user来说这是很糟糕的一件事, 终端里面还要切输入法是十分抽象的. 所幸可以使用<code>xdg-user-dirs-gtk-update</code>工具来修改我们的家目录是否是中英文. 这是一个命令行工具. 要查看当前的语言环境, 你也可以打开终端, 输入<code>echo $LANG</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">echo</span> <span class="variable">$LANG</span> <span class="comment">#因为我后天改过所以这里没有输出中文, 正常中文安装之后会显示zh_CN之类的</span></span><br><span class="line">en_US.UTF-8</span><br></pre></td></tr></table></figure>
<p>这个时候输入<code>xdg-user-dirs-gtk-update</code>肯定没用, 因为你本来就是中文的环境. 而按照下面的方式输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=en_US <span class="comment"># 这条命令可以临时改变终端的语言环境为英文</span></span><br><span class="line">xdg-user-dirs-gtk-update <span class="comment"># 此时运行检测到环境为英文</span></span><br></pre></td></tr></table></figure>
<p>然后会弹出窗口提示更新名称, 然后更新, 下次开机的时候又会提醒是否更新名称, 那为什么又会弹窗呢? 因为我们只是临时改变了<code>$LANG</code>的值, 重新开机的时候它又知道自己是中文. 这个时候点不更新然后点不再提醒就好了. 之后家目录就可以很方便地变成英文. (当然我也没有试过是不是可以直接换, 直接创建文件夹)</p>
<h2 id="输入法"><a class="markdownIt-Anchor" href="#输入法"></a> 输入法</h2>
<p>ubuntu自带的输入法是<code>ibus-rime</code>, 我的评价是很难用, 而且没有词库. 我建议直接放弃使用ibus-rime. 更加重要的一点就是, ibus无法在pycharm里面正常使用输入? 况且我们有fcitx这个搜狗输入法可以用为什么不用呢?</p>
<p>这里ibus是输入法框架, rime是输入法的名字. 我最后使用fcitx作为输入法框架, sogoupinyin作为输入法. 当然也有很多人选择更加先进的fcitx5作为输入法框架, 搭配其他的输入法. 但是说实话, 感觉不如搜狗输入法.</p>
<p>对于一些执意要使用ibus-rime的人, 使用ibus有可能会出现输入框无法跟随光标的问题, 据说是因为gnome的bug. 这种情况有一个尝试方案: <a href="https://www.ipangbo.cn/linux/264.html">点此</a></p>
<p><strong>但是注意</strong>! 因为这个方法修改了环境变量, 会导致将来试图安装fcitx一类输入法的时候老是出现莫名奇妙的问题!! 我一开始使用的是ubuntu自带的中文输入法ibus-rime, 也出现了输入法不跟着光标的问题, 然后按照文章说的修改了环境变量, 后来我想用搜狗输入法因为更好用, 发现fcitx怎么都没法用, 后来才想起来是这里多了一个环境变量的shell程序. 所以对于用了root权限的命令都要知道它的作用和后果, 假如要转fcitx输入法的时候一定要把和ibus有关的东西搞干净. <strong>对于自己的系统一定要负责, 尤其是没有备份的情况下, 每一步sudo命令都尽量理解这些命令做了什么, 否则更改了某个设置结果忘了, 对日后产生一些影响却一直想不起来设置已经不是默认的设置了, 所以看别人的教程也没用了</strong>.</p>
<p>在ubuntu上面使用搜狗输入法: <a href="https://blog.csdn.net/Mr_Sudo/article/details/124874239">点此</a>. 如果使用搜狗输入法就装fcitx4, 不要fcitx5. 然后就是教程里面有一点, <strong>设置fcitx开机启动的那一步是不必要的</strong>. 再就是因为ibus本身是集成在系统里面的, 卸载的时候一定要看清楚, 不要不小心把桌面的一些部件也一起卸载了, 如果按照这个blog里面的命令来的话应该是没有这些问题的. 如果对于自己的能力不够自信, <strong>建议就不要卸载ibus输入法了</strong>, 这个包虽然用不上了你也可以留着, 如果不在乎这点磁盘空间的话.全了的, 反正能选出来)</p>
<h2 id="笔记本上字体太小"><a class="markdownIt-Anchor" href="#笔记本上字体太小"></a> 笔记本上字体太小</h2>
<p>有人会在设置-&gt;显示器里面调整缩放, 但是对于我的笔记本来说啊, 就是它只能够100%或者是200%. 如果我开启其他倍数缩放又会让字体变模糊.</p>
<p>解决办法就是安装<code>gnome-tweaks</code>: (在较早的版本这个好像叫做gnome-tweakstools, 记不得了, 总之就是装完是一个&quot;优化&quot;名字的软件)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweaks</span><br></pre></td></tr></table></figure>
<p>在应用程序里面找到&quot;优化&quot;点开, 然后找到字体这一栏, 缩放比例拉到1.5.</p>
<h2 id="nvidia-drivers"><a class="markdownIt-Anchor" href="#nvidia-drivers"></a> NVIDIA-drivers</h2>
<p>首先, 一般会在安装的时候自动安装好. 检验安装好没常用手段是<code>nvidia-smi</code>. 显卡问题稍微严重一点的可能连ubuntu的安装程序都没办法启动, 这个时候开机的时候要选<strong>safe graphic</strong>一栏.(哎这个是不是应该拿到开头才对, 是不是说晚了).</p>
<p>假如出现了刚安装完nvidia-smi有显示, 更新之后没有, 这种情况就很玄学, 好像过会就好了. 换源之后update, 然后有一个附加驱动的软件, 那里面会有推荐的驱动(后面有一个tested)</p>
<p>如果最后显卡驱动都安置妥当, 再说双显卡如何切换. 可以在命令行里面通过prime-select来切换显卡模式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo prime-select query #查询当前显卡处于什么模式</span><br><span class="line">sudo prime-select nvidia #切换到纯N卡独显模式</span><br><span class="line">sudo prime-select intel #切换到省电模式 这个模式下面nvidia-smi会提示找不到N卡这是正常的 即使是amd好像也是通过这个命令来切换</span><br></pre></td></tr></table></figure>
<p>然后就是有的时候没有nvidia-setting. 假如需要一个nvidia设置可以直接apt install一个:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install nvidia-settings</span><br></pre></td></tr></table></figure>
<p>不过模式切换命令行就能解决就是了. 当然图形化设置也能切换:</p>
<p><img src="https://pic.imgdb.cn/item/626d5491239250f7c58e0bd2.png" alt="alt" /></p>
<p>值得一提的是, 在混合模式下如何指定应用用独立显卡打开. 根据ubuntu的<a href="https://help.ubuntu.com/community/BinaryDriverHowto/Nvidia">官方文档</a>, 首先可以在混合(就是on-demand)模式下右键某软件, 点击使用独立显卡启动. 如果是在命令行下启动的程序, 可以使用下列命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only __GLX_VENDOR_LIBRARY_NAME=nvidia &quot;here_command&quot;</span><br></pre></td></tr></table></figure>
<p>是不是看上去很麻烦, 所以有一个包叫做prime-run来简化操作, 但是就这篇文章写的时候好像这个包还没有给22.04用的? 就是在包的查询网页上面看到链接里面都是focal.</p>
<p>prime-run实际上也就是把这些参数进行一个封装(<a href="https://askubuntu.com/questions/1364762/prime-run-command-not-found">可见此</a>), 所以按照上面的链接可以自己做一个prime-run的启动脚本. 但是关键问题在于对于ubuntu用户来说, 如果真的需要用显卡正儿八经打游戏直接切换到nvidia模式不香吗…</p>
<p>当然如果像这样启动发现并不理想, 明明用独显启动了为什么感觉性能这么差? 这个时候一种可能的解决方法就是去nvidia的setting里面看一眼, 在PowerMizer里面可以调节preferred mode. 这里一般是调到auto, 然后auto默认是adaptive, 把这里改成performance mode之后再看看混合模式下的N卡的性能.</p>
<p><s>我现在已经十分确信当时在manjaro下面mc运行着效果不行是这里就开了个adaptive mode, manjaro下面好像没有prime-select这样完全切到独显模式, 似乎默认就是混合模式, 所以即使使用了prime-on之类的命令如果不开性能模式好像玩mc屏幕撕裂很严重, 应该是这样的, 但是也没有验证, 不知道撕裂是因为没有开性能模式(我也不记得当时开了性能模式没有)还是因为本身那个混合驱动就不好用.</s></p>
<p>注: 后来去manjaro底下实测了一下, 即使就是开性能模式也不能让画面不撕裂, 真的怪起来了. 虽然我心里面清楚这个问题最后肯定能解决, 我到处问了一下说是可以调参数什么的, 但是一个默认的配置连MC都画面撕裂我是不能接受的. 这也是我回ubuntu的一个重要原因, 那就是在manjaro下面的默认配置不能够发挥显卡的全部性能.</p>
<p>再注: 后来装上arch自己之后, 包括试用过arcolinux等arch更加纯正的发行版, manjaro显卡性能差问题首先是没有使用官方的驱动, 而是使用一种混合驱动. 对于那些使用了官方驱动MC却还是画面撕裂的人来说, 是特效混成器的问题, 想办法在KDE或者是其他桌面环境里面设置下面启动一些防撕裂的选项可以显著改善这个情况. 然后使用<code>optimus-manager</code>进行显卡切换. 我的评价是不如<code>prime-select</code>. 首先后者直接集成在ubuntu系统里面, 而且能够彻底地进行显卡切换并且省电, 然后前者却是GitHub提供的(还不是官方), 安装之后需要进行一些文件的配置改动, 而且配置不好经常弹窗说会造成额外的功耗(虽然我觉得不应该会这样, 还是没搞清楚这玩意什么原理).</p>
<p>最后呢, 在不同模式之间切换需要注销再进桌面, 但是关于混合模式下adaptive模式改成performance模式需不需要注销没有试过, 目测是不需要的.</p>
<p>那么在ubuntu下面笔记本双显卡切换还是非常好使, 对比pop_os(一个基于ubuntu的发行版?)在切换显卡的时候需要等更长时间, 还需要重启, 这个注销切换的方式还是方便得多. 对比manjaro默认的驱动配置没法切换, arch的依赖社区的软件进行显卡切换还有bug. 可以说如果是N卡笔记本的linux发行版几乎没有第二个选择, 除非想要放弃双显卡切换这个很帅的功能.</p>
<h1 id="软件相关问题和推荐"><a class="markdownIt-Anchor" href="#软件相关问题和推荐"></a> 软件相关问题和推荐</h1>
<h2 id="wps"><a class="markdownIt-Anchor" href="#wps"></a> wps</h2>
<p>wps在最开始会出现22.04没法进入的问题, 现在wps for linux放出了一个更新版本来修复这个问题. 但是字体还是缺就是了.  缺字体的话, 可以去Windows字体目录下面找到所有字体, 然后全部安装到ubuntu上面, 这样肯定不会出现缺字体的问题. 这也是基操了, 刷新字体缓存<code>fc-cache -fv</code>, 以这个命令作为关键词就能够查到一些批量安装字体的教程.</p>
<h2 id="netease-cloud-music-网易云音乐"><a class="markdownIt-Anchor" href="#netease-cloud-music-网易云音乐"></a> netease-cloud-music 网易云音乐</h2>
<p><strong>如果真的想要听歌, 也可以使用lxmusic, GitHub上的一个播放软件项目, 非常不错.</strong></p>
<p>其中需要说一句网易云音乐的事情, 即使是修复好了如果是笔记本上面还可能会出现: 1. 屏幕缩放太小根本看不清. 2. 登陆之后首页加载不出来.</p>
<p>对于非要使用网易云音乐的朋友也还有一个解决方案, 在启动器里面(以ubuntu作为例子). 一般ubuntu用户是通过”所有应用程序”来启动应用, 这个应用的启动方式实际上在<code>/usr/share/applications</code>里面, 进去可以看到很多desktop后缀的文件. 那么找到网易云音乐相关的文件, <a href="https://www.freesion.com/article/6842452116/">点此</a>, 就像这篇博客说的一样, 是可以的. Exec原来就是netease-cloud-music %U, 像文章里面那样给中间加上一些东西就可以实现强制的缩放.</p>
<p>但是其实有很多比网易云好用的听歌的替代品, 就比如<a href="https://github.com/Rocket1184/electron-netease-cloud-music">electron-netease-cloud-music</a>, 效果是非常不错的, 详情可以去它的github地址看看. 以下图片引自github的页面:</p>
<p><img src="https://user-images.githubusercontent.com/13914967/52464615-8cee9900-2bb6-11e9-8aa3-a74d8cf7bea5.png" alt="img" /></p>
<p>不过这个图片因为是github上面的所以加载估计很慢… 反正界面就是这样了.</p>
<p>想要运行需要额外装上electron, 主要是我对于npm这个包管理器不太熟悉, 所以如果只是想用音乐软件, <code>sudo npm install electron -g</code>应该就是可以的. (关于npm和nodejs的问题推荐看后面一栏有一个nvm的问题, 如果不使用nvm可能会出现全局安装带来的一系列权限bug, 后患无穷. nvm也是官方推荐的一个很好的解决方式)</p>
<h2 id="qq和替代品icalingua"><a class="markdownIt-Anchor" href="#qq和替代品icalingua"></a> <s>QQ和替代品icalingua++</s></h2>
<p><strong>注: 现在已经有了electron版本的QQ, 可以传文件了.</strong></p>
<p><strong>再注: electron版本的QQ极其不稳定, 加之icalingua++多次更新功能也完善了, 不失为一个好的选择.</strong></p>
<p>如果是不想用替代品, tencent官方有一个linux版本的QQ. 但是当时用着基本上天天闪退, 后来在2020年4月1号有一个更新的版本, 事实证明还是非常难用, 基本上一接消息就闪退.</p>
<p>icalingua++不管怎么样, 不谈好不好用, 起码能用. <a href="https://github.com/Icalingua-plus-plus/Icalingua-plus-plus/releases">icalingua的github</a>.</p>
<p>当然也有deepin-wine的解决方案, 这就多了, 但是我不喜欢这样.</p>
<h2 id="迅雷-xunlei"><a class="markdownIt-Anchor" href="#迅雷-xunlei"></a> 迅雷 xunlei</h2>
<p>虽然一般在用linux的人都有能力用一些”高级”一点的下载工具了, 但是有无脑的快速下载器为什么不用呢?</p>
<p>在aur的xunlei-bin里面的评论区, 有一个老哥提供了一个麒麟的deb包可以用<a href="http://archive.kylinos.cn/kylin/partner/pool/com.xunlei.download_1.0.0.1_amd64.deb">点此</a>, 那个aur提供的deb包需要deepin的验证没法用.</p>
<h2 id="欧路词典appimage无法使用"><a class="markdownIt-Anchor" href="#欧路词典appimage无法使用"></a> 欧路词典(appimage无法使用)</h2>
<p>非常经典的问题, 就是欧路词典的deb包安装之后没有办法正常启动. 其实问题也很简单, 命令行启动的话很明显就能看出来是缺少库文件, 但是我还是理解不了那个英文报错. 所以最后还是选了appimage格式的包来. 暂定在这里, 以后要是看见了别的地方出了解决方法就把那个方法贴过来.</p>
<p>这里也是一个非常经典的问题, 那就是appimage运行的时候提示缺少fuse, 如果你apt install的话(至少在ubuntu22.10上面)就一下子会卸载很多跟桌面相关的包, 我一直没有胆量尝试, 最坏的情况就是下次开机直接进不了桌面了, 直接黑屏.</p>
<p>正确的解决方法是这样: <a href="https://askubuntu.com/questions/1409496/how-to-install-safely-install-fuse-on-ubuntu-22-04">askubuntu</a>.</p>
<p>如果懒得点进去就省流:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libfuse2</span><br></pre></td></tr></table></figure>
<h2 id="更改系统的默认编辑软件"><a class="markdownIt-Anchor" href="#更改系统的默认编辑软件"></a> 更改系统的默认编辑软件</h2>
<p>nano个人认为没有vim好使. 提一嘴怎么更改默认的编辑软件, 所谓默认的编辑软件, 就是<code>/usr/bin/editor</code>这个是谁.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update-alternatives --config editor</span><br></pre></td></tr></table></figure>
<p>是有默认的工具来完成这件事情的.</p>
<h2 id="什么是打字重复键的延迟和速度"><a class="markdownIt-Anchor" href="#什么是打字重复键的延迟和速度"></a> 什么是打字重复键的延迟和速度</h2>
<p>也许很多人有这样的烦恼, 就是想要长按A键, 结果按了好久系统才出现一大长串A. 这个就是延迟, 就是按一个键被当成是长按之前给你的反应时间. 这个时间对于一些追求速度的人来讲还是要设置短一点, 不然突出表现就是vim里面长按J键到下一行之前需要有一段等待的时间.</p>
<p>在ubuntu下面这个是可以调的, 在设置&gt;辅助功能&gt;重复键里面把延迟调低一点就好了, 速度就是这个出重复字母的速度, 太快了hold不住, 调到合适位置就好.</p>
<p><strong>特别注意, 调之前最好记一下原来的位置, ubuntu的gnome桌面好像并没有恢复默认设置的按钮, 如果调乱了就很糟糕, 因为我强迫症必须调到原来的地方.</strong></p>
<h2 id="给ubuntu使用一个更好的终端"><a class="markdownIt-Anchor" href="#给ubuntu使用一个更好的终端"></a> 给ubuntu使用一个更好的终端</h2>
<p><strong>注: 后来已经转向使用wezterm, 这个终端自定义程度更加高, 而且更加现代化.</strong></p>
<p>使用过manjaro的同学都知道(假如你是安装的kde版本), 安装完了之后默认的终端模拟器很漂亮, 然后里面的shell提供一些很好的功能包括命令预测, git仓库状态显示之类的好用的功能. 那么在ubuntu上面其实也很好搞.</p>
<p>首先就是换一个终端模拟器, ubuntu默认的终端模拟器实在是不行. 注意, 那些只能的git功能包括命令预测是<strong>不需要终端模拟器的支持</strong>, 也就是假如ubuntu默认的终端你已经觉得足够好看就没必要再下新的. 但是实际情况是默认的终端没法方便地调字体, 假如最后装好的shell花里胡哨地显示了几个图案不是纯文字, 那么就会乱码. 所以建议还是换一个. 我这里使用的是terminator, 你也可以使用别的, 可以在网上搜哪个好看.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install terminator</span><br></pre></td></tr></table></figure>
<p>这是一个我认为的比较好的终端模拟器, 解决完这个问题就来解决shell的配置问题.</p>
<p>我这里还是选用的zsh, 毕竟比较成熟而且更主要的是基本上兼容bash的用法. 我最近也看见好多人选用fish之类的新shell, 但是我并不觉得有多好用, 而且因为有些写法和bash有差异, 设置为系统默认终端之后出问题的概率会增加.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>第一行是安装zsh本身, 如果仅仅是zsh也不是很好用.(没有高亮没有补全什么都没有)</p>
<p>第二行是安装zsh的一个插件管理框架oh my zsh. 这个命令有可能回过时, 建议还是去官网上面找:<a href="https://ohmyz.sh/#install">点击此</a></p>
<p>期间说要不要改成默认终端, 建议还是需要.</p>
<p>安装完了之后发现还是没有补全功能, 那是插件没有安装到位. 我这里推荐两个插件, 一个是自动检测当前输入的命令是否合法的插件, 如果命令不对整个命令会变成红色.</p>
<p>关于插件的安装参看此:<a href="https://zhuanlan.zhihu.com/p/346665734">ubuntu终端配置</a> <strong>考虑到文章的时效性, 在跟着做的时候最好清楚自己在做什么, 安装插件的时候如果有条件和精力可以直接去GitHub上面看这个怎么用而不是跟着文章, 包括oh-my-zsh的安装命令, 自己看自己现在的情况是最好的</strong>. 我把我需要的两个插件的命令粘贴下来(原文章的第二个命令有一些小问题). 对于这篇文章的其他部分我觉得还行, 就是设置默认终端那里命令搞麻烦了, 直接使用<code>sudo update-alternatives --config x-terminal-emulator</code>也还是很不错的, 主要是这样更加直观而且知道自己做了什么, 很清楚地能够看到现在默认终端以及各个终端模拟器所处于的模式. 我这里就把它选择成我刚刚安装好的新的终端模拟器.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>
<p>上面两个分别是自动补全命令插件和命令高亮插件. 其他的我不需要, 所以我的~/.zshrc相比上面的文章中会简单一些.</p>
<p>还是把zsh的配置搬上来作一个备份, 虽然说也没有配置什么. <strong>千万不要直接粘贴, 复制上来只是一个备份和参考.</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you come from bash you might have to change your $PATH.</span></span><br><span class="line"><span class="comment"># export PATH=$HOME/bin:/usr/local/bin:$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to your oh-my-zsh installation.</span></span><br><span class="line"><span class="built_in">export</span> ZSH=<span class="string">&quot;<span class="variable">$HOME</span>/.oh-my-zsh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set name of the theme to load --- if set to &quot;random&quot;, it will</span></span><br><span class="line"><span class="comment"># load a random theme each time oh-my-zsh is loaded, in which case,</span></span><br><span class="line"><span class="comment"># to know which specific one was loaded, run: echo $RANDOM_THEME</span></span><br><span class="line"><span class="comment"># See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;robbyrussell&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set list of themes to pick from when loading at random</span></span><br><span class="line"><span class="comment"># Setting this variable when ZSH_THEME=random will cause zsh to load</span></span><br><span class="line"><span class="comment"># a theme from this variable instead of looking in $ZSH/themes/</span></span><br><span class="line"><span class="comment"># If set to an empty array, this variable will have no effect.</span></span><br><span class="line"><span class="comment"># ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use case-sensitive completion.</span></span><br><span class="line"><span class="comment"># CASE_SENSITIVE=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use hyphen-insensitive completion.</span></span><br><span class="line"><span class="comment"># Case-sensitive completion must be off. _ and - will be interchangeable.</span></span><br><span class="line"><span class="comment"># HYPHEN_INSENSITIVE=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment one of the following lines to change the auto-update behavior</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; mode disabled  # disable automatic updates</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; mode auto      # update automatically without asking</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; mode reminder  # just remind me to update when it&#x27;s time</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to change how often to auto-update (in days).</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; frequency 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if pasting URLs and other text is messed up.</span></span><br><span class="line"><span class="comment"># DISABLE_MAGIC_FUNCTIONS=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable colors in ls.</span></span><br><span class="line"><span class="comment"># DISABLE_LS_COLORS=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable auto-setting terminal title.</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_TITLE=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to enable command auto-correction.</span></span><br><span class="line"><span class="comment"># ENABLE_CORRECTION=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to display red dots whilst waiting for completion.</span></span><br><span class="line"><span class="comment"># You can also set it to another string to have that shown instead of the default red dots.</span></span><br><span class="line"><span class="comment"># e.g. COMPLETION_WAITING_DOTS=&quot;%F&#123;yellow&#125;waiting...%f&quot;</span></span><br><span class="line"><span class="comment"># Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)</span></span><br><span class="line"><span class="comment"># COMPLETION_WAITING_DOTS=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to disable marking untracked files</span></span><br><span class="line"><span class="comment"># under VCS as dirty. This makes repository status check for large repositories</span></span><br><span class="line"><span class="comment"># much, much faster.</span></span><br><span class="line"><span class="comment"># DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to change the command execution time</span></span><br><span class="line"><span class="comment"># stamp shown in the history command output.</span></span><br><span class="line"><span class="comment"># You can set one of the optional three formats:</span></span><br><span class="line"><span class="comment"># &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;</span></span><br><span class="line"><span class="comment"># or set a custom format using the strftime function format specifications,</span></span><br><span class="line"><span class="comment"># see &#x27;man strftime&#x27; for details.</span></span><br><span class="line"><span class="comment"># HIST_STAMPS=&quot;mm/dd/yyyy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which plugins would you like to load?</span></span><br><span class="line"><span class="comment"># Standard plugins can be found in $ZSH/plugins/</span></span><br><span class="line"><span class="comment"># Custom plugins may be added to $ZSH_CUSTOM/plugins/</span></span><br><span class="line"><span class="comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="comment"># Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">    git</span><br><span class="line">    extract</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># export MANPATH=&quot;/usr/local/man:$MANPATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You may need to manually set your language environment</span></span><br><span class="line"><span class="comment"># export LANG=en_US.UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preferred editor for local and remote sessions</span></span><br><span class="line"><span class="comment"># if [[ -n $SSH_CONNECTION ]]; then</span></span><br><span class="line"><span class="comment">#   export EDITOR=&#x27;vim&#x27;</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line"><span class="comment">#   export EDITOR=&#x27;mvim&#x27;</span></span><br><span class="line"><span class="comment"># fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compilation flags</span></span><br><span class="line"><span class="comment"># export ARCHFLAGS=&quot;-arch x86_64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span></span><br><span class="line"><span class="comment"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span></span><br><span class="line"><span class="comment"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span></span><br><span class="line"><span class="comment"># For a full list of active aliases, run `alias`.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example aliases</span></span><br><span class="line"><span class="comment"># alias zshconfig=&quot;mate ~/.zshrc&quot;</span></span><br><span class="line"><span class="comment"># alias ohmyzsh=&quot;mate ~/.oh-my-zsh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setopt</span> no_nomatch <span class="comment"># zsh里面无法使用bash的通配符* 这一行解决这个问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;lsd&#x27;</span> <span class="comment"># 自带的ls命令不好看 我使用lsd替代ls alias作用自搜</span></span><br><span class="line"><span class="built_in">alias</span> neofetch=<span class="string">&#x27;neofetch --disable cols&#x27;</span> <span class="comment"># neofetch有bug</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/liu/code/software_bin/bin <span class="comment"># 添加环境变量的形式</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/liu/.local/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/liu/.local/share/nvim/mason/bin</span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure>
<p>注意看我这里开启的插件和我下载的插件要对应.</p>
<p><strong>有一点需要注意, 在改变默认终端之后也就是运行了chsh这个命令之后, 最好还是重新启动一下系统.</strong></p>
<p>因为随着终端的改变, 很多默认的行为会改变. 比如说下文即将有的nvm, 因为是安装在家目录底下, 需要添加环境变量才能够正确地运行程序. 如果先完成zsh的改变之后重启, 此时默认终端就已经完全改变为zsh, 这样安装nvm的时候它会自动帮我们添加环境变量到<code>~/.zshrc</code>里面. (虽然这个问题也不是严重, 也很好解决, 我们自己动一下也行了, 重装一下也行了, 但是按照顺序, 一步一步来, 多重启可以解决很多麻烦)</p>
<h2 id="nodejs-和-npm使用nvm安装"><a class="markdownIt-Anchor" href="#nodejs-和-npm使用nvm安装"></a> nodejs 和 npm(使用nvm安装)</h2>
<p>因为本人很喜欢lunarvim这个配置(<strong>好, 现在我已经润helix了, 任何vim终将绳之以法!</strong>), 而且包括这hexo博客也需要nodejs和npm. 但是问题在于Ubuntu自带的包管理器里面的nodejs和npm版本比较低, 因为我是22.04养老(现在是22.10了), checkhealth的时候还经常说版本不符合要求.</p>
<p>使用nvm来管理nodejs和npm, 不仅可以在Ubuntu上面获得最新的版本, 还可以解决<code>npm install -g &lt;package_name&gt;</code>root权限的问题. 其实很多人在npm全局安装包的时候解决方式比较简单粗暴, 都是直接root权限解决. 之所以需要root权限, 是因为默认情况下的npm全局安装是把这个package安装到根目录下面的位置. 但是实际上这样非常不好:</p>
<p><a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">解决npm -g install的权限问题</a></p>
<p>在官方文档里面是十分不推荐使用sudo权限粗暴地解决问题的.</p>
<p><a href="https://github.com/nvm-sh/nvm">nvm的GitHub</a></p>
<p>nvm的思想很像这个conda. 安装的所有的包都会在<code>~/.nvm</code>下面. 全局安装也不需要root权限了(因为此时全局安装需要修改的目录也不再是root目录下面的某个位置)</p>
<h2 id="tldr-too-long-dont-read"><a class="markdownIt-Anchor" href="#tldr-too-long-dont-read"></a> tldr: too long don’t read</h2>
<p>虽然说manual手册和<code>--help</code>是很多人喜欢看的文档<s>喜欢个鬼, 谁喜欢看manual手册啊</s>, 但是有没有更好的办法用一种更加简洁的方式来知道一个命令的使用方法呢?</p>
<p>就拿tar来举例子, 我只是想要知道怎么解压tar.gz, 我只是一时不小心忘记了, 再去翻全英文的man手册是否有点失礼了呢?</p>
<p><a href="https://github.com/tldr-pages/tldr">tldr的github</a></p>
<p>tldr是一个以很简洁的形式展现命令的工具, 比如说对于tar, 我运行tldr的结果是这样:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">归档实用程序。</span><br><span class="line">  通常与压缩方法结合使用，例如 gzip 或 bzip2.</span><br><span class="line">  更多信息：&lt;https://www.gnu.org/software/tar&gt;.</span><br><span class="line"></span><br><span class="line">  创建存档并将其写入文件：</span><br><span class="line"></span><br><span class="line">      tar cf target.tar file1 file2 file3</span><br><span class="line"></span><br><span class="line">  创建一个 gzip 压缩文件并将其写入文件：</span><br><span class="line"></span><br><span class="line">      tar czf target.tar.gz file1 file2 file3</span><br><span class="line"></span><br><span class="line">  使用相对路径从目录创建一个 gzip 压缩文件：</span><br><span class="line"></span><br><span class="line">      tar czf target.tar.gz --directory=path/to/directory .</span><br><span class="line"></span><br><span class="line">  详细地将（压缩的）存档文件提取到当前目录中：</span><br><span class="line"></span><br><span class="line">      tar xvf source.tar[.gz|.bz2|.xz]</span><br><span class="line"></span><br><span class="line">  将（压缩的）存档文件解压缩到目标目录中：</span><br><span class="line"></span><br><span class="line">      tar xf source.tar[.gz|.bz2|.xz] --directory=directory</span><br><span class="line"></span><br><span class="line">  创建压缩存档并将其写入文件，使用存档后缀确定压缩程序：</span><br><span class="line"></span><br><span class="line">      tar caf target.tar.xz file1 file2 file3</span><br><span class="line"></span><br><span class="line">  详细列出 tar 文件的内容：</span><br><span class="line"></span><br><span class="line">      tar tvf source.tar</span><br><span class="line"></span><br><span class="line">  从存档文件中提取与模式匹配的文件：</span><br><span class="line"></span><br><span class="line">      tar xf source.tar --wildcards <span class="string">&quot;*.html&quot;</span></span><br></pre></td></tr></table></figure>
<p>非常的诱人了. (在博客里面看还是不一样, 博客里面代码块高亮差, 自己用的时候是彩色的很舒服)</p>
<p><strong>但是新版本tldr更新之后, 每次查命令的时候, 都需要和服务器同步</strong>.(虽然说明明可以通过cache的形式本地查找, 不知道为啥即使<code>tldr --update</code>了之后还是没法查看)</p>
<p>推荐另一个用rust完成的tldr项目: <a href="https://github.com/dbrgn/tealdeer">dbrgn/tealdeer</a></p>
<p><strong>这个版本的tldr是可以离线使用的</strong>, 一次更新基本上就可以使用了. 只需要一次更新魔法上网即可. (对于我Ubuntu来讲, 我只直接下载了二进制版本, 然后把下载好的可执行文件重命名为tldr, 然后加到环境变量里面, 当做tldr使用即可.)</p>
<h2 id="可能改善笔记本电脑的续航问题"><a class="markdownIt-Anchor" href="#可能改善笔记本电脑的续航问题"></a> 可能改善笔记本电脑的续航问题</h2>
<p>推荐一个叫做tlp的软件, 先安装, 然后<code>sudo tlp start</code>, 之后可能会没法启动, <strong>根据屏幕上的提示来输入接下来的命令</strong>. 我也不知道是不是能够改善续航问题. 输入<code>sudo tlp-stat</code>可以看现在tlp是不是在运行以及状态. 据说启动之后就不用管了, 后台会自动省电, 听着真玄乎.</p>
<h2 id="nala-一个稍微美丽的apt前端"><a class="markdownIt-Anchor" href="#nala-一个稍微美丽的apt前端"></a> nala: 一个稍微美丽的apt前端</h2>
<p>我必须说明, 其实这种所谓美化并不符合linux的哲学. 如非必要其实没有必要依赖很多外来的, 给系统复杂性增加了. 折腾终端模拟器搭配zsh已经很复杂了. 如果输出不美观其实也可以使用grep之类的工具, 也是非常不错.</p>
<p><a href="https://gitlab.com/volian/nala">gitlab: nala</a></p>
<p>还有一个参考资料是一个B站Up的视频, <a href="https://www.bilibili.com/video/BV1mT41127fa?share_source=copy_web">点此跳转</a></p>
<p>apt比较不美观, 输出信息比较多, 占用很多屏幕信息. 而且新安装和卸载的软件包不能够明确地用颜色标出来. 当然不美观不是nala好用的主要理由, 最重要的理由是它可以保存nala安装包包括upgrade更新的信息, 从而实现回滚(虽然你timeshift回滚也很好用但是…). 颜色的加入确实让易用性要强一些.</p>
<p>但是美中不足的是, 这里的许多消息都被限制在框里面, 滚动了之后就走了, 让人看不到完整的信息.(不过那些信息也许没那么重要, 假如有error或者是其他信息说不定会着重显示呢.)</p>
<h2 id="clang编译找不到头文件"><a class="markdownIt-Anchor" href="#clang编译找不到头文件"></a> clang编译找不到头文件</h2>
<p>我建议别碰Clang, 我之前碰clang是因为我想使用clangd补全, 我以为必须要clang, 谁知道这两个根本一点关系都没有.</p>
<p>这个问题也是一个经常见的问题: <a href="https://askubuntu.com/questions/1441844/todays-ubuntu-22-04-updates-seem-to-break-clang-compiler/1441954#1441954">askubuntu</a></p>
<p>这个问题居然是新出现的, 我最开始不知道为啥没有这个问题. 原因在于clang自己并不带有头文件, 需要使用c++的标准库, 或者说得更清楚一些需要libstdc++这个东西.</p>
<p>但是很多时候会出现问题. 比如<code>gcc-12</code>这个包已经出来, 而且很有可能已经安装到你电脑上. 但是和<code>gcc-12</code>相对应 的</p>
<p>我在安装g++的时候连带着安装了<code>libstdc++-11-dev</code>, 但是clang仍然找不到头文件, 最后加装了<code>libstdc++-12-dev</code>才解决问题. 本质上这是ubuntu可以安装多个版本导致的(这本来是一个优点结果却成了缺点).</p>
<p>所以第一个解决方法就是, 只留一个. 也就是卸载<code>cpp-12</code>这个包. 连带的<code>libstdc++-12-dev</code>也跟着卸载(免得占空间). 标准为g++还有gcc的可执行文件只留下一个(去<code>/usr/bin</code>下面找). 然后<code>clang -v</code>输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  bin clang -v   </span><br><span class="line">Ubuntu clang version 14.0.0-1ubuntu1</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /usr/bin</span><br><span class="line">Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/11</span><br><span class="line">Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/11</span><br><span class="line">Candidate multilib: .;@m64</span><br><span class="line">Selected multilib: .;@m64</span><br></pre></td></tr></table></figure>
<p>这里的<code>Selected GCC installation</code>只有一行, 没有出现多意义的情况, 此时clang可以正常使用, 默认使用libstdc++, 而且是现在唯一的libstdc++, 也是现在gcc的libstdc++.</p>
<p>当然你也可以补全, 假如说<code>clang -v</code>出现了多意义的情况, 你只需要找到<code>clang -v</code>里面显示的最新的gcc的版本是什么, 然后安装对应版本的<code>libstdc++-xx-dev</code>即可. 但是这样有点浪费空间, 而且奇怪的是<code>gcc-12</code>已经可以用但是ubuntu官方安装<code>apt install gcc</code>的时候仍然默认安装版本11.3, 这说明官方推荐.(虽然说你也可以把这个gcc的链接改一下)</p>
<p><strong>第二个选择就是使用libc++.</strong> 其实在更多人的认识里面clang应该和libc++联系更加紧密. 但是在Linux上面clang的默认编译参数是使用libstdc++的, 比较奇怪. 同时也引出了上面这样的问题, 导致经常clang就用不了.</p>
<p><code>sudo apt install libc++-dev</code></p>
<p><code>sudo apt install libc++abi-dev</code></p>
<p>当然你在输命令的时候可能会发现有好多版本, 这种情况如果有特殊版本需求就两个都装匹配版本即可, 如果不知道哪个版本就像上面这样输入, 最后官方会有一个默认的版本安装.</p>
<p>只不过这个时候每次clang编译都需要加上<code>-stdlib=libc++</code>才行了, 因为这个时候我们相当于是放弃了libstdc++而使用libc++, 所以这样.</p>
<p>可见多版本既是好处, 也要多加注意, 不然也是坏处.</p>
<h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1>
<p>未完, 有时间接着写.</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>论解决问题的方法论</title>
    <url>/2022/11/10/%E8%AE%BA%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="发生什么事了"><a class="markdownIt-Anchor" href="#发生什么事了"></a> 发生什么事了</h1>
<p>故事还是得从几天前说起，看了O老师的一个关于排版的视频，我深受启发。</p>
<p><a href="https://www.bilibili.com/video/BV1GY411E7Jr?share_source=copy_web">一件吵了100多年的小事…… - oooooohmygosh</a></p>
<p>这个视频讲到了关于引号的问题，探讨了一下现在这一套标点符号系统是如何来的。提到的中文方引号让我很感兴趣，像这样：「」</p>
<span id="more"></span>
<p>当时我记在心里面，准备写一个文探讨一下markdown的排版。（正在被中文括号 英文引号 中文引号折磨中）后来没写成。</p>
<p>今天一个朋友问了我一个字符串的问题，好嘛，我回答完了去自己写的博客看看错了没，结果居然发现我博客上面写的笔记有数组越界的问题。就在我修改的过程中，看到了让强迫症无法容忍的一幕。</p>
<p><img src="https://pic.imgdb.cn/item/625aa64e239250f7c5020069.png" alt="img" /></p>
<p>上网搜索的时候发现这是一个小bug，官方有一个暂时的方法就是使用中文的方括号代替引号。（闭环了，我一下子就想到了OOOOO老师提出来的那个括号的问题）</p>
<p>好吧，这个markdown排版的问题最终我还是出现了，那么正好以此作为例子，探讨一下我解决问题的方法论。</p>
<h1 id="问题定位"><a class="markdownIt-Anchor" href="#问题定位"></a> 问题定位</h1>
<p>许多人一上来就直接上网搜索，这样确实没有问题。但是如果要更快地解决必须搜索地更加精准。这里使用hexo的next主题出现这样的问题，那是主题的锅还是hexo的问题呢？换用landscape主题之后发现这个问题还是存在，但是明显好很多。所以肯定使用next主题的人更容易提出这个问题。所以搜索关键词里面加上一个next就更容易搜出来想要的结果。</p>
<h1 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> 搜索</h1>
<p>假如对html还有css还有hexo什么相关的东西比较了解，那估计自己就能解决。但是我对于这几个东西并没有充分的了解，所以对于我来说还是搜索比较好。</p>
<p>那该如何搜索呢？网上已经有很多帖子描述了如何善用搜索引擎，像只搜出来文件啊，站内搜索啊等等，但是对于一般的这种问题怎么解决？</p>
<p>应该在搜索框里面输入：hexo博客next主题中文引号渲染错误怎么办 吗？</p>
<p>这样是不好的，这样百度把这句话当做一个元素来搜索这句话在哪篇文章里面出现……</p>
<p>不过这个情况也能搜出来，只能说搜索引擎比较聪明。但是我一直觉得这样搜不好。</p>
<p>如果是我，我会这样搜：hexo next 引号</p>
<p>然后找到符合自己问题描述的帖子就好了。我找到了这个：<a href="https://liuqinh2s.github.io/blog/2019/04/15/hexo%E6%8A%8A%E8%8B%B1%E6%96%87%E5%BC%95%E5%8F%B7%E6%B8%B2%E6%9F%93%E6%88%90%E4%B8%AD%E6%96%87%E5%BC%95%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98/">解决问题的帖子</a></p>
<h1 id="信息来源"><a class="markdownIt-Anchor" href="#信息来源"></a> 信息来源</h1>
<p>然后就是判断信息来源是否可靠，主要是平时经常在csdn上面看到描述非常贴合自己问题的，但是实际上却非常水，给出来的答案没有什么用。但是上面说的那个帖子确确实实真的是跟我的问题一模一样，但是这个帖子如何并不重要，更重要的是它给出来github上面这个问题的参考链接，然后其中有一个问题完完全全跟我遇到的问题一模一样！这启示了我，因为用的next主题本来就是github里面的一个项目，以后就应该直接搜索github的issue，能得到更加官方的解释。搜bing也是一种绕远路。。</p>
<p>但是只是理想情况，在next的主题仓库里面的issue下面搜索引号似乎效果并没有那么好。。搜索引号出来一些issue，最后一个才是我想要的，还得花点时间一个一个找。不过要是能找到官方的解决方法，那也是值得的。</p>
<h1 id="解决问题"><a class="markdownIt-Anchor" href="#解决问题"></a> 解决问题</h1>
<p>既然已经找到了一个issue有项目的参与者亲自回复，那肯定就不用去看开头那个博客了。里面有这样一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 适用默认的 hexo-renderer-marked</span><br><span class="line">marked:</span><br><span class="line">-  smartypants: true</span><br><span class="line">+  smartypants: false</span><br></pre></td></tr></table></figure>
<p>这里面的加号减号是更改的意思。那就是某一个配置文件里面会有smartypants这一项。我第一反应就是hexo根目录下的config文件（因为哪一个主题都存在问题所以不用管主题里面的配置文件，跟它没关系了），发现并没有这一项。（没有也不能添加啊，这里面说更改肯定是原来已经有这一项了）</p>
<p>那就疯狂地找这个配置文件呗，首先已经缩小了范围，肯定不在主题文件夹里面。</p>
<p>然后在~/node_modules下找到了一个叫做hexo-renderer-marked的文件夹，这和上面的那个完全一样。我打开却没有发现任何配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/blog/node_modules/hexo-renderer-marked  ls                                     </span><br><span class="line"></span><br><span class="line">index.js  lib  LICENSE  package.json  README.md</span><br></pre></td></tr></table></figure>
<p>遇到这种情况，<a href="http://xn--README-9f2j034eslf4z3ek7a4jm059a4id.md">首先看对应项目的README.md</a>，这是官方文档。</p>
<p>然后文档里面这么说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can configure this plugin in `_config.yml`.</span><br><span class="line"></span><br><span class="line">``` yaml</span><br><span class="line">marked:</span><br><span class="line">  gfm: true</span><br><span class="line">  pedantic: false</span><br><span class="line">  breaks: true</span><br><span class="line">  smartLists: true</span><br><span class="line">  smartypants: true</span><br><span class="line">  quotes: &#x27;“”‘’&#x27;</span><br><span class="line">  modifyAnchors: 0</span><br><span class="line">  anchorAlias: false</span><br><span class="line">  autolink: true</span><br><span class="line">  mangle: true</span><br><span class="line">  sanitizeUrl: false</span><br><span class="line">  dompurify: false,</span><br><span class="line">  headerIds: true</span><br><span class="line">  lazyload: false</span><br><span class="line">  prependRoot: false</span><br><span class="line">  postAsset: false</span><br><span class="line">  external_link:</span><br><span class="line">    enable: false</span><br><span class="line">    exclude: []</span><br><span class="line">    nofollow: false</span><br><span class="line">  disableNunjucks: false</span><br><span class="line">  descriptionLists: true</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>我第一反应是，你的这个文件在哪里？是指那个configyml？</p>
<p>考虑到这是一个默认的hexo的渲染器，这里面的很有可能是指根目录下的configyml。那试一下。将上面这一段直接复制到configyml里面。</p>
<p>再按照上面的方法把smartypants改成false。然后问题解决 了？</p>
<p>好嘛，结果引号是正常了，我的\标记用不了，简而言之就是没有阅读全文按钮了，所有的文案全都在首页上展示。。。。</p>
<p>但是既然只能这么解决，那就必须换一个方法来控制文章截断，\的方法已经无法使用了。</p>
<p>我这里选择的是description方法控制截断。每一篇文章在写的时候就是用description描述，这样的话就可以截断了，引号也总算正常了。。。</p>
<h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1>
<p>真的是处处充满妥协。。。因为我对这些知识知之甚少，为了解决这个渲染问题放弃了使用\这么好用的标记符。如果我对于相关知识了解我也许可以自己去动一下，但是现在只能暂时这样了。。。实际上对于markdown渲染我一直非常好奇，有的时候渲染非常规整，有的时候空格会异常。。等到以后也许有时间还是得稍微了解一下网页相关知识，即使将来并不从事前端工作。</p>
<h1 id="后后记"><a class="markdownIt-Anchor" href="#后后记"></a> 后后记</h1>
<p>别在那里用你那什么Next主题了, 今天仙贝展示了一个matery主题, 真的是功能该有的都有了, 好像也没发现有什么bug, 属于是连根拔起地解决问题了.</p>
]]></content>
      <tags>
        <tag>touchfish</tag>
        <tag>空虚地思考</tag>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>我的大学生活</title>
    <url>/2022/11/10/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<p>就很突然，我刚刚进入大学，本来我设想的大学生活是当一个宅，像隐士那样的……</p>
<span id="more"></span>
<p>然后每天玩累了就学，学累了就玩。偶尔上网找找乐子。。</p>
<p>然后我还在家里面的时候就听说俄罗斯和乌克兰打起来了。阿哲。。。</p>
<p>其实我以前对西方文化并没有很抵触，因为喜欢计算机嘛，好多大人物还有技术还有工具都是西方的。所以原先看到有人有一些比较激进的论调就会很反感，觉得还没有到那种程度。</p>
<p>然而就是这次战争，让我们看见了西方的力量。这里单单是指掌控全球舆论的力量，是一种实力带来的话语权。</p>
<p>知名网站GitHub、node的官网、react的网站还有pytorch，这里面的有些我比较熟悉，有些我在用…… 都在官网打出了声援乌克兰的旗号。</p>
<p>然后，截止写这个评论的时候，俄罗斯已经经历了几千项制裁，具体我也懒得查，这不是我想表达的重点。</p>
<p>我想表达的重点是，原来我之前喜欢用的，听说很好的，各种产品网站互联网工具居然都不是自己的，随时都有“反叛”的可能。（原谅我用词过重，因为就目前而言这些人和组织只是声援了乌克兰）</p>
<p>就在前几日看到的新闻，npm的一个包的作者添加了恶意代码，加入是俄罗斯的IP下载了这个包，这个包会尝试覆盖根目录下的文件，简单来说就是搞破坏。</p>
<p>人在一生中会不会有这样一个时刻，在这个时刻之前，一切都风平浪静，非常和谐，然后马上就进入到一种截然不同的境地？俄罗斯恐怕就经受了这样一种情况。我也感觉非常魔幻，好像一瞬间，全世界都与俄罗斯为敌了。世界上的许多声音都站向乌克兰一方。</p>
<p>当我还没有从这个世界性的大事走出来的时候，我所在的吉林又爆发了疫情。我现在身在寝室楼无法出门。说实话就我个人来讲，我上网课真的是没有好好听，真的是完全没有把网课当回事。生活作息完全乱掉了还没有学到什么东西。真的是非常混乱。</p>
<p>一切的种种都和我预想的大学生活有差别。我并没有像预想的那样在大学好好学习，完全都不玩。我曾经以为我对计算机很有兴趣（现在也是），但是我现在发现这个兴趣还没有大到能够克服娱乐项目的程度。。。。</p>
<p>非常有幸在短暂的一生中还能经历几次大事，先是疫情后是俄乌战争。无论种种这也是长大的过程吧。</p>
<p>还是希望在以后的日子里能够在计算机这一条道路上坚定地走下去。最近网上多有劝退计算机的留言，什么越来越卷了之类。但是无论如何我希望我能记住，我学计算机主要的原因不是赚钱（当然赚钱也重要），而是我一开始就被它所吸引。从小学开始接触计算机，到长大一点为了如何让英雄联盟流畅地运行在电脑上绞尽脑汁，再到高二因为百度上的一句玩笑话接触linux，再到高三初下定决心非计算机不读…… 直到现在有些时候因为一些manjaro的小bug焦头烂额。希望我会带着对计算机的热爱一直走下去。虽然说发生了很多事情。</p>
]]></content>
      <tags>
        <tag>touchfish</tag>
        <tag>空虚地思考</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习</title>
    <url>/2022/11/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这一个专栏以cprimer为主，记录一些C语言中需要注意的知识。大概能算是一篇读书笔记。每周一晚上的三节课一般都是用来看计算机专业书籍的，这个星期暂时定为cprimer，等到cprimer看得差不多了之后就来看《深入理解计算机操作系统》，着几本都是很好的书籍，当然还没有忘记《linux私房菜》。 <s>考古：基本上计划没完成 都鸽了 要不是有一天心血来潮估计这个都写不完了</s></p>
<span id="more"></span>
<p><strong>本文章提到的有关函数资料的引用绝大多数都来自菜鸟教程。</strong><br />
<a href="https://m.runoob.com/">菜鸟教程</a></p>
<h1 id="c语言中的宏"><a class="markdownIt-Anchor" href="#c语言中的宏"></a> C语言中的宏</h1>
<h2 id="stdout和stdin"><a class="markdownIt-Anchor" href="#stdout和stdin"></a> stdout和stdin</h2>
<p>如果用惯了文件操作，难免会觉得把屏幕和文件分开处理很麻烦。就是说将内容输出到屏幕上要使用printf和puts之类的函数，其实是把屏幕特殊化了。所以就定义了一个stdout的宏，可以将显示器当做文件来处理，促进了代码的整洁。stdin也是一样，这两个变量都是FILE类型的指针，只不过一个是键盘一个是显示屏，可以当做常规文件操作。</p>
<hr />
<h1 id="gcc编译器的过程"><a class="markdownIt-Anchor" href="#gcc编译器的过程"></a> GCC编译器的过程</h1>
<p>编译分为四步。</p>
<ol>
<li>预处理<br />
<code>gcc -E main.c -o main.i</code><br />
生成main.i的经过预处理的代码。<em>注意所有的步骤都可以通过-o指令来指定生成的文件名。</em></li>
<li>编译<br />
<code>gcc -S main.i -o main.s</code></li>
<li>汇编<br />
<code>gcc -c main.s -o main.o</code></li>
<li>链接<br />
<code>gcc main.o -o main</code></li>
</ol>
<hr />
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-o</td>
<td>指定文件输出路径（一般用来重命名）</td>
</tr>
<tr>
<td style="text-align:left">-E</td>
<td>只进行预处理</td>
</tr>
<tr>
<td style="text-align:left">-S</td>
<td>进行预处理、编译</td>
</tr>
<tr>
<td style="text-align:left">-c</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td style="text-align:left">-I(大写i)</td>
<td>包含头文件路径</td>
</tr>
<tr>
<td style="text-align:left">-L</td>
<td>链接库文件路径</td>
</tr>
<tr>
<td style="text-align:left">-l</td>
<td>链接库文件</td>
</tr>
<tr>
<td style="text-align:left">-fPIC</td>
<td>生成位置无关代码</td>
</tr>
<tr>
<td style="text-align:left">-Wall</td>
<td>对代码所有可能有问题的地方发出警告</td>
</tr>
<tr>
<td style="text-align:left">-g</td>
<td>调试信息（如果需要调试必须勾这个）</td>
</tr>
<tr>
<td style="text-align:left">-w</td>
<td>不显示所有警告</td>
</tr>
</tbody>
</table>
<p>假如我写好了一个C文件，叫main.c，可以使用-v参数来查看详细的编译过程。输入gcc main.c -v。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">使用内建 specs。</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/lto-wrapper</span><br><span class="line">目标：x86_64-pc-linux-gnu</span><br><span class="line">配置为：/build/gcc/src/gcc/configure --enable- languages=c,c++,ada,fortran,go,lto,objc,obj-c++,d --enable-bootstrap --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-werror --with-build-config=bootstrap-lto --enable-link-serialization=1 gdc_include_dir=/usr/include/dlang/gdc</span><br><span class="line">线程模型：posix</span><br><span class="line">Supported LTO compression algorithms: zlib zstd</span><br><span class="line">gcc 版本 11.2.0 (GCC) </span><br><span class="line"></span><br><span class="line">//从此开始编译 上面都是显示配置？ 里面写满了默认的配置参数 注意到下面的有一串路径后面跟上cc1 cc1就是负责预处理和编译</span><br><span class="line"></span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27; &#x27;-dumpdir&#x27; &#x27;a-&#x27;</span><br><span class="line"> /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/cc1 -quiet -v main.c -quiet -dumpdir a- -dumpbase main.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -o /tmp/ccpxXxA0.s</span><br><span class="line">GNU C17 (GCC) 版本 11.2.0 (x86_64-pc-linux-gnu)</span><br><span class="line">        由 GNU C 版本 11.2.0 编译，GMP 版本 6.2.1，MPFR 版本 4.1.0-p13，MPC 版本 1.2.1，isl 版本 isl-0.24-GMP</span><br><span class="line"></span><br><span class="line">GGC 准则：--param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">忽略不存在的目录“/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../x86_64-pc-linux-gnu/include”</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include <span class="string">&quot;...&quot;</span> 搜索从这里开始：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;...&gt; 搜索从这里开始：</span></span><br><span class="line"> /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/include-fixed</span><br><span class="line"> /usr/include</span><br><span class="line">搜索列表结束。</span><br><span class="line">GNU C17 (GCC) 版本 11.2.0 (x86_64-pc-linux-gnu)</span><br><span class="line">        由 GNU C 版本 11.2.0 编译，GMP 版本 6.2.1，MPFR 版本 4.1.0-p13，MPC 版本 1.2.1，isl 版本 isl-0.24-GMP</span><br><span class="line"></span><br><span class="line">//下面的as就是用来汇编的 将汇编码后缀.s转变为后缀.o的机械码 注意参数顺序 因为有了-o选项 是 as -o 新路径 源文件.s</span><br><span class="line"></span><br><span class="line">GGC 准则：--param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">Compiler executable checksum: 65a5ec6b673b24273c0fdde359680a16</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27; &#x27;-dumpdir&#x27; &#x27;a-&#x27;</span><br><span class="line"> as -v --64 -o /tmp/ccyInjqL.o /tmp/ccpxXxA0.s</span><br><span class="line">GNU assembler version 2.38 (x86_64-pc-linux-gnu) using BFD version (GNU Binutils) 2.38</span><br><span class="line">COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/../../../:/lib/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27; &#x27;-dumpdir&#x27; &#x27;a.&#x27;</span><br><span class="line"></span><br><span class="line">//这下面就是cllect2了 用处是链接</span><br><span class="line"></span><br><span class="line">/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/lto-wrapper -plugin-opt=-fresolution=/tmp/cclMPHvr.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/crtbeginS.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/../../.. /tmp/ccyInjqL.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../lib/crtn.o</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=x86-64&#x27; &#x27;-dumpdir&#x27; &#x27;a.&#x27;</span><br></pre></td></tr></table></figure>
<p>里面信息很多，也没必要看。总之可以发现cc1，as和collect2是实际起作用的命令。正因为如此gcc的英文名字叫GNU Compiler Collection，是一个Collection（套件），理应由几部分组成。</p>
<h1 id="c语言中的预处理器"><a class="markdownIt-Anchor" href="#c语言中的预处理器"></a> C语言中的预处理器</h1>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">define</td>
<td style="text-align:left">定义宏</td>
</tr>
<tr>
<td style="text-align:center">include</td>
<td style="text-align:left">包含一个头文件</td>
</tr>
<tr>
<td style="text-align:center">undef</td>
<td style="text-align:left">取消已经定义的宏</td>
</tr>
<tr>
<td style="text-align:center">ifdef</td>
<td style="text-align:left">如果宏已经定义就返回真</td>
</tr>
<tr>
<td style="text-align:center">ifndef</td>
<td style="text-align:left">如果宏没有定义就返回真</td>
</tr>
<tr>
<td style="text-align:center">if</td>
<td style="text-align:left">给定条件为真就执行以下代码</td>
</tr>
<tr>
<td style="text-align:center">else</td>
<td style="text-align:left">同上</td>
</tr>
<tr>
<td style="text-align:center">elif</td>
<td style="text-align:left">如果前面的if不为真就这个为真</td>
</tr>
<tr>
<td style="text-align:center">endif</td>
<td style="text-align:left">结束一个#if和#else的模块</td>
</tr>
<tr>
<td style="text-align:center">error</td>
<td style="text-align:left">遇到标准错误的时候输出错误消息</td>
</tr>
<tr>
<td style="text-align:center">progma</td>
<td style="text-align:left">使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody>
</table>
<p><strong>记得预处理器需要加#符号，这里因为markdown语法的影响就没有再额外加了hhhhh。</strong></p>
<h1 id="stdlibh"><a class="markdownIt-Anchor" href="#stdlibh"></a> stdlib.h</h1>
<p>记录一下那些stdlib里面的好用函数</p>
<p>这是两个在标准函数库里面的函数。分别表示quick sort和binary search。（快速排序、二分查找）</p>
<h2 id="qsort"><a class="markdownIt-Anchor" href="#qsort"></a> qsort</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-qsort.html">菜鸟教程qsort</a></p>
<p>函数原型：<br />
<code>void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></p>
<p>参数</p>
<ul>
<li><strong>base</strong> — 指向要排序的数组的第一个元素的指针。</li>
<li><strong>nitems</strong> — 由 base 指向的数组中元素的个数。</li>
<li><strong>size</strong> — 数组中每个元素的大小，以字节为单位。</li>
<li><strong>compar</strong> — 用来比较两个元素的函数。（学了C++之后再看这是个函数指针）</li>
</ul>
<p>具体使用时，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//首先要包括这个标准函数库</span></span></span><br><span class="line"><span class="comment">//假如这里对array[8]=&#123;1, 2, 5, 8, 7, 4, 6, 2&#125;进行排序</span></span><br><span class="line"><span class="comment">//void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//要比较的是整数所以要转换成整数指针</span></span><br><span class="line">    <span class="type">int</span>* pa= (<span class="type">int</span>*)a;</span><br><span class="line">    <span class="type">int</span>* pb= (<span class="type">int</span>*)b;</span><br><span class="line">    <span class="comment">//因为要比较的是整数所以转换成整数指针。注意要比较什么就转换成什么样的指针</span></span><br><span class="line">    <span class="type">int</span> num1 = *pa;</span><br><span class="line">    <span class="type">int</span> num2 = *pb; <span class="comment">//求出pa和pb两个指针指向的值</span></span><br><span class="line">    <span class="comment">//一定注意这里面 如果是想正向排序 就要求a和b指向的大小和返回值正负一致</span></span><br><span class="line">    <span class="keyword">if</span>(num1-num2&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//假如想反向排序 则让返回值和a b大小异号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">8</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    qsort(<span class="built_in">array</span>, <span class="number">8</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序输出12245678</span></span><br></pre></td></tr></table></figure>
<p>这段代码能让排序进行。</p>
<h2 id="bsearch"><a class="markdownIt-Anchor" href="#bsearch"></a> bsearch()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-bsearch.html">bsearch</a></p>
<p>函数原型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *))</span><br></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li><strong>key</strong> — 指向要查找的元素的指针，类型转换为 void*。</li>
<li><strong>base</strong> — 指向进行查找的数组的第一个对象的指针，类型转换为 void*。</li>
<li><strong>nitems</strong> — base 所指向的数组中元素的个数。</li>
<li><strong>size</strong> — 数组中每个元素的大小，以字节为单位。</li>
<li><strong>compar</strong> — 用来比较两个元素的函数。</li>
</ul>
<p>但是注意，bsearch只能返回一个指向对应值的指针（好吧其实你自己还要强制转化）。如果有多个元素符合，<strong>bsearch没有定义返回哪一个</strong>。</p>
<p>通过cmp函数的不同当然还可以搜索是否有比制定目标大1的元素，还有各种规则等等。这些都是 在比较函数里面更改。</p>
<h2 id="atoi"><a class="markdownIt-Anchor" href="#atoi"></a> atoi()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-atoi.html">atoi</a><br />
<code>int atoi(const char *str)</code></p>
<ul>
<li>作用：将str所指向的一个字符串转换成一个int类型的整数。</li>
<li>参数：str—-要转换成整数的字符串。</li>
<li>自然是返回那个整数，如果转换失败那么返回零。</li>
</ul>
<p>跟atoi一个系列的还有atof，atol和atoll。分别是float，long和longlong。</p>
<hr />
<h1 id="stdioh中的常用的文件操作"><a class="markdownIt-Anchor" href="#stdioh中的常用的文件操作"></a> stdio.h中的常用的文件操作</h1>
<p>这一个模块来记录一下stdio.h这个头文件里面关于文件操作的常用函数。然后摘录菜鸟教程里面的内容，对必要内容加以注释。</p>
<h2 id="fopen"><a class="markdownIt-Anchor" href="#fopen"></a> fopen()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-fopen.html">fopen</a><br />
<code>FILE *fopen(const char *filename, const char *mode)</code><br />
作用：<br />
使用指定的mode打开指定的文件。<br />
参数说明：<br />
filename是要打开文件的名字。<br />
mode是一个c字符串，决定打开这个文件的模式。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>打开一个用于读取的文件，该文件必须存在</td>
</tr>
<tr>
<td>w</td>
<td>创建一个用于写入的空文件，如果文件名字重复则清零</td>
</tr>
<tr>
<td>a</td>
<td>追加一个文件，写操作向文件末尾增加数据，不存在则创建</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个用于更新的文件可读取可写入，文件必须存在</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个用于读写的空文件，文件必须存在</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个用于读取和追加的文件</td>
</tr>
</tbody>
</table>
<p>返回值：<br />
返回一个FILE类型的指针（如果成功打开文件的话）。否则返回空指针。</p>
<h2 id="fclose"><a class="markdownIt-Anchor" href="#fclose"></a> fclose()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-fclose.html">fclose</a><br />
<code>int fclose(FILE *stream)</code><br />
作用：<br />
关闭文件stream，刷新所有的缓冲区。<br />
参数说明：<br />
stream是一个FILE类型的文件指针。<br />
返回值：<br />
如果stream成功关闭，返回0。关闭失败，返回EOF。</p>
<h2 id="ftell"><a class="markdownIt-Anchor" href="#ftell"></a> ftell()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-ftell.html">ftell</a><br />
<code>long int ftell(FILE *stream)</code><br />
作用：<br />
返回给定流stream的当前文件位置。<br />
参数说明：略。<br />
返回值：<br />
返回位置表示符号的当前值。如果出现错误就返回-1L。</p>
<h2 id="remove"><a class="markdownIt-Anchor" href="#remove"></a> remove()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-remove.html">remove</a><br />
<code>int remove(const char *filename)</code><br />
作用：<br />
删除文件。<br />
参数说明：<br />
文件名。<br />
返回值：<br />
成功删除返回0，发生错误返回-1。</p>
<h2 id="rename"><a class="markdownIt-Anchor" href="#rename"></a> rename()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-rename.html">rename</a><br />
<code>int rename(const char *old_filename, const char *new_filename)</code><br />
使用方法不谈了。如果重命名成功，那么返回0，否则返回-1。</p>
<h2 id="fprintf"><a class="markdownIt-Anchor" href="#fprintf"></a> fprintf()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-fprintf.html">fprintf</a><br />
<code>int fprintf(FILE *stream, const char *format, ...)</code><br />
作用：<br />
发送格式化输出到流stream中。（stream是一个文件指针）</p>
<p>参数：<br />
一个是stream文件指针，另一个是c字符串。这个字符串和printf里面的c字符串是同一个格式，是可以带有格式化说明符号的。</p>
<p>我的说明：<br />
可以说这个fprintf连同fscanf一同构成了大多数对文件的操作。对于一些基本的情况使用fprintf而不是fwrite，fwrite设计二进制写入，比较复杂。<s>我没看懂bushi</s></p>
<h2 id="fscanf"><a class="markdownIt-Anchor" href="#fscanf"></a> fscanf()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-fscanf.html">fscanf</a><br />
<code>int fscanf(FILE *stream, const char *format, ...)</code><br />
作用：<br />
从流stream读取格式化输入。<s>这里因为C语言就把打开的文件看做流式文件，意思就是从文件读取输入。原先的scanf是从标准输入输出读取输入，（相当于stdin也被看作是一个文件了！！）不知道我的一点猜想对不对。就是把键盘等输入设备输入的内容也看做流式文件。</s></p>
<p>参数：<br />
一个文件指针好说。另外的是标识符。</p>
<p>例子：<br />
看下面一段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char str1[10], str2[10], str3[10];</span><br><span class="line">   int year;</span><br><span class="line">   FILE * fp;</span><br><span class="line"></span><br><span class="line">   fp = fopen (&quot;file.txt&quot;, &quot;w+&quot;);</span><br><span class="line">   fputs(&quot;We are in 2014&quot;, fp);</span><br><span class="line">   </span><br><span class="line">   rewind(fp);</span><br><span class="line">   fscanf(fp, &quot;%s %s %s %d&quot;, str1, str2, str3, &amp;year); //注意这一行！</span><br><span class="line">   </span><br><span class="line">   printf(&quot;Read String1 |%s|\n&quot;, str1 );</span><br><span class="line">   printf(&quot;Read String2 |%s|\n&quot;, str2 );</span><br><span class="line">   printf(&quot;Read String3 |%s|\n&quot;, str3 );</span><br><span class="line">   printf(&quot;Read Integer |%d|\n&quot;, year );</span><br><span class="line"></span><br><span class="line">   fclose(fp);</span><br><span class="line">   </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个里面fscanf的用法就很标准。从fp这个文件指针所指的文件里面按照%s %s %s %d读取数据然后存入到了后面的指针里面，完成了从数据库到内存的转换。</p>
<p>返回值：<br />
如果成功，该函数返回成功匹配和赋值的个数。如果到达<strong>文件末尾</strong>或发生读错误，则返回 EOF。</p>
<p>我的说明：<br />
feof()函数同样有检测到达末尾的效果，区别在于feof()函数仅仅是观测，而fscanf是实际读取，读取不到才会报EOF。</p>
<h2 id="feof"><a class="markdownIt-Anchor" href="#feof"></a> feof()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-feof.html">feof</a><br />
<code>int feof(FILE *stream)</code><br />
作用：<br />
测试给定流文件的文件结束标识符。</p>
<p>参数：<br />
一个FILE类型的指针。</p>
<p>返回值：<br />
如果说这个流文件结束了，就返回真（非零值），否则返回0。</p>
<p>我的说明：<br />
这个比较常用，用来检测文件是否到达结尾。这里检测结尾是说现在这个流文件中指针是不是在结尾，许多对于文件操作的函数可以控制流文件指针的移动，这个是检测当前指针的位置。所以经常看见和循环连用，经常都是只要不到结尾就继续读取之类。但是这个函数的效果使用fscanf的返回值检测也能达到。</p>
<h2 id="fgets"><a class="markdownIt-Anchor" href="#fgets"></a> fgets()</h2>
<p><a href="https://www.runoob.com/cprogramming/c-function-fgets.html">fgets</a><br />
<code>char *fgets(char *str, int n, FILE *stream)</code><br />
作用：<br />
从制定的流文件读取一行，储存到str所指向的字符串里面。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<p>参数：<br />
str是一个指向数组的指针。<br />
n是一个要读取的最大字符数。<br />
stream是一个FILE的流文件指针。</p>
<p>返回值：<br />
返回值是一个字符指针。假如成功地写入了str指针，那么返回值也还是这个str。假如到达文件末尾或者没有读取到任何字符或者说发生了错误，返回空指针NULL。</p>
<p>这个常用来替换gets()，这个函数以后要少用。以后的标准会越来越限制使用gets。这个如何代替在第十一章gets函数缓冲区溢出问题的时候再说。</p>
<hr />
<h1 id="提供的分析字符函数"><a class="markdownIt-Anchor" href="#提供的分析字符函数"></a> 提供的分析字符函数</h1>
<p><a href="https://www.runoob.com/cprogramming/c-standard-library-ctype-h.html">菜鸟教程 ctype.h</a></p>
<p>在学习cpp的时候曾经下断言凡是c开头的头文件好多都是从c继承下来的用于cpp的全新函数库。这个还是比较特别，ctype.h是C语言里面有的。</p>
<p>在这一段代码里面就使用了isspace函数来判断这一个字符是不是空格。（话说这么简单的操作还需要引用函数吗。。。。<s>其实空格还比较简单，但是像判断大写字母这些函数都是自己写起来很麻烦的，所以这个函数库还是比较好用的</s>）</p>
<h1 id="第三章-数据和c"><a class="markdownIt-Anchor" href="#第三章-数据和c"></a> 第三章 数据和C</h1>
<p>这一章比较简单，注意<strong>字</strong>的概念。</p>
<p>字对于不同的机器是不一样的。硬件层面来看就是内存条的宽度。多少位计算机字长就是多少位。</p>
<p>c语言中，声明和赋值对于一个变量来说不同。声明的时候只是仅仅创建了内存空间，内存空间里面的值是随机的。</p>
<h2 id="整数的打印"><a class="markdownIt-Anchor" href="#整数的打印"></a> 整数的打印</h2>
<p>在使用 printf 的时候，可以用不同的进制来打印。<br />
<strong>使用 %o 打印八进制数字，使用 %x 打印十六进制数字。若是要带前缀的话，（例如一般显示八进制数字的话前面就要带一个 0 ，显示十六进制数字的话前面就要带一个 0x ）就在百分号和字母之间加一个 # 。例如 %#o 和 %#x 。<s>当然如果是 %#X 就是会显示大写的 X，出现 0X 而不是 0x。（花里胡哨的知识增加了！</s></strong></p>
<h2 id="整数的类型"><a class="markdownIt-Anchor" href="#整数的类型"></a> 整数的类型</h2>
<p>int 本身普遍的话是占 4 个字节。（32bit）范围大概是正负21亿左右。</p>
<p>short int 一般占十六位。</p>
<p>long long int 一般占64位。</p>
<p>无符号数字无非就是范围是对应的两倍。unsigned long long int 和 unsigned int。</p>
<p>short 一般不用，不在乎那一点空间。一般llint用的比较多。在使用llint的时候的格式转换符需要注意。</p>
<p>一般不使用 long int，因为历史原因 long int 在我的机器上看来和int没有区别！</p>
<p>long long 或者说 long long int 需要使用 lld 的转换符号。</p>
<p>对于unsigned的就需要使用 %u，假如是表示最大的正数像 unsigned long long 就使用 %llu 作为转换符号。</p>
<h2 id="非打印字符查询"><a class="markdownIt-Anchor" href="#非打印字符查询"></a> 非打印字符查询</h2>
<table>
<thead>
<tr>
<th style="text-align:center">转移序列</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\a</td>
<td style="text-align:center">警报</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">退格</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">水平制表符</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:center">垂直制表符</td>
</tr>
</tbody>
</table>
<h2 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区"></a> 缓冲区</h2>
<p>C语言规定，printf函数会把语句发送到缓冲区buffer里面，然后缓冲区里面的内容再被发送到屏幕上。</p>
<ol>
<li>当缓冲区满</li>
<li>遇到换行字符</li>
<li>需要输入</li>
</ol>
<p><strong>这三种情况就会刷新缓冲区</strong></p>
<p>这一点在linux环境下使用vscode配合gdb调试深有体会。假如说这里有一句<code>printf(&quot;linux vscode&quot;);</code> 因为后面没有加换行符，缓冲区没有满，所以不会刷新，也就是单步调试明明执行了却在终端里面看不到输出结果。VS调试好像就没有这个问题，推测是不停地刷新了缓冲区。</p>
<hr />
<h1 id="第四章-字符串和格式化输入输出"><a class="markdownIt-Anchor" href="#第四章-字符串和格式化输入输出"></a> 第四章 字符串和格式化输入/输出</h1>
<p>C语言没有专门的字符串类型来存储字符串，而是使用char类型的数组来存储字符串。如果使用scanf函数来读取字符串的话，像<code>scanf(&quot;%s&quot;, array);</code>，那array里面末尾会被自动补上’\0’，标志字符串的结束，所以\0也是字符串结束的标志。</p>
<p>字符使用’字符’，字符串使用”字符串”。</p>
<p><code>#define *** ***</code>后面不要加分号！这是一种预处理操作，是把前面的替换成后面的，这是预处理器完成的。</p>
<h2 id="sizeof和strlen"><a class="markdownIt-Anchor" href="#sizeof和strlen"></a> sizeof()和strlen()</h2>
<p><a href="https://www.runoob.com/w3cnote/strlen-and-sizeof.html">菜鸟教程</a><br />
我的评价是，说得好！</p>
<p>strlen会把接受的参数视为数组一样的，然后求从开始到’\0’的长度（但是不含\0）。</p>
<p>sizeof则是求它后面的东西的长度。在看的时候尤其注意，<code>sizeof(字符指针)</code>返回的是这个字符指针本身的大小！有意思的是在我的电脑上面**字符指针一个好像占8个字节。**也合理其实。</p>
<p>scanf和printf函数的使用</p>
<h2 id="函数原型和返回值"><a class="markdownIt-Anchor" href="#函数原型和返回值"></a> 函数原型和返回值</h2>
<p><code>int scanf(const char *format, ...)</code><br />
如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。<br />
<code>int printf(const char *format, ...)</code><br />
如果成功，则返回写入的字符总数，否则返回一个负数。</p>
<h2 id="格式化输出输入符号"><a class="markdownIt-Anchor" href="#格式化输出输入符号"></a> 格式化输出输入符号</h2>
<p>题外话这图片是在xfce桌面下面截的，换到kde了之后发现kde真的比这好看不知道多少。截自cprimer。</p>
<p><img src="https://pic.imgdb.cn/item/622608f35baa1a80ab88d858.png" alt="格式化打印符号" /></p>
<p>就以%d作为例子。%hd是用来输出short int类型的，%ld就是long int类型，%lld就是long long int类型。注意，这些都是有符号整型。如果是无符号就应当使用%u系列。（u就是unsigned int的意思）</p>
<p>浮点是%f一支，在printf double的量的时候，可以使用%f。但是在scanf的时候好像应该使用%lf。当然对应的还有%llf。</p>
<p>%p用来输出指针。打印一个指针？经过实际的尝试，发现打印出来是一个十六进制的数字，应该就是指针了。</p>
<h2 id="在输入输出函数中的使用"><a class="markdownIt-Anchor" href="#在输入输出函数中的使用"></a> *在输入输出函数中的使用</h2>
<p>假如想要以执行宽度打印数据，就可以考虑使用*。<br />
<code>printf(&quot;%*d&quot;, width, it);</code><br />
width就是打印的宽度。这样能够让输入输出更灵活了。</p>
<p>而在scanf这边，带有的*表示忽略这个输入。<br />
<code>scanf(&quot;%*d %*d %d&quot;, &amp;input);</code><br />
这条语句会接收三个输入，但是只会把这三个数最后的一个数字scanf到input变量里面。</p>
<p><strong>最后提醒，scanf不能够跳过空格，scanf在遇到空格的时候会中断。</strong></p>
<hr />
<h1 id="第五章-运算符-表达式和语句"><a class="markdownIt-Anchor" href="#第五章-运算符-表达式和语句"></a> 第五章 运算符、表达式和语句</h1>
<p>要点比较少。</p>
<ol>
<li>
<p>注意除号，除号两边如果都是整数，结果会被执行<em>整数截断</em>。</p>
</li>
<li>
<p>对于‘=’这种运算符，一般都是从左到右进行的。</p>
<blockquote>
<p>a = b = 3;<br />
这个式子应该这样理解：先把3这个值赋给b，然后b=3这个式子它的值和右侧是相等的，所以把这个整体的值也赋给a，导致复制操作完成之后，a，b全都是3。</p>
</blockquote>
</li>
</ol>
<p>这里关于整个式子的理解存疑，学了C++之后可能观点不一样。可能其实并不是这个式子的值，而是a=b=3的意思是把3的值赋给b，把b的值赋给a，不是什么式子的值的理解。（不过也都差不多就是了）</p>
<h2 id="更为生疏的运算符"><a class="markdownIt-Anchor" href="#更为生疏的运算符"></a> 更为生疏的运算符</h2>
<h3 id="sizeof操作和size_t类型"><a class="markdownIt-Anchor" href="#sizeof操作和size_t类型"></a> sizeof操作和size_t类型</h3>
<p>在将转换符的时候就有这么一回事。sizeof函数的作用是返回后面对象的大小（单位是字节）。那么首先这是一个无符号整数。出于可移植的考虑，定义了一个%zd来作为输出符号。因为是在不同平台上面再定义的，所以一定能保证%zd的读取和sizeof所输出的数据在栈中等长。</p>
<p>如果是使用%u，会害怕sizeof返回值是不是%lu的。如果使用%lu有可能会是后面的格式转换符在栈中读取的时候移位。。（这样的原因就是不同平台的编译器上面sizeof返回值的占用位数不确定。所以%zd还是非常好用︿(￣︶￣)︿）</p>
<h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> %运算符</h3>
<p>取余数的运算符号的负数情况。</p>
<p>第一个操作数如果是负数，那么取模一定是负数。第一个操作数是正数，那一定是正数。</p>
<h2 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h2>
<p>理论上来讲，式子一定要使用相同类型的变量。但是C语言比较智能，即使使用混合类型的式子也能够进行自动转换。</p>
<ol>
<li>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被转换成int。有必要会转换为范围更大的unsigned int。（在较早的C语言里面float在类型转换的时候会被转换为double，但是现在不是这样）。这些都是从小类型转换为较大类型，称为升级。</li>
<li>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。</li>
<li>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类 型没有列出，是因为它们已经被升级到int或unsigned int。</li>
<li>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类 型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一 种类型转换成更低级别的类型。</li>
</ol>
<p>一般来讲升级的话不会有什么影响，但是降级转换的时候有的时候有问题，需要注意。</p>
<hr />
<h1 id="第六章-c控制语句-循环"><a class="markdownIt-Anchor" href="#第六章-c控制语句-循环"></a> 第六章 C控制语句—-循环</h1>
<h2 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h2>
<p>尤其注意c风格的循环：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;x))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Input completed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码还是比较有意思的，运行之后，假如说读入的是一个整数，那么scanf就会返回1，因为scanf的返回值是赋值成功的数量。这样的话这个循环就会继续进行。</p>
<p>假如说输入的不是数字，比如说字母，函数甚至不会进入循环，会直接中断掉，不会打印任何结果。</p>
<p><s>但是不知道为什么输入小数的时候会打印一次目标语句，还是好奇怪。（但是打印之后就循环结束了）</s></p>
<p>此外在嵌套循环的时候一定要注意不能使循环的内外层互相干扰，最好使用不一样的循环控制条件。</p>
<h2 id="数组简介"><a class="markdownIt-Anchor" href="#数组简介"></a> 数组简介</h2>
<p>因为是数组简介，有价值的点比较少，只有两个：</p>
<ol>
<li>数组越界在编译的时候并不会检查。比如说数组只开了20个位置，里面出现了<code>array[20]=1;</code>等字样， <strong>为了编译速度考虑并不会检查</strong>。</li>
<li>区别字符串和数组就看末尾有没有空字符。</li>
</ol>
<hr />
<h1 id="第七章-c控制语句分支和跳转"><a class="markdownIt-Anchor" href="#第七章-c控制语句分支和跳转"></a> 第七章 C控制语句：分支和跳转</h1>
<h2 id="做一个统计单词数量的程序实践"><a class="markdownIt-Anchor" href="#做一个统计单词数量的程序实践"></a> 做一个统计单词数量的程序（实践）</h2>
<p>功能是统计单词的数量，计算字符数和行数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt; //为isspace()函数提供原型</span><br><span class="line">#include&lt;stdbool.h&gt; //为bool true false提供定义</span><br><span class="line"></span><br><span class="line">#define STOP &#x27;|&#x27;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    char prev; //读入的前一个字符</span><br><span class="line">    long n_chars=0L; //字符的数量</span><br><span class="line">    int n_lines;</span><br><span class="line">    int n_words;</span><br><span class="line">    int p_lines;</span><br><span class="line">    p_lines=n_lines=n_words=0;</span><br><span class="line">    bool inword=false;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Enter text to be analyzed (| to terminate):\n&quot;);</span><br><span class="line">    prev=&#x27;\n&#x27;;</span><br><span class="line">    while( ( c=getchar() ) != STOP)</span><br><span class="line">    &#123;</span><br><span class="line">        n_chars++;</span><br><span class="line">        if(c == &#x27;\n&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            n_lines++; //统计行</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if( !isspace(c) &amp;&amp; !inword )</span><br><span class="line">        &#123;</span><br><span class="line">            inword=true;</span><br><span class="line">            n_words++; //统计单词个数</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if( isspace(c) &amp;&amp; inword )</span><br><span class="line">            inword=false;</span><br><span class="line"></span><br><span class="line">        prev=c;</span><br><span class="line">    &#125;</span><br><span class="line">    if(prev != &#x27;\n&#x27;)</span><br><span class="line">        p_lines=1;</span><br><span class="line"></span><br><span class="line">    printf(&quot;characters =%ld, words = %d, lines = %d&quot;, n_chars, n_words, n_lines);</span><br><span class="line">    printf(&quot;\tpartial lines = %d&quot;, p_lines);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="认识条件运算符"><a class="markdownIt-Anchor" href="#认识条件运算符"></a> 认识条件运算符 ?:</h2>
<p>这是if-else语句的一种快捷的表达方式：<br />
<code>x = (y &lt; 0) ? -y : y;</code><br />
等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (y &lt; 0)</span><br><span class="line">	x = -y;</span><br><span class="line">else</span><br><span class="line">	x = y;</span><br></pre></td></tr></table></figure>
<p>总而言之，?:需要三个expression。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expression1 ? expression2 : expression3</span><br></pre></td></tr></table></figure>
<p>意思是，如果1为真，整个条件表达式（注意上面这整个是有一个值的，这整个称为一个条件表达式）的值是2的值，否则是3的值。</p>
<h1 id="第十一章-字符串和字符串函数"><a class="markdownIt-Anchor" href="#第十一章-字符串和字符串函数"></a> 第十一章 字符串和字符串函数</h1>
<h2 id="表示字符串和字符串io"><a class="markdownIt-Anchor" href="#表示字符串和字符串io"></a> 表示字符串和字符串I/O</h2>
<h3 id="字符串常量"><a class="markdownIt-Anchor" href="#字符串常量"></a> 字符串常量</h3>
<p>首先是定义字符串。使用双引号括起来的部分叫做字符串常量，有一个小技巧就是假如字符串包括双引号但是不想让字符串中止就要使用转义字符。<strong>当字符串常量储存在内存里面的时候编译器会自动在末尾加一个\0</strong>。</p>
<p><strong>字符串常量属于*静态类别*(static storage class)，意思是说在函数里面使用字符串常量的时候这个字符串只会被存储一次。</strong></p>
<p>字符串有可能使用指针指向首地址，也有可能使用字符数组来存储，一般就这里两种手段储存字符串。指针不谈，会不会有人在使用字符类型的数组的时候这样初始化？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char m1[7] = &#123;&#x27;w&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;a&#x27;, &#x27;y&#x27;, &#x27;?&#x27;, 0&#125;;</span><br></pre></td></tr></table></figure>
<p>首先着肯定是没问题的，是标准语法。但是实际上可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char m1[7] = &quot;whoay?&quot;;</span><br></pre></td></tr></table></figure>
<p>一定注意不要加大括号！直接使用双引号初始化。</p>
<p>当然更为聪明的人也许会这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char m1[] = &quot;whoay?&quot;;</span><br></pre></td></tr></table></figure>
<p>将数组留空，让编译器自动分配合理大小的数组空间，这样更加安全。</p>
<p>忽然发现这里有新特性，即使写成<code>const char m1[6] = &quot;whoay?&quot;;</code>再使用gcc的情况下不会报错，编译正常运行。就是0没有存进去而已。这就随缘了，假如内存里面有0那么打印就停止，没有就会往后面再打一点乱码。</p>
<hr />
<p>关于静态量和字符串常量之类的讨论下面的程序可以进一步理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//指针和数组和字符串常量</span><br><span class="line">#define MSG &quot;I&#x27;m special&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char ar[] = MSG;</span><br><span class="line">    const char *pt = MSG;</span><br><span class="line">    printf(&quot;address of \&quot;I&#x27;m special\&quot; : %p\n&quot;, &quot;I&#x27;m special&quot;);</span><br><span class="line">    printf(&quot;          address ar : %p\n&quot;, ar);</span><br><span class="line">    printf(&quot;          address of pt : %p\n&quot;, pt);</span><br><span class="line">    printf(&quot;          address of MSG : %p\n&quot;, MSG);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见，使用宏定义了一个字符串常量MSG=”I’m special”。然后让一个数组的值为它，再const了一个指针指向这个常量字符串。接着使用%p打印指针变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address of &quot;I&#x27;m special&quot; : 0x560db1ead008</span><br><span class="line">              address ar : 0x7ffd5b1d452c</span><br><span class="line">           address of pt : 0x560db1ead008</span><br><span class="line">          address of MSG : 0x560db1ead008</span><br></pre></td></tr></table></figure>
<p>直接贴我电脑上面的运行结果。从这个结果可以直观地说明几点：</p>
<ol>
<li>新建数组时，无论数组里面的值是不是字符串常量，一定会重新分配空间。</li>
<li>将一个字符串常量复制给指针之后，其他所有用到这个字符串的地方都会共用一个地址。编译器可以把多个相同的字符串常量合并来节省空间。这是编译器的智能的地方。</li>
<li>即使是同一个字符串常量在内存中也可能储存多次，像本例子中的数组。</li>
</ol>
<h2 id="数组和指针"><a class="markdownIt-Anchor" href="#数组和指针"></a> 数组和指针</h2>
<p>数组定义之后，数组名不能再动了。就我的理解来看一旦数组被定义，数组首地址就成了常量了。</p>
<p>指针也指向常量字符串，但是指向过后还是能改变它的值。</p>
<h2 id="指针和字符串"><a class="markdownIt-Anchor" href="#指针和字符串"></a> 指针和字符串</h2>
<p>字符串和指针的联系非常紧密，现在来看一个程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    const char * mesg = &quot;I love study!&quot;;</span><br><span class="line">    const char * copy;</span><br><span class="line">    </span><br><span class="line">    copy = mesg;</span><br><span class="line">    printf(&quot;%s\n&quot;, copy);</span><br><span class="line">    printf(&quot;mesg = %s, &amp;mesg = %p, value = %s\n&quot;, mesg, &amp;mesg, mesg);</span><br><span class="line">    printf(&quot;copy = %s, &amp;copy = %p, value = %s\n&quot;, copy, &amp;copy, copy);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">I love study!</span><br><span class="line">mesg = I love study!, &amp;mesg = 0x7ffeca443bf8, value = I love study!</span><br><span class="line">copy = I love study!, &amp;copy = 0x7ffeca443c00, value = I love study!</span><br></pre></td></tr></table></figure>
<p>运行结果是这样。合理。两个指针的位置不同，指向同一个字符串。</p>
<h2 id="危险的字符串空间分配问题"><a class="markdownIt-Anchor" href="#危险的字符串空间分配问题"></a> 危险的字符串空间分配问题</h2>
<p>看这样一个代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *name;</span><br><span class="line">scanf(&quot;%s&quot;, name);</span><br></pre></td></tr></table></figure>
<p>乍一看好像没有什么问题，但是假如编译的话就会发现编译器报错。（这里书本上面说的是编译的时候会报错，我这里的实际情况是编译过了，运行的时候segmentation fault）</p>
<p>这样写是危险的，不管能不能编译通过。因为一开始并没有告诉%s有多大，这样编译器不知道给这个留多大空间。假如输入的%s过大，空间没有留够，那个这个字符串就会顶掉这个程序在内存中的其他部分。</p>
<p>C语言的程序在执行的时候在内存里面都是有结构的，<s>这个等我看了深入理解计算机系统再说</s>，面对这种情况最好就用数组，就是数组不指定大小也不要用指针。</p>
<h2 id="gets函数的替代问题"><a class="markdownIt-Anchor" href="#gets函数的替代问题"></a> gets()函数的替代问题</h2>
<p>我是没想到本来准备在上面关于头文件编写的章节里面说这个问题，但是书上面刚好说了这个问题。</p>
<p>gets函数的危险性和上面举的例子是一样的，因为gets函数读入字符串不加节制，而且没有标明这个字符串到底多大，这样一旦输入某个字符串太长就会顶掉这个程序其他地方，又叫做缓冲区溢出*(buffer overflow)*，超出的字符串有可能会破坏程序。</p>
<p><strong>c11标准采取了非常严格的态度，这个函数将在c11标准被删除！</strong></p>
<p>方法是使用fgets函数代替：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *str=0;</span><br><span class="line">    gets(str);</span><br><span class="line">    fgets(str, 60, stdin); //这里面两个函数是等价的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧也不是完全等价，下面最多只能输入60个字符，也就是说加入你输入了70个字符，最终读到str里面的就只有60个。<strong>在推荐标准下不能无限制读入字符串</strong>，虽然看上去不合理但是这样确实安全一些。要是怕读不完数字就调大点。。。。</p>
<p><a href="https://www.runoob.com/cprogramming/c-function-fgets.html">fgets</a></p>
<p>还是贴上fgets的函数用法。</p>
<hr />
<p>随书还附加了一些字符串函数，这些字符串函数都可以在string.h中找到。（其实就许多C语言的题目都可以直接使用标准库中的函数解决，常见的像排序，字符串合并等等）</p>
<p><a href="https://www.runoob.com/cprogramming/c-standard-library-string-h.html">菜鸟教程sting.h</a></p>
<p>还有一部分和处理字符串有关的函数被放在stdlib里面，可以搜索str就能找到他们。</p>
<p><a href="https://www.runoob.com/cprogramming/c-standard-library-stdlib-h.html">菜鸟教程stdlib.h</a></p>
<p><s>赶快结束这一章吧，虽然知识点还有很多但是基本上对我来说用的很少，到时候再查</s></p>
<h1 id="第十二章-存储类别-链接和内存管理"><a class="markdownIt-Anchor" href="#第十二章-存储类别-链接和内存管理"></a> 第十二章 存储类别、链接和内存管理</h1>
<p>这个比较专业，逐章笔记。作用域, 存储期和链接是描述一个变量的三个角度.</p>
<h2 id="1211作用域"><a class="markdownIt-Anchor" href="#1211作用域"></a> 12.1.1作用域</h2>
<p>作用域是描述可以访问标识符的区域。一个C变量的作用域常见的有<strong>块作用域，函数作用域，函数原型作用域或者是文件作用域</strong>。</p>
<p><strong>块作用域</strong>是用花括号括起来的区域，函数中使用的局部变量都具有块作用域。</p>
<p><strong>函数作用域</strong>是用于goto语句的标签。（看不懂）</p>
<p><strong>函数原型作用域</strong>是从形参定义到函数原型声明结束。这里直接证明了函数原型里面变量的名字完全不影响定义。</p>
<p>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int function(int a, int b);</span><br><span class="line"></span><br><span class="line">int function(int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    return m+n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不用担心m还有n的混淆问题，因为到下面的时候函数已经完全不认识a和b了，a和b的作用域只在那个小括号里面。前面已经学到过函数声明仅仅只管类型，不管名字。</p>
<p><strong>文件作用域</strong>是当一个变量定义在函数外面时候的作用域，也叫做<strong>全局变量</strong>。这样的变量可以用于多个函数。</p>
<p>这里说的很好，有人说那另一个文件里面可不可以用呢？另一个文件里面一般写的不就是函数嘛，一句可以用于多个函数也暗示着不只这个文件的函数可以用。</p>
<h2 id="1212-链接"><a class="markdownIt-Anchor" href="#1212-链接"></a> 12.1.2 链接</h2>
<p>C变量有三个链接属性。<strong>外部链接、内部链接和无链接。</strong></p>
<p>凡是块作用域、函数作用域或者是函数原型作用域的变量都是无链接变量。</p>
<p>那么一个变量具有文件作用域，就看它有没有static声明，如果有就是内部链接，没有就是外部链接。</p>
<p>这里链接的概念是这个变量和其他文件之间的关系，因为只有具有文件作用域的变量才可以被其他文件使用，所以叫外部链接（可以供外部使用的变量）。加上static就是不让外部使用，就是内部链接变量。其他的不谈链接，因为无论如何都不会被外部文件使用。</p>
<h2 id="1213-存储期"><a class="markdownIt-Anchor" href="#1213-存储期"></a> 12.1.3 存储期</h2>
<p><strong>作用域和链接描述了标识符的可见性，存储期描述了变量的生存周期。</strong></p>
<p>C变量有四个存储期：</p>
<ol>
<li>静态存储期</li>
<li>线程存储期</li>
<li>自动存储期</li>
<li>动态分配存储期</li>
</ol>
<p>静态存储区的意思是，在程序运行的过程中变量一直存在。文件作用域变量都具有静态存储区。而无论其是内部链接还是外部链接。（那么针对文件作用域变量，static的作用仅仅是表明是内部链接还是外部链接）</p>
<p>线程存储区用于并发程序设计，巴拉巴拉巴拉~~</p>
<p>块作用域变量具有自动存储期。当程序进入块的时候，为块作用域的变量申请内存。结束之后就释放。变长数组稍有不同，它不像一般的块作用域变量是进入块开始到块结束，是声明到块结束。</p>
<p>在块作用域变量里面使用static关键字在后面有讨论。</p>
<h2 id="1214-自动变量"><a class="markdownIt-Anchor" href="#1214-自动变量"></a> 12.1.4 自动变量</h2>
<p>自动存储期，块作用域，无链接。</p>
<h2 id="1216-块作用域的静态变量"><a class="markdownIt-Anchor" href="#1216-块作用域的静态变量"></a> 12.1.6 块作用域的静态变量</h2>
<p>块作用域，无连接，静态存储区。可以看出来描述一个变量有很多方面, 首先就是作用于, 指的是在什么范围中能够访问这个变量, 再就是在内存里面的存储位置, 像是块作用域的静态变量(这里面的静态主要指的是在内存里面原地不动), 最经典的就是在函数里面定义一个静态的量, 每次调用函数结束之后就没法访问这个量了, 但是只要main函数不结束那么这个值就一直保存在内存里面, 下次再调用这个值还是保存下来了.</p>
<p>剩下的一些部分太繁琐了看不进~~~~(&gt;_&lt;)~~~~.</p>
<p>直接小结一下吧.</p>
<h2 id="127-小结"><a class="markdownIt-Anchor" href="#127-小结"></a> 12.7 小结</h2>
<p>对于一个变量, 从存储期, 作用域和链接表征三方面来考虑.</p>
<p>存储期是<strong>静态的, 自动的或者动态分配</strong>的. 静态变量存储期是从程序运行开始到结束, 变量一直存在在内存里面(这里面暂时不考虑能不能访问的问题), 自动存储期就是在进入变量定义所在块的时候分配内存, 离开的时候释放. 动态分配就是使用malloc和free来申请和释放的.</p>
<p>作用域是决定哪一部分可以访问这个数据. 是文件作用域, 块作用域. 在所有函数之外定义的变量具有文件作用域, 块内就是块作用域.</p>
<p>链接是一个变量能被外部文件访问的程度, 具有块作用域的变量一定是局部变量(不谈是内部链接还是外部链接), 只有文件作用域的变量才有可能是具有外部链接(这个时候才有可能是内部链接和外部链接).</p>
<h1 id="第十三章-文件的输入输出"><a class="markdownIt-Anchor" href="#第十三章-文件的输入输出"></a> 第十三章 文件的输入输出</h1>
<p>首先C提供两种模式, 文本模式和二进制模式. 前面的一些基本的知识都知道不记了.</p>
<p>getc比getchar更加完善, putc也比putchar更加完善, 事实上后面带char的两个函数是通过前面的函数来定义的. 这章感觉太难写笔记了不写了.</p>
<h1 id="第十五章-位操作"><a class="markdownIt-Anchor" href="#第十五章-位操作"></a> 第十五章 位操作</h1>
<h1 id="c中的按位运算符"><a class="markdownIt-Anchor" href="#c中的按位运算符"></a> C中的按位运算符</h1>
<p>~: 二进制反码(这里要注意是把操作的数字转成二进制了之后才有的看.)</p>
<p>&amp;: 按位与</p>
<p>|: 按位或</p>
<p>^: 按位异或</p>
<p>OK cprimer结束</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>C和C++</tag>
      </tags>
  </entry>
  <entry>
    <title>manjarokde的配置</title>
    <url>/2022/11/10/manjarokde%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>这是一篇关于manjaro-kde版本的配置。</p>
<p>其实一开始我是拒绝使用kde桌面的，因为上次kde装好了之后发现N卡驱动存在一点小问题。然而就在今天下午我的xfce桌面崩了，而且也不知道是怎么回事。。。</p>
<span id="more"></span>
<h1 id="联网换源"><a class="markdownIt-Anchor" href="#联网换源"></a> 联网换源</h1>
<p>这个永远都是第一步：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure>
<p>虽然manjaro添加archlinuxcn的源有风险，但是谁能拒绝新软件呢？这里还是使用阿里巴巴的开源镜像站：<a href="https://developer.aliyun.com/mirror/archlinuxcn?spm=a2c6h.13651102.0.0.3e221b111LkGYj">archlinuxcn-alibaba</a></p>
<p>注意安装完成之后还要安装archlinuxcn-keyring。</p>
<p>一切完成之后<code>sudo pacman -Syyu</code>。</p>
<h1 id="家目录和时间差异的问题"><a class="markdownIt-Anchor" href="#家目录和时间差异的问题"></a> 家目录和时间差异的问题</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xdg-user-dirs-gtk</span><br><span class="line">export LANG=en_US</span><br><span class="line">xdg-user-dirs-gtk-update</span><br></pre></td></tr></table></figure>
<p>上面是解决家目录的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo timedatectl set-local-rtc 1</span><br></pre></td></tr></table></figure>
<p>输入这个改好时间，然后回windows矫正就完事了。这个问题的根本原因就是协调世界时的问题。。</p>
<h1 id="软件安装"><a class="markdownIt-Anchor" href="#软件安装"></a> 软件安装</h1>
<ul>
<li>总命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S yay base-devel nodejs npm</span><br><span class="line">yay -S visual-studio-code-bin google-chrome neovim debtap timeshift neovim wemeet wechat-uos gdb icalingua++ wps-office-mui-zh-cn tlp obsidian gnome-keyring electron-netease-cloud-music qtcreator eclipse fcitx5-im fcitx5-rime rime-cloverpinyin</span><br></pre></td></tr></table></figure>
<p>有一说一我没想到居然不预装gdb，我是没想到。</p>
<p>eclipse和qt分别是java和QT C++的IDE，至于为什么不用idea，当然是学校的示范程序用的就是eclipse。（而且IDE并不影响编程技术）</p>
<h2 id="先解决输入法的问题"><a class="markdownIt-Anchor" href="#先解决输入法的问题"></a> 先解决输入法的问题</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S yay base-devel</span><br></pre></td></tr></table></figure>
<p>上面说的是一些最基本的打包工具的安装，在以后的安装软件的过程中很有可能会需要这些工具。</p>
<p>刚开始是使用的学长的方案，但是现在发现搜狗输入法还是泰拉。。</p>
<p><a href="https://zhuanlan.zhihu.com/p/114296129">manjarokde配置全攻略</a></p>
<p>很多情况下我都是参考的这个配置攻略，作者一直在更新我也很喜欢。现在是用rime输入法。这个输入法比较不好的地方是，它下载的时候完全是看github的心情。原来这里使用的是搜狗拼音，但是实际用下来感觉不是很好（首先就是响应速度上面感觉很慢。。）</p>
<p>其实刚刚配置出来的这个输入法不是很好用，因为词库比较差。。这个作者也写了一篇帖子，在刚刚的manjaro配置全攻略里面。作者甚至还保存了现成的词库文件，只需要解压到指定位置就能用。</p>
<p>这个输入法一个比较麻烦的点就是配置是通过配置文件解决的，不过这对于linux用户来讲，估计已经是家常便饭了。</p>
<h2 id="其他软件和让人觉得更舒服的配置"><a class="markdownIt-Anchor" href="#其他软件和让人觉得更舒服的配置"></a> 其他软件和让人觉得更舒服的配置</h2>
<p>其他软件其实也没有什么，需要什么就安装什么就完事了。就是有的软件需要配置值得一说：</p>
<h3 id="neovim"><a class="markdownIt-Anchor" href="#neovim"></a> neovim</h3>
<p>配置详细见<a href="https://gitee.com/oiaom/my_vim">my_vim</a>。</p>
<p><s>现在已经没有维护了</s></p>
<h3 id="vscode"><a class="markdownIt-Anchor" href="#vscode"></a> vscode</h3>
<p>安装之后（安装包的名字叫做visual-studio-code-bin），直接联网同步插件。manjarokde桌面我觉得比较适合编程的字体是一个叫做Noto Mono的字体。其实感觉很多方面已经赶得上微软雅黑和consola的混合字体了。而且由于是原装的字体，对于特殊符号包括emoji的支持显示好像稍微要好一些？当然这个字体还是有的时候不妥当，比如复制的复，给人一种短一截的感觉。所以使用思源黑体也是很好的选择。</p>
<p>然后是没法登录同步的问题，这个是没有安装gnome-keyring的缘故。</p>
<h3 id="显示缩放"><a class="markdownIt-Anchor" href="#显示缩放"></a> 显示缩放</h3>
<p>这个不要去改字体，这样效果很不好。正确的打开方式应该是在显示器设置里面设置缩放为150还是比较合适的。注意改完之后会自动分配一个dpi，不要动它！</p>
<h3 id="下载微信"><a class="markdownIt-Anchor" href="#下载微信"></a> 下载微信</h3>
<p>现在AUR里面比较好用的微信的包的名字叫做 com.tencent.weixin，目前来看还是挺好用的。</p>
<h3 id="typora"><a class="markdownIt-Anchor" href="#typora"></a> typora</h3>
<p>这个虽然有一个报叫做typora-free但是实际上不魔法上网根本不行，所以还好我存了一个typora的deb包。然后使用debtap进行一个安装，debtap还是好用滴！</p>
<h3 id="wps在150缩放下字体发虚问题"><a class="markdownIt-Anchor" href="#wps在150缩放下字体发虚问题"></a> WPS在150缩放下字体发虚问题</h3>
<p>这个很简单解决。</p>
<p><a href="https://aur.archlinux.org/packages/wps-office-mui-zh-cn">wps的aur</a></p>
<p>里面可以找到解决办法。他这个是直接修改了bin文件，我的方案是只是更改启动器。右键左下角的启动器，再每个关于wps的启动项命令前面加上<code>env QT_SCREEN_SCALE_FACTORS=1</code>。注意改完之后不要有多余的空格什么的，就这句话加上一个空格加上后面的命令。</p>
<p>例子wps文字的启动命令：<code>env QT_SCREEN_SCALE_FACTORS=1 /usr/bin/wps %U</code></p>
<p>我的评价是要不直接把wps2019这个总的删除了，像微软那样也是分着的。</p>
<h3 id="tlp记得启动"><a class="markdownIt-Anchor" href="#tlp记得启动"></a> tlp记得启动</h3>
<p><code>sudo tlp start</code>就完事了，如果这个命令不能正常使用，就按照提示输入命令。</p>
<h1 id="题外话"><a class="markdownIt-Anchor" href="#题外话"></a> 题外话</h1>
<p>和xfce版本相比，kde有什么不一样呢？</p>
<p>首先一点，那就是由于linux的极高的可配置性，即使当时安装的是xfce桌面想要配成kde桌面也还是非常容易的。所以这里仅仅是讨论两个桌面的预配置如何，不讨论自己配置的情况，毕竟要是真心喜欢kde的话xfce桌面的版本照样可以安装kde桌面这个包。</p>
<p>首先是字体，kde的默认字体对于中文的显示就已经非常不错了，我原来使用xfce版本的时候经常还要在网上使用consolas和雅黑的混合字体，但是桌面毕竟还是有一些bug，有的地方显示是我设置的字体，有的地方不是。</p>
<p>但是kde桌面的默认字体中文显示就非常优秀了。</p>
<p>再就是缩放，我在xfce版本更改缩放的时候总感觉缩放不是很统一。（跟个人太菜有很大关系）有的时候更改还是觉得缩放不是很合适。感觉大小有一些不协调。在kde版本下在显示器设置里面改成150缩放或者说是125缩放不仅字体显示会更加清晰，而且综合起来观感比较好，非常协调。</p>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>从头开始</title>
    <url>/2022/11/10/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>由于一次不小心的事故, 整个装有linux系统的盘没了. 究其原因还是我对这个叫做btrfs的文件系统还有timeshift的备份逻辑不是特别了解, 这次翻车了之后肯定没有下次了.</p>
<p>正好, 我早就看那个next的主题不爽了, 主要是经常撞衫. <s>好吧hexo主题少其实不管用什么基本上都有可能撞衫…</s></p>
<p>我还是很喜欢yilia主题的, 但是其实我上次在部署的时候好像遇到了一些问题, 但是这次我是对我自己有自信解决的.</p>
]]></content>
      <tags>
        <tag>touchfish</tag>
        <tag>原先网站崩了</tag>
      </tags>
  </entry>
</search>
