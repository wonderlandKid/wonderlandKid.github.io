<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://pic.imgdb.cn/item/66ab69ecd9c307b7e945ca17.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://pic.imgdb.cn/item/66ab69ecd9c307b7e945ca17.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wonderlandkid.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习STL是一个和艰难的过程, 但是里面的很多容器却只需要略微了解就能够使用. 这篇文章就来记录一下常见的容器及其使用.">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP中的container">
<meta property="og:url" content="http://wonderlandkid.github.io/2023/10/09/CPP%E4%B8%AD%E7%9A%84container/index.html">
<meta property="og:site_name" content="wonderlandKid的小窝">
<meta property="og:description" content="学习STL是一个和艰难的过程, 但是里面的很多容器却只需要略微了解就能够使用. 这篇文章就来记录一下常见的容器及其使用.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload.cppreference.com/mwiki/images/1/1b/range-begin-end.svg">
<meta property="og:image" content="https://upload.cppreference.com/mwiki/images/3/39/range-rbegin-rend.svg">
<meta property="og:image" content="https://pic.imgdb.cn/item/65274551c458853aefaf3969.png">
<meta property="article:published_time" content="2023-10-09T11:42:13.000Z">
<meta property="article:modified_time" content="2025-02-27T08:36:46.012Z">
<meta property="article:author" content="wonderlandKid">
<meta property="article:tag" content="study">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload.cppreference.com/mwiki/images/1/1b/range-begin-end.svg">


<link rel="canonical" href="http://wonderlandkid.github.io/2023/10/09/CPP%E4%B8%AD%E7%9A%84container/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://wonderlandkid.github.io/2023/10/09/CPP%E4%B8%AD%E7%9A%84container/","path":"2023/10/09/CPP中的container/","title":"CPP中的container"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CPP中的container | wonderlandKid的小窝</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">wonderlandKid的小窝</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-text"> 写在前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sequence-containers"><span class="nav-text"> Sequence containers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#arrayc11"><span class="nav-text"> array(C++11)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector"><span class="nav-text"> vector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#capacity-size-shrink_to_fit%E5%92%8Creserve"><span class="nav-text"> capacity(), size(), shrink_to_fit()和reserve()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor"><span class="nav-text"> constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#access"><span class="nav-text"> access</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iterators"><span class="nav-text"> iterators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#modifiers"><span class="nav-text"> modifiers</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque"><span class="nav-text"> deque</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#forward_listc11"><span class="nav-text"> forward_list(c++11)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list"><span class="nav-text"> list</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#remove%E5%92%8Cremove_if"><span class="nav-text"> remove()和remove_if()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#associative-containers"><span class="nav-text"> Associative containers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#set"><span class="nav-text"> set</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wonderlandKid"
      src="https://pic.imgdb.cn/item/66ab69ecd9c307b7e945ca17.png">
  <p class="site-author-name" itemprop="name">wonderlandKid</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wonderlandkid.github.io/2023/10/09/CPP%E4%B8%AD%E7%9A%84container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic.imgdb.cn/item/66ab69ecd9c307b7e945ca17.png">
      <meta itemprop="name" content="wonderlandKid">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wonderlandKid的小窝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CPP中的container | wonderlandKid的小窝">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CPP中的container
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-09 19:42:13" itemprop="dateCreated datePublished" datetime="2023-10-09T19:42:13+08:00">2023-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-27 16:36:46" itemprop="dateModified" datetime="2025-02-27T16:36:46+08:00">2025-02-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>学习STL是一个和艰难的过程, 但是里面的很多容器却只需要略微了解就能够使用. 这篇文章就来记录一下常见的容器及其使用. <span id="more"></span></p>
<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1>
<p>参考文章或者是推荐阅读: <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container">cpp中的container</a></p>
<p>在C++11之前, C++中有所谓的<code>sequence containers</code>和<code>associative containers</code>. sequence, 就像它的英文原意一样, 是表示一系列数据. 比如数组其实就是一系列数据. 下面我们先来看sequence container中的array, vector, deque, forward_list以及list.</p>
<p>本篇源代码摘自llvm项目的libcxx, libstdc++实在是太难看了.</p>
<h1 id="sequence-containers"><a class="markdownIt-Anchor" href="#sequence-containers"></a> Sequence containers</h1>
<h2 id="arrayc11"><a class="markdownIt-Anchor" href="#arrayc11"></a> array(C++11)</h2>
<p>array是C++11才加入的新容器, array实际上就是一个数组, 这个数组就是C语言里面的数组, 类似于<code>int a[3]</code>这样的. 不同点在于array对于数据的所有更加明确.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">array&lt;<span class="type">int</span>,3&gt; a;</span><br></pre></td></tr></table></figure>
<p>原来C风格的数组一直和指针混淆, C风格的数组在设计传参, 拷贝等多种操作的时候就很难说清楚. 现在a就是一个整体, 类型就是array&lt;int,3&gt;, 更加现代.</p>
<p>当然还有一个非常重要的功能就是提供了迭代器. 在C++的algorithm头文件里面提供的很多算法都是需要接受迭代器, 但是如果使用传统数组就没法使用, 比如常见的sort, for_each等等. 而array实现了类似于vector的begin(), end()等. 当然因为支持迭代器当然也支持ranged based for loop的遍历.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;i: a)&#123;</span><br><span class="line">	cout&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为只是一个普通的数组没什么好说的, 里面有一个比较关键就是在访问的时候可以使用at()或者是operator[], 当然这一点在后面其他sequence container的时候也是同样的. 那这样访问有什么好处呢? 好处就是可以抛出异常:</p>
<blockquote>
<p>Returns a reference to the element at specified location pos, with bounds checking.</p>
<p>If pos is not within the range of the container, an exception of type std::out_of_range is thrown.</p>
</blockquote>
<p>这也是为了让C++更加现代统一, 越界的时候抛出异常也能够给编程人员一些处理的空间.</p>
<h2 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h2>
<p>多看<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container/vector">cpprefer</a></p>
<p>这位更是非常的常用, vector也就是我们常说的动态数组, 我们可以不断地向一段连续的空间加入数据. 传统数组在存入数据之后就没有办法扩大了, 但是vector可以, 可以通过尾部插入的方法来向其中增加数据.(当然也有insert()实际上插入任何地方)</p>
<p>在时间复杂度方面:</p>
<blockquote>
<p>The complexity (efficiency) of common operations on vectors is as follows:</p>
<ul>
<li>Random access - constant 𝓞(1).</li>
<li>Insertion or removal of elements at the end - amortized constant 𝓞(1).</li>
<li>Insertion or removal of elements - linear in the distance to the end of the vector 𝓞(n).</li>
</ul>
</blockquote>
<p>可以看见从尾部插入或者是删除元素是很轻松, 时间复杂度是1, 而其他地方的insert和remove, 则正比于和尾部的距离.</p>
<p>下面我们看一下cppreference如何描述它的常见一些成员函数:</p>
<h3 id="capacity-size-shrink_to_fit和reserve"><a class="markdownIt-Anchor" href="#capacity-size-shrink_to_fit和reserve"></a> capacity(), size(), shrink_to_fit()和reserve()</h3>
<p>我想把这两个放在最前面来讲. vector既然被称为动态数组, 那首先是数组. 也就是空间是连续的, 不是不是在栈上连续而是堆上一片连续的空间. 那既然是连续的空间是怎么做到动态的呢? 原因就是capacity, 新建一个vector的时候都会有一个capacity, 即使里面没有任何元素. 看下面代码(代码测试环境是C++20 O2优化):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; test1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>可以看见capacity随着不断地插入元素是翻倍的, 而且capacity指的是最大容量, 即使pop了, capacity也不会变.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; test1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; test1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    test1.<span class="built_in">pop_back</span>();</span><br><span class="line">    test1.<span class="built_in">pop_back</span>();</span><br><span class="line">    test1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在size大小是%d, capacity大小是%d\n&quot;</span>, (<span class="type">int</span>)test1.<span class="built_in">size</span>(),</span><br><span class="line">           (<span class="type">int</span>)test1.<span class="built_in">capacity</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">现在size大小是0, capacity大小是4</span><br></pre></td></tr></table></figure>
<p>size是里面存储了多少个元素, capacity是vector实际占用的空间. 当超出capacity的时候会翻倍capacity, 并且找一块新的内存空间. 那这个过程是一个申请内存的过程, 这个时候的数组越大越耗时间.</p>
<p>在这个过程中经常会有一些错误产生, 一个常见的错误就是因为内存中出现数据转移, 必须保证迭代器的时效性. 当然也包括指针的时效性.</p>
<p>下面代码用到了data()成员函数, 详细可以看<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container/vector/data">cpprefer</a>, 无论如何就是获得底层内容的指针:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; test1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = test1.<span class="built_in">data</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问指针指向的第一个值%d\n&quot;</span>, *p);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    test1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问指针指向的第一个值%d\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问指针指向的第一个值1</span><br><span class="line">访问指针指向的第一个值1488999553</span><br></pre></td></tr></table></figure>
<p>造成这个错误的原因是vector已经转移走了, 不在原位置了. 是一个隐蔽的错误. 而且比较离谱的是g++并不会对此做任何提示. 不过使用g++自带的越界检查可以检查出来, 但是这并不是一个强制选项:</p>
<p><code>g++ -fsanitize=address -fno-omit-frame-pointer -O2 -g mytest.cpp</code></p>
<p>那么再来考虑reserve, 不是reverse! reserve是预留. 如果一开始就知道capacity是大概多少, 不就可以减少内存重分配的次数吗? 我可以<code>vec.reserve(20)</code>直接把capacity拉到20, 虽然size()还是0.</p>
<p>shrink_to_fit()就是将capacity缩小到size附近, 释放多余的空间.</p>
<p>所以这四个放在一起讲.</p>
<h3 id="constructor"><a class="markdownIt-Anchor" href="#constructor"></a> constructor</h3>
<p>下面来说说构造函数的问题.</p>
<p>下面只说一下常用的构造函数. 下面四个是比较常用的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">vector</span>( <span class="type">const</span> vector&amp; other );</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">( <span class="type">const</span> vector&amp; other )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动构造</span></span><br><span class="line"><span class="built_in">vector</span>( vector&amp;&amp; other );</span><br><span class="line"><span class="built_in">vector</span>( vector&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">( vector&amp;&amp; other )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空构造 默认</span></span><br><span class="line"><span class="built_in">vector</span>();</span><br><span class="line"><span class="built_in">vector</span>() <span class="built_in">noexcept</span>(<span class="built_in">noexcept</span>(<span class="built_in">Allocator</span>()));</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(Allocator()))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count个value</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">( size_type count,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> T&amp; value = T(),</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;</span><br><span class="line"><span class="built_in">vector</span>( size_type count,</span><br><span class="line">                 <span class="type">const</span> T&amp; value,</span><br><span class="line">                 <span class="type">const</span> Allocator&amp; alloc = <span class="built_in">Allocator</span>() );</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">( size_type count,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器初始化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="title">vector</span><span class="params">( InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">vector</span><span class="params">( InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;</span><br></pre></td></tr></table></figure>
<p>空构造函数和拷贝不必多说, 移动构造就是要接受一个右值, 通过将参数的所有数据移动给要构造的对象来完成. 这是C++11一个很重要的话题. 可以了解一下C++11的右值引用.</p>
<p>然后下一个很常用的就是用n个x来初始化.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">test1</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// test1 = [1,1,1,...1](100个)</span></span><br></pre></td></tr></table></figure>
<p>值得一提的是C++11引入了所谓的List-initialization初始化方法, 简称大括号初始化. 如果想要初始化vector为1 2 3 4也可以这样写:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; test1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上是用了另一个不怎么常见的vector初始化函数. 一定不要混淆:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">test1</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 100个1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; test2&#123;<span class="number">100</span>, <span class="number">1</span>&#125;; <span class="comment">// 大小为2 分别是100和1</span></span><br></pre></td></tr></table></figure>
<p>最后还有迭代器初始化, 比如想要拷贝vec1的所有元素也可以:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(vec1.begin(), vec1.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p>反正只要是迭代器类型就可以, 迭代器本身也可以任意移动, 可以拷贝某一个区间也能够做到.</p>
<p>这里可以进一步体会到, 迭代器是STL的一个重要组成部分. 它起到了结合算法和容器的作用, 不知道有没有注意到这里并没有限定迭代器的来历, 也就是说, List的迭代器能否用于vec的构造函数呢? 答案是肯定的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; lst1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(lst1.begin(), lst1.end())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;i : vec1) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这就是比指针优越的地方, 迭代器就像是胶水一样连接着整个STL.</p>
<h3 id="access"><a class="markdownIt-Anchor" href="#access"></a> access</h3>
<p>下面来看访问vector的成员函数.</p>
<p>data()成员函数已经展现过作用了, 在上面可以看到可以通过传统C指针访问数据. 当然也是很危险的.</p>
<p>下面来看at和operator[].</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; vec1[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec1[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这显然是错误的, 首先这个vec1最多只有三个数字, 这个时候访问下标为3就是显然越界了, 我这边输出是0. 可以看见capacity甚至都是3! 也就是这一片空间根本就不是vector! cpprefer如是说:</p>
<blockquote>
<p>Returns a reference to the element at specified location pos. No bounds checking is performed.</p>
</blockquote>
<p>也就是不知不觉就越界了. 那么at就有作用了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; vec1.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec1.<span class="built_in">at</span>(<span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span><br><span class="line">  what():  vector::_M_range_check: __n (which is 3) &gt;= this-&gt;size() (which is 3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不仅报出了越界<code>std::out_of_range</code>, 还报出更多有用的信息, size是3, 你下标也是3. 虽然没有报出具体的行数, 但是也是比原来能够正常编译运行好多了.</p>
<p>在reference的access界面, 还有front()和back()两个方法用于访问最前面的数据和最后面的数据, 就没有什么别的注意点.</p>
<h3 id="iterators"><a class="markdownIt-Anchor" href="#iterators"></a> iterators</h3>
<p>成员函数省略了括号!</p>
<p>begin, cbegin, end, cend, 四个成员函数返回迭代器. begin就是开始迭代器, end就是结尾迭代器, 注意左闭右开, 也就是begin返回的迭代器是指向头元素的, 而end指向的却是尾元素还要往后一位, 没有元素.</p>
<p>偷一个refer的图.<br />
<img src="https://upload.cppreference.com/mwiki/images/1/1b/range-begin-end.svg" alt="" /></p>
<p>c开头就是const.</p>
<p>然后还有rbegin, rend, crbegin, crend等迭代器. 就是反过来迭代.</p>
<p><img src="https://upload.cppreference.com/mwiki/images/3/39/range-rbegin-rend.svg" alt="" /></p>
<p>再偷一个图.</p>
<h3 id="modifiers"><a class="markdownIt-Anchor" href="#modifiers"></a> modifiers</h3>
<p>clear()方法, 清除所有size(), 不影响capacity, 换句话来说就是不会释放vector掌管的内存.</p>
<p>insert(), 相当有用的成员函数. 整个insert函数有五个重载, 都非常常用.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在pos前面插入value</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator <span class="title">insert</span><span class="params">( const_iterator pos, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在pos前面插入value</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, T&amp;&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator <span class="title">insert</span><span class="params">( const_iterator pos, T&amp;&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos前面插入count个value</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, size_type count, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator</span></span><br><span class="line"><span class="function">    <span class="title">insert</span><span class="params">( const_iterator pos, size_type count, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos前面插入[first, last)之间的元素</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, InputIt first, InputIt last )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator <span class="title">insert</span><span class="params">( const_iterator pos, InputIt first, InputIt last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos前面插入initializer_list</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> iterator <span class="title">insert</span><span class="params">( const_iterator pos,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure>
<p>在cppreference里面也有示例代码, 里面都是使用构造函数的例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> id, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; id &lt;&lt; <span class="string">&quot;. &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> x : container)</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">3</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, c1);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> it = c1.<span class="built_in">begin</span>();</span><br><span class="line">    it = c1.<span class="built_in">insert</span>(it, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>, c1);</span><br><span class="line"> </span><br><span class="line">    c1.<span class="built_in">insert</span>(it, <span class="number">2</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>, c1);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// `it` no longer valid, get a new one:</span></span><br><span class="line">    it = c1.<span class="built_in">begin</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">2</span>, <span class="number">400</span>)</span></span>;</span><br><span class="line">    c1.<span class="built_in">insert</span>(std::<span class="built_in">next</span>(it, <span class="number">2</span>), c2.<span class="built_in">begin</span>(), c2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>, c1);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">501</span>, <span class="number">502</span>, <span class="number">503</span>&#125;;</span><br><span class="line">    c1.<span class="built_in">insert</span>(c1.<span class="built_in">begin</span>(), arr, arr + std::<span class="built_in">size</span>(arr));</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>, c1);</span><br><span class="line"> </span><br><span class="line">    c1.<span class="built_in">insert</span>(c1.<span class="built_in">end</span>(), &#123;<span class="number">601</span>, <span class="number">602</span>, <span class="number">603</span>&#125;);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">6</span>, c1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不知道有没有人感觉到一个疑问, 既然insert的一个重载的一个函数里面, 接受的参数类型(其中一个)为什么会是const T&amp;, insert的时候, vector内部存的一直就是某个元素的副本而不是引用或其本身. 写成引用只是为了方便传参, 这样传参的时候可以省下一次拷贝.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">    <span class="keyword">typename</span> vector&lt;_Tp, _Alloc&gt;::iterator</span><br><span class="line">    vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">    <span class="built_in">insert</span>(const_iterator __position, <span class="type">const</span> value_type&amp; __x)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">insert</span>(iterator __position, <span class="type">const</span> value_type&amp; __x)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> size_type __n = __position - <span class="built_in">begin</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage)</span><br><span class="line">	<span class="keyword">if</span> (__position == <span class="built_in">end</span>())</span><br><span class="line">	  &#123;</span><br><span class="line">	    _GLIBCXX_ASAN_ANNOTATE_GROW(<span class="number">1</span>);</span><br><span class="line">	    _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">				     __x);</span><br><span class="line">	    ++<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">	    _GLIBCXX_ASAN_ANNOTATE_GREW(<span class="number">1</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">	    <span class="type">const</span> <span class="keyword">auto</span> __pos = <span class="built_in">begin</span>() + (__position - <span class="built_in">cbegin</span>());</span><br><span class="line">	    <span class="comment">// __x could be an existing element of this vector, so make a</span></span><br><span class="line">	    <span class="comment">// copy of it before _M_insert_aux moves elements around.</span></span><br><span class="line">	    _Temporary_value __x_copy(<span class="keyword">this</span>, __x);</span><br><span class="line">	    _M_insert_aux(__pos, std::<span class="built_in">move</span>(__x_copy._M_val()));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	    _M_insert_aux(__position, __x);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">	_M_realloc_insert(<span class="built_in">begin</span>() + (__position - <span class="built_in">cbegin</span>()), __x);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	_M_realloc_insert(__position, __x);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在源代码中, 还特意注释了这一点. 甚至这个函数看上去很乱, 因为各个标准都不一样.</p>
<h2 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> deque</h2>
<p>double-ended queue. 也经常翻译成双端队列. 我们还是看时间复杂度:</p>
<blockquote>
<p>The complexity (efficiency) of common operations on deques is as follows:</p>
<ul>
<li>Random access - constant O(1).</li>
<li>Insertion or removal of elements at the end or beginning - constant O(1).</li>
<li>Insertion or removal of elements - linear O(n).</li>
</ul>
<p><code>std::deque</code> meets the requirements of Container, AllocatorAwareContainer, SequenceContainer and ReversibleContainer.</p>
</blockquote>
<p>随机访问时间复杂度O(1), 在头部尾部都是O(1), 中间是线性的.</p>
<p>回顾一下vector的, vector几乎和这个差不多, 也是随机访问O(1), 中间插入O(n), 但是只是在末尾插入是常数复杂度, 头部插入是O(n). 这样看来好像deque全面优于vector?</p>
<p>deque的内存分布是一系列固定长度的内存小块, 然后组合起来.</p>
<p><img src="https://pic.imgdb.cn/item/65274551c458853aefaf3969.png" alt="" /></p>
<p>从这个图也可以很直观地看出来, 无论是在头部删除还是在尾部删除都是常数. 主要是在两端预留空间, 其实很有链表的特色. 例如我如果删除一个元素, 只需要把begin往后拨一位.</p>
<p>其实和链表非常相似, 那么这个头尾时间复杂度为O(1)反而不足为奇, 反而需要问问是随机访问如何做到O(1)的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">typename</span> deque&lt;_Tp, _Allocator&gt;::reference</span><br><span class="line">deque&lt;_Tp, _Allocator&gt;::<span class="keyword">operator</span>[](size_type __i) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    size_type __p = __start_ + __i;</span><br><span class="line">    <span class="keyword">return</span> *(*(__map_.<span class="built_in">begin</span>() + __p / __block_size) + __p % __block_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面访问下标为i的内容, 首先先算出p, 等于start+i. 这是我们希望的位置, 但是如何快速跳转呢? 如果是链表, 是不是就得不断地往后跳转, 迭代器一位一位往后next得到结果. 但是我们注意这里deque的做法.</p>
<p>先通过map.begin()加上 p/block_size获取对应chunk的迭代器. 例如在上图中我们访问下标为6, 因为一个块是5, 所以需要map的迭代器往前一位, 指向chunk1. 然后取余得到是1, 也就是说<code>*(__map_.begin() + __p / __block_size)</code>就是chunk1这个数组, 或者说是其首地址. 然后再来看, 最开始是start指向2, 因为<code>data[0]</code>是指向所在数组的下标2, 2加上6为8, 8取模5是3. 也就是说需要访问的元素是在当前数组的第三位.</p>
<p>总结来看. 访问的下标i加上最开始元素所在chunk的下标start共同组成了一个p, 这个p和chunk_size除法的部分用来跳转块, 取模的部分用来标识块也就是chunk数组的下标.</p>
<p>相比较而言, 同样都是O(1)的random access, vector的O(1)看上去还是更加O(1)一些.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="keyword">operator</span>[](size_type __n) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(__n &lt; <span class="built_in">size</span>(), <span class="string">&quot;vector[] index out of bounds&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__begin_[__n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题外话: deque只是规定了行为, 至于具体实现, 还得看各个编译器的实现. 而且还有个很有意思的点就是对于<code>operator[]</code>的实现, 可以看见libcxx里面是有一个内存检查的, 而下面是libstdc++的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libstdc++</span></span><br><span class="line">  _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR</span><br><span class="line">  reference</span><br><span class="line">  <span class="keyword">operator</span>[](size_type __n) _GLIBCXX_NOEXCEPT</span><br><span class="line">  &#123;</span><br><span class="line">__glibcxx_requires_subscript(__n);</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>似乎没有检查. 本来上面说过at有检查, 但是libcxx似乎下标访问也会检查. 还没有实测clang++搭配libc++的报错情况.</p>
<p>deque的成员函数没有什么好说的. 和vector比较类似.</p>
<h2 id="forward_listc11"><a class="markdownIt-Anchor" href="#forward_listc11"></a> forward_list(c++11)</h2>
<blockquote>
<p>std::forward_list is a container that supports fast insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is implemented as a singly-linked list. Compared to std::list this container provides more space efficient storage when bidirectional iteration is not needed.</p>
</blockquote>
<p>这一个就略过, 这个只是一个更加&quot;more space efficient&quot;的list. 由C++11引入.</p>
<h2 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h2>
<p>其实STL的很多成员函数都大差不差, 所以下面只说明一下比较有新意的一些成员函数.</p>
<p>在operation一栏里面, 有一些很有意思的函数.</p>
<h3 id="remove和remove_if"><a class="markdownIt-Anchor" href="#remove和remove_if"></a> remove()和remove_if()</h3>
<p>对于一个list, remove就是删除所有和参数一样的元素嘛, 这个remove_if就很酷炫, 它的参数可以是一个lambda表达式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reference的示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">-1</span>, <span class="number">12</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> count1 = l.<span class="built_in">remove</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; count1 &lt;&lt; <span class="string">&quot; elements equal to 1 were removed\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> count2 = l.<span class="built_in">remove_if</span>([](<span class="type">int</span> n)&#123; <span class="keyword">return</span> n &gt; <span class="number">10</span>; &#125;);</span><br><span class="line">    std::cout &lt;&lt; count2 &lt;&lt; <span class="string">&quot; elements greater than 10 were removed\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finally, the list contains: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : l)</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以根据函数的要求来删除元素. 其他的就不赘述了, 接下来也是重头戏, associative container.</p>
<h1 id="associative-containers"><a class="markdownIt-Anchor" href="#associative-containers"></a> Associative containers</h1>
<h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h2>
<blockquote>
<p>std::set is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as Red–black trees.</p>
</blockquote>
<p>对于set来说, search, removal, insertion都含有&quot;logarithmic complexity&quot;也就是O(logn)的复杂度. 而且经常使用红黑树来实现.</p>
<p>所以与其说学习set, 不如说需要了解红黑树的性质, 不然的话没有办法能够了解时间复杂度和set的优缺点从何而来.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/study/" rel="tag"># study</a>
              <a href="/tags/cpp/" rel="tag"># cpp</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/09/13/CPP%E4%B8%AD%E7%9A%84cin%E5%92%8Ccout%E8%BF%90%E8%A1%8C%E7%BC%93%E6%85%A2/" rel="prev" title="CPP中的cin和cout运行缓慢">
                  <i class="fa fa-angle-left"></i> CPP中的cin和cout运行缓慢
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/14/gdb%E4%BB%8E%E6%97%A0%E7%9F%A5%E5%88%B0%E8%83%BD%E7%94%A8/" rel="next" title="gdb从无知到能用">
                  gdb从无知到能用 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wonderlandKid</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" integrity="sha256-3574TpfThVfeAhg+I4+N39EJiLN3QUkuEsMVe8hWAR4=" crossorigin="anonymous">



</body>
</html>
